CCS PCH C Compiler, Version 4.114, 93460303               11-mar-12 20:14

               Filename: C:\Users\MrDarkness\X-Weather\Rx\rx.lst

               ROM used: 19628 bytes (30%)
                         Largest free fragment is 44624
               RAM used: 1778 (53%) at main() level
                         1960 (59%) worst case
               Stack:    9 worst case (7 in main + 2 for interrupts)

*
00500:  GOTO   42B4
*
00508:  MOVWF  04
0050A:  MOVFF  FD8,05
0050E:  MOVFF  FE0,06
00512:  MOVLB  0
00514:  MOVFF  FE9,0C
00518:  MOVFF  FEA,07
0051C:  MOVFF  FE1,08
00520:  MOVFF  FE2,09
00524:  MOVFF  FD9,0A
00528:  MOVFF  FDA,0B
0052C:  MOVFF  FF3,12
00530:  MOVFF  FF4,13
00534:  MOVFF  FFA,14
00538:  MOVFF  FF5,15
0053C:  MOVFF  FF6,16
00540:  MOVFF  FF7,17
00544:  MOVFF  00,0E
00548:  MOVFF  01,0F
0054C:  MOVFF  02,10
00550:  MOVFF  03,11
00554:  BTFSS  FF0.3
00556:  GOTO   0560
0055A:  BTFSC  FF0.0
0055C:  GOTO   0CDA
00560:  BTFSS  F9D.5
00562:  GOTO   056C
00566:  BTFSC  F9E.5
00568:  GOTO   0C90
0056C:  MOVFF  0E,00
00570:  MOVFF  0F,01
00574:  MOVFF  10,02
00578:  MOVFF  11,03
0057C:  MOVFF  0C,FE9
00580:  MOVFF  07,FEA
00584:  BSF    07.7
00586:  MOVFF  08,FE1
0058A:  MOVFF  09,FE2
0058E:  MOVFF  0A,FD9
00592:  MOVFF  0B,FDA
00596:  MOVFF  12,FF3
0059A:  MOVFF  13,FF4
0059E:  MOVFF  14,FFA
005A2:  MOVFF  15,FF5
005A6:  MOVFF  16,FF6
005AA:  MOVFF  17,FF7
005AE:  MOVF   04,W
005B0:  MOVFF  06,FE0
005B4:  MOVFF  05,FD8
005B8:  RETFIE 0
.................... #if defined(__PCH__) 
.................... #include <rx.h>         // Headers 
.................... #include <18F4680.h> 
.................... //////// Standard Header file for the PIC18F4680 device //////////////// 
.................... #device PIC18F4680 
.................... #list 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
.................... //#FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BBSIZ1K                  //1K words Boot Block size 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
....................  
.................... #use delay(crystal=8000000) 
*
01B7C:  MOVLW  07
01B7E:  MOVWF  FEA
01B80:  MOVLW  3E
01B82:  MOVWF  FE9
01B84:  MOVF   FEF,W
01B86:  BZ    1BA2
01B88:  MOVLW  02
01B8A:  MOVWF  01
01B8C:  CLRF   00
01B8E:  DECFSZ 00,F
01B90:  BRA    1B8E
01B92:  DECFSZ 01,F
01B94:  BRA    1B8C
01B96:  MOVLW  97
01B98:  MOVWF  00
01B9A:  DECFSZ 00,F
01B9C:  BRA    1B9A
01B9E:  DECFSZ FEF,F
01BA0:  BRA    1B88
01BA2:  GOTO   4CB8 (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,errors) 
*
00C78:  BTFSS  F9E.5
00C7A:  BRA    0C78
00C7C:  MOVFF  FAB,19
00C80:  MOVFF  FAE,01
00C84:  BTFSS  19.1
00C86:  BRA    0C8C
00C88:  BCF    FAB.4
00C8A:  BSF    FAB.4
00C8C:  GOTO   0CB0 (RETURN)
....................  
.................... #endif 
.................... #include <bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                       BOOTLOADER.H                                //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example bootloader (ex_bootloader.c).                     //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  LOADER_END and LOADER_SIZE may need to be adjusted for a         //// 
.................... ////  specific chip and bootloader.                                    //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #if defined(__PCM__) 
....................    #define LOADER_END   0x1FF 
....................    #define LOADER_SIZE   0x1BF 
.................... #elif defined(__PCH__) 
....................    #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
....................    #warning FLASH_SIZE 
....................    #if ((0x500 % FLASH_SIZE) == 0 )       //IF 0x500 is even flash boundary 
....................       #define LOADER_END   0x4FF 
....................       #define LOADER_SIZE  0x3FF 
....................    #else                                  //ELSE, goto next even boundary 
....................       #define LOADER_END   ((0x500+FLASH_SIZE-(0x500%FLASH_SIZE))-1) 
....................       #define LOADER_SIZE  (LOADER_END-0x100) 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  
.................... #if defined(__PCM__) 
....................    #build(reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #elif defined(__PCH__) 
....................    #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
.................... #endif 
....................  
.................... #org 0, LOADER_END {} 
....................  
.................... #endif 
....................  
....................    
....................  
....................    
.................... /*DEFINICIONES*/   
....................  
....................  
.................... //#define GLCD_RST     PIN_C0 
.................... //#define GLCD_CS1     PIN_A5   // Chip Selection 1 
.................... #define FAST_GLCD 
....................  
....................  
....................  
....................  
.................... #define BUFFER_SIZE 32     //Buffer Serial 
.................... #define bkbhit (next_in!=next_out) //Serial 
....................  
.................... /*FIN**DEFINICIONES*/   
....................  
....................  
....................  
.................... /*VARIABLES**GLOBALES*/ 
....................  
.................... BYTE buffer[BUFFER_SIZE];  //Buffer Serial 
.................... BYTE next_in = 0;          //Buffer Serial 
.................... BYTE next_out = 0;         //Buffer Serial 
....................  
....................  
.................... int8 i; 
.................... int8 control = 0; 
.................... int pressed = 0; 
.................... int config=0; 
.................... int firstrun = 1; 
.................... int confpos,conftype,selconf; 
.................... int up,lastup; 
.................... int down,lastdown; 
.................... int enter,lastenter; 
.................... int left,lastleft; 
.................... int lastright,right; 
....................  
....................  
....................  
.................... char MENUTITLE[] = "Configuracion"; 
....................  
.................... char MENU1[] =   "-Fecha y Hora"; 
....................  
.................... char MENU2[] =   "-Temperatura   "; 
.................... char MENU2ITEM1[] = "--Celsius"; 
.................... char MENU2ITEM2[] = "--Farenheit"; 
....................  
.................... char MENU3[] =   "-Presion"; 
.................... char MENU3ITEM1[] = "--Pascal"; 
.................... char MENU3ITEM2[] = "--Milibar"; 
....................  
....................  
.................... char MENU4[] =   "-Velocidad"; 
.................... char MENU4ITEM1[] = "--m/s"; 
.................... char MENU4ITEM2[] = "--km/h"; 
.................... char MENU4ITEM3[] = "--Nudos"; 
....................  
....................  
.................... char dia[] = "01"; 
.................... char mes[] = "01"; 
.................... char ao[] = "01"; 
.................... char hora[] = "10"; 
.................... char min[] = "10"; 
.................... char aop[] = "AM"; 
....................  
....................  
.................... char UniTemp[3] = "C"; 
.................... char UniPres[4] = "Pa "; 
....................  
.................... char UniVel[5] = "m/s "; 
....................  
.................... /*FIN**VARIBLES**GLOBALES*/ 
....................  
....................  
....................  
....................  
.................... /**INCLUDES**/ 
....................  
.................... #include "../HDM64GS12.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_A5   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B0   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B3   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B4   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_C0   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(int8 x, int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    int8 left[512]; 
....................    int8 right[512]; 
.................... } displayData; 
....................  
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
00E44:  BCF    F94.0
00E46:  BSF    F8B.0
....................    output_low(GLCD_E); 
00E48:  BCF    F93.4
00E4A:  BCF    F8A.4
....................    output_low(GLCD_CS1); 
00E4C:  BCF    F92.5
00E4E:  BCF    F89.5
....................    output_low(GLCD_CS2); 
00E50:  BCF    F93.0
00E52:  BCF    F8A.0
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
00E54:  BCF    F93.2
00E56:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
00E58:  MOVLB  7
00E5A:  CLRF   x83
00E5C:  MOVLW  C0
00E5E:  MOVWF  x84
00E60:  MOVLB  0
00E62:  RCALL  0CF2
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
00E64:  MOVLW  01
00E66:  MOVLB  7
00E68:  MOVWF  x83
00E6A:  MOVLW  C0
00E6C:  MOVWF  x84
00E6E:  MOVLB  0
00E70:  RCALL  0CF2
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
00E72:  MOVLB  7
00E74:  CLRF   x83
00E76:  MOVLW  40
00E78:  MOVWF  x84
00E7A:  MOVLB  0
00E7C:  RCALL  0CF2
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
00E7E:  MOVLW  01
00E80:  MOVLB  7
00E82:  MOVWF  x83
00E84:  MOVLW  40
00E86:  MOVWF  x84
00E88:  MOVLB  0
00E8A:  RCALL  0CF2
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
00E8C:  MOVLB  7
00E8E:  CLRF   x83
00E90:  MOVLW  B8
00E92:  MOVWF  x84
00E94:  MOVLB  0
00E96:  RCALL  0CF2
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
00E98:  MOVLW  01
00E9A:  MOVLB  7
00E9C:  MOVWF  x83
00E9E:  MOVLW  B8
00EA0:  MOVWF  x84
00EA2:  MOVLB  0
00EA4:  RCALL  0CF2
....................  
....................    if(mode == ON) 
00EA6:  MOVLB  7
00EA8:  DECFSZ x3D,W
00EAA:  BRA    0EC8
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
00EAC:  CLRF   x83
00EAE:  MOVLW  3F
00EB0:  MOVWF  x84
00EB2:  MOVLB  0
00EB4:  RCALL  0CF2
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
00EB6:  MOVLW  01
00EB8:  MOVLB  7
00EBA:  MOVWF  x83
00EBC:  MOVLW  3F
00EBE:  MOVWF  x84
00EC0:  MOVLB  0
00EC2:  RCALL  0CF2
....................    } 
....................    else 
00EC4:  BRA    0EE0
00EC6:  MOVLB  7
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
00EC8:  CLRF   x83
00ECA:  MOVLW  3E
00ECC:  MOVWF  x84
00ECE:  MOVLB  0
00ED0:  RCALL  0CF2
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
00ED2:  MOVLW  01
00ED4:  MOVLB  7
00ED6:  MOVWF  x83
00ED8:  MOVLW  3E
00EDA:  MOVWF  x84
00EDC:  MOVLB  0
00EDE:  RCALL  0CF2
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
00EE0:  MOVLB  7
00EE2:  CLRF   x48
00EE4:  MOVLB  0
00EE6:  RCALL  0D32
....................  
....................    #ifdef FAST_GLCD 
....................    glcd_update(); 
00EE8:  RCALL  0D8C
....................    #endif 
.................... } 
00EEA:  GOTO   4B96 (RETURN)
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    int8 i, j; 
....................    int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
*
00D8C:  MOVLB  7
00D8E:  CLRF   x7F
00D90:  MOVLW  EA
00D92:  MOVWF  x7E
....................    p2 = displayData.right; 
00D94:  MOVLW  02
00D96:  MOVWF  x81
00D98:  MOVLW  EA
00D9A:  MOVWF  x80
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
00D9C:  CLRF   x7C
00D9E:  MOVF   x7C,W
00DA0:  SUBLW  07
00DA2:  BNC   0E40
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
00DA4:  BCF    F93.2
00DA6:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
00DA8:  CLRF   x83
00DAA:  MOVLW  40
00DAC:  MOVWF  x84
00DAE:  MOVLB  0
00DB0:  RCALL  0CF2
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
00DB2:  MOVLW  01
00DB4:  MOVLB  7
00DB6:  MOVWF  x83
00DB8:  MOVLW  40
00DBA:  MOVWF  x84
00DBC:  MOVLB  0
00DBE:  RCALL  0CF2
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
00DC0:  MOVLB  7
00DC2:  MOVF   x7C,W
00DC4:  IORLW  B8
00DC6:  MOVWF  x82
00DC8:  CLRF   x83
00DCA:  MOVWF  x84
00DCC:  MOVLB  0
00DCE:  RCALL  0CF2
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
00DD0:  MOVLB  7
00DD2:  MOVF   x7C,W
00DD4:  IORLW  B8
00DD6:  MOVWF  x82
00DD8:  MOVLW  01
00DDA:  MOVWF  x83
00DDC:  MOVFF  782,784
00DE0:  MOVLB  0
00DE2:  RCALL  0CF2
....................       output_high(GLCD_DI);                     // Set for data 
00DE4:  BCF    F93.2
00DE6:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
00DE8:  MOVLB  7
00DEA:  CLRF   x7D
00DEC:  MOVF   x7D,W
00DEE:  SUBLW  3F
00DF0:  BNC   0E3C
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
00DF2:  MOVFF  77F,03
00DF6:  MOVF   x7E,W
00DF8:  INCF   x7E,F
00DFA:  BTFSC  FD8.2
00DFC:  INCF   x7F,F
00DFE:  MOVWF  FE9
00E00:  MOVFF  03,FEA
00E04:  MOVFF  FEF,782
00E08:  CLRF   x83
00E0A:  MOVFF  782,784
00E0E:  MOVLB  0
00E10:  RCALL  0CF2
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
00E12:  MOVLB  7
00E14:  MOVFF  781,03
00E18:  MOVF   x80,W
00E1A:  INCF   x80,F
00E1C:  BTFSC  FD8.2
00E1E:  INCF   x81,F
00E20:  MOVWF  FE9
00E22:  MOVFF  03,FEA
00E26:  MOVFF  FEF,782
00E2A:  MOVLW  01
00E2C:  MOVWF  x83
00E2E:  MOVFF  782,784
00E32:  MOVLB  0
00E34:  RCALL  0CF2
....................       } 
00E36:  MOVLB  7
00E38:  INCF   x7D,F
00E3A:  BRA    0DEC
....................    } 
00E3C:  INCF   x7C,F
00E3E:  BRA    0D9E
.................... } 
00E40:  MOVLB  0
00E42:  RETLW  00
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(int8 x, int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8* p; 
....................    int16 temp; 
....................    temp =  y/8; 
*
00EEE:  MOVLB  7
00EF0:  CLRF   xA0
00EF2:  RRCF   x9B,W
00EF4:  MOVWF  x9F
00EF6:  RRCF   x9F,F
00EF8:  RRCF   x9F,F
00EFA:  MOVLW  1F
00EFC:  ANDWF  x9F,F
....................    temp *= 64; 
00EFE:  RLCF   x9F,F
00F00:  RLCF   xA0,F
00F02:  RLCF   x9F,F
00F04:  RLCF   xA0,F
00F06:  RLCF   x9F,F
00F08:  RLCF   xA0,F
00F0A:  RLCF   x9F,F
00F0C:  RLCF   xA0,F
00F0E:  RLCF   x9F,F
00F10:  RLCF   xA0,F
00F12:  RLCF   x9F,F
00F14:  RLCF   xA0,F
00F16:  MOVLW  C0
00F18:  ANDWF  x9F,F
....................    temp += x; 
00F1A:  MOVF   x9A,W
00F1C:  ADDWF  x9F,F
00F1E:  MOVLW  00
00F20:  ADDWFC xA0,F
....................  
....................    if(x > 63) 
00F22:  MOVF   x9A,W
00F24:  SUBLW  3F
00F26:  BC    0F42
....................    { 
....................       p = displayData.right + temp - 64; 
00F28:  MOVLW  EA
00F2A:  ADDWF  x9F,W
00F2C:  MOVWF  xA1
00F2E:  MOVLW  02
00F30:  ADDWFC xA0,W
00F32:  MOVWF  xA2
00F34:  MOVLW  40
00F36:  SUBWF  xA1,W
00F38:  MOVWF  x9D
00F3A:  MOVLW  00
00F3C:  SUBWFB xA2,W
00F3E:  MOVWF  x9E
....................    } 
....................    else 
00F40:  BRA    0F4E
....................    { 
....................       p = displayData.left + temp; 
00F42:  MOVLW  EA
00F44:  ADDWF  x9F,W
00F46:  MOVWF  x9D
00F48:  MOVLW  00
00F4A:  ADDWFC xA0,W
00F4C:  MOVWF  x9E
....................    } 
....................  
....................    if(color) 
00F4E:  MOVF   x9C,F
00F50:  BZ    0F7C
....................    { 
....................       bit_set(*p, y%8); 
00F52:  MOVFF  79E,03
00F56:  MOVFF  79D,FE9
00F5A:  MOVFF  79E,FEA
00F5E:  MOVF   x9B,W
00F60:  ANDLW  07
00F62:  MOVWF  xA1
00F64:  MOVLW  01
00F66:  MOVWF  00
00F68:  MOVF   xA1,W
00F6A:  MOVWF  01
00F6C:  BZ    0F76
00F6E:  BCF    FD8.0
00F70:  RLCF   00,F
00F72:  DECFSZ 01,F
00F74:  BRA    0F6E
00F76:  MOVF   00,W
00F78:  IORWF  FEF,F
....................    } 
....................    else 
00F7A:  BRA    0FA6
....................    { 
....................       bit_clear(*p, y%8); 
00F7C:  MOVFF  79E,03
00F80:  MOVFF  79D,FE9
00F84:  MOVFF  79E,FEA
00F88:  MOVF   x9B,W
00F8A:  ANDLW  07
00F8C:  MOVWF  xA1
00F8E:  MOVLW  01
00F90:  MOVWF  00
00F92:  MOVF   xA1,W
00F94:  MOVWF  01
00F96:  BZ    0FA0
00F98:  BCF    FD8.0
00F9A:  RLCF   00,F
00F9C:  DECFSZ 01,F
00F9E:  BRA    0F98
00FA0:  MOVF   00,W
00FA2:  XORLW  FF
00FA4:  ANDWF  FEF,F
....................    } 
.................... } 
00FA6:  MOVLB  0
00FA8:  RETLW  00
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
....................    { 
....................       x -= 64; 
....................       side = GLCD_RIGHT; 
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
....................    output_high(GLCD_DI);                        // Set for data 
....................    glcd_readByte(side);                         // Need two reads to get data 
....................    data = glcd_readByte(side);                  //  at new address 
....................  
....................    if(color == ON) 
....................       bit_set(data, y%8);        // Turn the pixel on 
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
....................    glcd_writeByte(side, x);      // Set the horizontal address 
....................    output_high(GLCD_DI);         // Set for data 
....................    glcd_writeByte(side, data);   // Write the pixel data 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8  data; 
....................    int8  *p1, *p2; 
....................    int16 i; 
....................  
....................    p1 = displayData.left; 
*
00D32:  MOVLB  7
00D34:  CLRF   x4B
00D36:  MOVLW  EA
00D38:  MOVWF  x4A
....................    p2 = displayData.right; 
00D3A:  MOVLW  02
00D3C:  MOVWF  x4D
00D3E:  MOVLW  EA
00D40:  MOVWF  x4C
....................    data = 0xFF * color; 
00D42:  MOVF   x48,W
00D44:  MULLW  FF
00D46:  MOVFF  FF3,749
....................  
....................    for(i=0; i<512; ++i) 
00D4A:  CLRF   x4F
00D4C:  CLRF   x4E
00D4E:  MOVF   x4F,W
00D50:  SUBLW  01
00D52:  BNC   0D88
....................    { 
....................       *p1++ = data; 
00D54:  MOVFF  74B,03
00D58:  MOVF   x4A,W
00D5A:  INCF   x4A,F
00D5C:  BTFSC  FD8.2
00D5E:  INCF   x4B,F
00D60:  MOVWF  FE9
00D62:  MOVFF  03,FEA
00D66:  MOVFF  749,FEF
....................       *p2++ = data; 
00D6A:  MOVFF  74D,03
00D6E:  MOVF   x4C,W
00D70:  INCF   x4C,F
00D72:  BTFSC  FD8.2
00D74:  INCF   x4D,F
00D76:  MOVWF  FE9
00D78:  MOVFF  03,FEA
00D7C:  MOVFF  749,FEF
....................    } 
00D80:  INCF   x4E,F
00D82:  BTFSC  FD8.2
00D84:  INCF   x4F,F
00D86:  BRA    0D4E
.................... } 
00D88:  MOVLB  0
00D8A:  RETLW  00
.................... #else 
.................... { 
....................    int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    if(side)                   // Choose which side to write to 
*
00CF2:  MOVLB  7
00CF4:  MOVF   x83,F
00CF6:  BZ    0CFE
....................       output_high(GLCD_CS2); 
00CF8:  BCF    F93.0
00CFA:  BSF    F8A.0
....................    else 
00CFC:  BRA    0D02
....................       output_high(GLCD_CS1); 
00CFE:  BCF    F92.5
00D00:  BSF    F89.5
....................  
....................    output_low(GLCD_RW);       // Set for writing 
00D02:  BCF    F93.3
00D04:  BCF    F8A.3
....................    output_d(data);            // Put the data on the port 
00D06:  CLRF   F95
00D08:  MOVFF  784,F8C
....................    delay_cycles(16); 
00D0C:  MOVLW  05
00D0E:  MOVWF  00
00D10:  DECFSZ 00,F
00D12:  BRA    0D10
....................    output_high(GLCD_E);       // Pulse the enable pin 
00D14:  BCF    F93.4
00D16:  BSF    F8A.4
....................    delay_cycles(80); 
00D18:  MOVLW  1A
00D1A:  MOVWF  00
00D1C:  DECFSZ 00,F
00D1E:  BRA    0D1C
00D20:  NOP   
....................    output_low(GLCD_E); 
00D22:  BCF    F93.4
00D24:  BCF    F8A.4
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
00D26:  BCF    F92.5
00D28:  BCF    F89.5
....................    output_low(GLCD_CS2); 
00D2A:  BCF    F93.0
00D2C:  BCF    F8A.0
.................... } 
00D2E:  MOVLB  0
00D30:  RETLW  00
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
....................    output_high(GLCD_RW);      // Set for reading 
....................  
....................    if(side)                   // Choose which side to write to 
....................       output_high(GLCD_CS2); 
....................    else 
....................       output_high(GLCD_CS1); 
....................  
....................    delay_cycles(16); 
....................    output_high(GLCD_E);       // Pulse the enable pin 
....................    delay_cycles(64); 
....................    data = input_d();          // Get the data from the display's output register 
....................    output_low(GLCD_E); 
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
....................    output_low(GLCD_CS2); 
....................    return data;               // Return the read data 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "../graphics.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(int16 x1, int16 y1, int16 x2, int16 y2, int1 color) 
.................... #else 
.................... void glcd_line(int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... #endif 
.................... { 
*
00FAA:  MOVLW  01
00FAC:  MOVLB  7
00FAE:  MOVWF  x90
00FB0:  MOVWF  x91
00FB2:  CLRF   x96
....................    int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
00FB4:  MOVF   x87,W
00FB6:  SUBWF  x89,W
00FB8:  MOVWF  x97
00FBA:  MOVF   x97,W
00FBC:  BTFSS  x97.7
00FBE:  BRA    0FC6
00FC0:  MOVLW  00
00FC2:  BSF    FD8.0
00FC4:  SUBFWB x97,W
00FC6:  CLRF   03
00FC8:  MOVWF  x8E
00FCA:  MOVFF  03,78F
....................    dy = abs((signed int8)(y2 - y1)); 
00FCE:  MOVF   x88,W
00FD0:  SUBWF  x8A,W
00FD2:  MOVWF  x97
00FD4:  MOVF   x97,W
00FD6:  BTFSS  x97.7
00FD8:  BRA    0FE0
00FDA:  MOVLW  00
00FDC:  BSF    FD8.0
00FDE:  SUBFWB x97,W
00FE0:  CLRF   03
00FE2:  MOVWF  x8C
00FE4:  MOVFF  03,78D
....................    #endif 
....................  
....................    if(x1 > x2) 
00FE8:  MOVF   x87,W
00FEA:  SUBWF  x89,W
00FEC:  BC    0FF2
....................       addx = -1; 
00FEE:  MOVLW  FF
00FF0:  MOVWF  x90
....................    if(y1 > y2) 
00FF2:  MOVF   x88,W
00FF4:  SUBWF  x8A,W
00FF6:  BC    0FFC
....................       addy = -1; 
00FF8:  MOVLW  FF
00FFA:  MOVWF  x91
....................  
....................    if(dx >= dy) 
00FFC:  MOVF   x8D,W
00FFE:  SUBWF  x8F,W
01000:  BNC   1078
01002:  BNZ   100A
01004:  MOVF   x8C,W
01006:  SUBWF  x8E,W
01008:  BNC   1078
....................    { 
....................       dy *= 2; 
0100A:  BCF    FD8.0
0100C:  RLCF   x8C,F
0100E:  RLCF   x8D,F
....................       P = dy - dx; 
01010:  MOVF   x8E,W
01012:  SUBWF  x8C,W
01014:  MOVWF  00
01016:  MOVF   x8F,W
01018:  SUBWFB x8D,W
0101A:  MOVFF  00,792
0101E:  MOVWF  x93
....................       diff = P - dx; 
01020:  MOVF   x8E,W
01022:  SUBWF  x92,W
01024:  MOVWF  x94
01026:  MOVF   x8F,W
01028:  SUBWFB x93,W
0102A:  MOVWF  x95
....................  
....................       for(; i<=dx; ++i) 
0102C:  MOVF   x8F,F
0102E:  BNZ   1036
01030:  MOVF   x96,W
01032:  SUBWF  x8E,W
01034:  BNC   1076
....................       { 
....................          glcd_pixel(x1, y1, color); 
01036:  MOVFF  787,79A
0103A:  MOVFF  788,79B
0103E:  MOVFF  78B,79C
01042:  MOVLB  0
01044:  RCALL  0EEE
....................  
....................          if(P < 0) 
01046:  MOVLB  7
01048:  BTFSC  x93.7
0104A:  BRA    104E
0104C:  BRA    105E
....................          { 
....................             P  += dy; 
0104E:  MOVF   x8C,W
01050:  ADDWF  x92,F
01052:  MOVF   x8D,W
01054:  ADDWFC x93,F
....................             x1 += addx; 
01056:  MOVF   x90,W
01058:  ADDWF  x87,W
0105A:  MOVWF  x87
....................          } 
....................          else 
0105C:  BRA    1072
....................          { 
....................             P  += diff; 
0105E:  MOVF   x94,W
01060:  ADDWF  x92,F
01062:  MOVF   x95,W
01064:  ADDWFC x93,F
....................             x1 += addx; 
01066:  MOVF   x90,W
01068:  ADDWF  x87,W
0106A:  MOVWF  x87
....................             y1 += addy; 
0106C:  MOVF   x91,W
0106E:  ADDWF  x88,W
01070:  MOVWF  x88
....................          } 
....................       } 
01072:  INCF   x96,F
01074:  BRA    102C
....................    } 
....................    else 
01076:  BRA    10E4
....................    { 
....................       dx *= 2; 
01078:  BCF    FD8.0
0107A:  RLCF   x8E,F
0107C:  RLCF   x8F,F
....................       P = dx - dy; 
0107E:  MOVF   x8C,W
01080:  SUBWF  x8E,W
01082:  MOVWF  00
01084:  MOVF   x8D,W
01086:  SUBWFB x8F,W
01088:  MOVFF  00,792
0108C:  MOVWF  x93
....................       diff = P - dy; 
0108E:  MOVF   x8C,W
01090:  SUBWF  x92,W
01092:  MOVWF  x94
01094:  MOVF   x8D,W
01096:  SUBWFB x93,W
01098:  MOVWF  x95
....................  
....................       for(; i<=dy; ++i) 
0109A:  MOVF   x8D,F
0109C:  BNZ   10A4
0109E:  MOVF   x96,W
010A0:  SUBWF  x8C,W
010A2:  BNC   10E4
....................       { 
....................          glcd_pixel(x1, y1, color); 
010A4:  MOVFF  787,79A
010A8:  MOVFF  788,79B
010AC:  MOVFF  78B,79C
010B0:  MOVLB  0
010B2:  RCALL  0EEE
....................  
....................          if(P < 0) 
010B4:  MOVLB  7
010B6:  BTFSC  x93.7
010B8:  BRA    10BC
010BA:  BRA    10CC
....................          { 
....................             P  += dx; 
010BC:  MOVF   x8E,W
010BE:  ADDWF  x92,F
010C0:  MOVF   x8F,W
010C2:  ADDWFC x93,F
....................             y1 += addy; 
010C4:  MOVF   x91,W
010C6:  ADDWF  x88,W
010C8:  MOVWF  x88
....................          } 
....................          else 
010CA:  BRA    10E0
....................          { 
....................             P  += diff; 
010CC:  MOVF   x94,W
010CE:  ADDWF  x92,F
010D0:  MOVF   x95,W
010D2:  ADDWFC x93,F
....................             x1 += addx; 
010D4:  MOVF   x90,W
010D6:  ADDWF  x87,W
010D8:  MOVWF  x87
....................             y1 += addy; 
010DA:  MOVF   x91,W
010DC:  ADDWF  x88,W
010DE:  MOVWF  x88
....................          } 
....................       } 
010E0:  INCF   x96,F
010E2:  BRA    109A
....................    } 
.................... } 
010E4:  MOVLB  0
010E6:  RETLW  00
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(int16 x1, int16 y1, int16 x2, int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(int8 x1, int8 y1, int8 x2, int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
010E8:  MOVLB  7
010EA:  MOVF   x80,F
010EC:  BZ    114A
....................    { 
....................       #ifdef LARGE_LCD 
....................       int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
010EE:  MOVF   x7E,W
010F0:  SUBWF  x7C,W
010F2:  BC    10FE
....................       { 
....................          xmin = x1; 
010F4:  MOVFF  77C,783
....................          xmax = x2; 
010F8:  MOVFF  77E,784
....................       } 
....................       else 
010FC:  BRA    1106
....................       { 
....................          xmin = x2; 
010FE:  MOVFF  77E,783
....................          xmax = x1; 
01102:  MOVFF  77C,784
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
01106:  MOVF   x7F,W
01108:  SUBWF  x7D,W
0110A:  BC    1116
....................       { 
....................          ymin = y1; 
0110C:  MOVFF  77D,785
....................          ymax = y2; 
01110:  MOVFF  77F,786
....................       } 
....................       else 
01114:  BRA    111E
....................       { 
....................          ymin = y2; 
01116:  MOVFF  77F,785
....................          ymax = y1; 
0111A:  MOVFF  77D,786
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
0111E:  MOVF   x83,W
01120:  SUBWF  x84,W
01122:  BNC   1148
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
01124:  MOVFF  785,782
01128:  MOVF   x82,W
0112A:  SUBWF  x86,W
0112C:  BNC   1144
....................          { 
....................             glcd_pixel(xmin, i, color); 
0112E:  MOVFF  783,79A
01132:  MOVFF  782,79B
01136:  MOVFF  781,79C
0113A:  MOVLB  0
0113C:  RCALL  0EEE
....................          } 
0113E:  MOVLB  7
01140:  INCF   x82,F
01142:  BRA    1128
....................       } 
01144:  INCF   x83,F
01146:  BRA    111E
....................    } 
....................    else 
01148:  BRA    11A6
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
0114A:  MOVFF  77C,787
0114E:  MOVFF  77D,788
01152:  MOVFF  77E,789
01156:  MOVFF  77D,78A
0115A:  MOVFF  781,78B
0115E:  MOVLB  0
01160:  RCALL  0FAA
....................       glcd_line(x1, y2, x2, y2, color); 
01162:  MOVFF  77C,787
01166:  MOVFF  77F,788
0116A:  MOVFF  77E,789
0116E:  MOVFF  77F,78A
01172:  MOVFF  781,78B
01176:  RCALL  0FAA
....................       glcd_line(x1, y1, x1, y2, color); 
01178:  MOVFF  77C,787
0117C:  MOVFF  77D,788
01180:  MOVFF  77C,789
01184:  MOVFF  77F,78A
01188:  MOVFF  781,78B
0118C:  RCALL  0FAA
....................       glcd_line(x2, y1, x2, y2, color); 
0118E:  MOVFF  77E,787
01192:  MOVFF  77D,788
01196:  MOVFF  77E,789
0119A:  MOVFF  77F,78A
0119E:  MOVFF  781,78B
011A2:  RCALL  0FAA
011A4:  MOVLB  7
....................    } 
.................... } 
011A6:  MOVLB  0
011A8:  RETLW  00
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(int16 x1, int16 y1, int16 x2, int16 y2, int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(int8 x1, int8 y1, int8 x2, int8 y2, int8 width, int1 color) 
.................... #endif 
.................... { 
*
01388:  MOVLW  01
0138A:  MOVLB  7
0138C:  MOVWF  x87
0138E:  MOVWF  x88
01390:  CLRF   x92
....................    int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
01392:  MOVF   x7C,W
01394:  SUBWF  x7E,W
01396:  MOVWF  x99
01398:  MOVF   x99,W
0139A:  BTFSS  x99.7
0139C:  BRA    13A4
0139E:  MOVLW  00
013A0:  BSF    FD8.0
013A2:  SUBFWB x99,W
013A4:  CLRF   03
013A6:  BTFSC  FE8.7
013A8:  DECF   03,F
013AA:  MOVWF  x85
013AC:  MOVFF  03,786
....................    dy = abs((signed int8)(y2 - y1)); 
013B0:  MOVF   x7D,W
013B2:  SUBWF  x7F,W
013B4:  MOVWF  x99
013B6:  MOVF   x99,W
013B8:  BTFSS  x99.7
013BA:  BRA    13C2
013BC:  MOVLW  00
013BE:  BSF    FD8.0
013C0:  SUBFWB x99,W
013C2:  CLRF   03
013C4:  BTFSC  FE8.7
013C6:  DECF   03,F
013C8:  MOVWF  x83
013CA:  MOVFF  03,784
....................    #endif 
....................  
....................    half_width = width/2; 
013CE:  BCF    FD8.0
013D0:  RRCF   x80,W
013D2:  MOVWF  x82
....................    c1 = -(dx*x1 + dy*y1); 
013D4:  MOVFF  786,79E
013D8:  MOVFF  785,79D
013DC:  CLRF   xA0
013DE:  MOVFF  77C,79F
013E2:  MOVLB  0
013E4:  RCALL  1334
013E6:  MOVFF  02,79A
013EA:  MOVFF  01,799
013EE:  MOVFF  784,79E
013F2:  MOVFF  783,79D
013F6:  MOVLB  7
013F8:  CLRF   xA0
013FA:  MOVFF  77D,79F
013FE:  MOVLB  0
01400:  RCALL  1334
01402:  MOVFF  02,03
01406:  MOVF   01,W
01408:  MOVLB  7
0140A:  ADDWF  x99,W
0140C:  MOVWF  01
0140E:  MOVF   x9A,W
01410:  ADDWFC 03,F
01412:  MOVF   01,W
01414:  XORLW  FF
01416:  ADDLW  01
01418:  MOVWF  x8E
0141A:  MOVLW  00
0141C:  SUBFWB 03,W
0141E:  MOVWF  x8F
....................    c2 = -(dx*x2 + dy*y2); 
01420:  MOVFF  786,79E
01424:  MOVFF  785,79D
01428:  CLRF   xA0
0142A:  MOVFF  77E,79F
0142E:  MOVLB  0
01430:  RCALL  1334
01432:  MOVFF  02,79A
01436:  MOVFF  01,799
0143A:  MOVFF  784,79E
0143E:  MOVFF  783,79D
01442:  MOVLB  7
01444:  CLRF   xA0
01446:  MOVFF  77F,79F
0144A:  MOVLB  0
0144C:  RCALL  1334
0144E:  MOVFF  02,03
01452:  MOVF   01,W
01454:  MOVLB  7
01456:  ADDWF  x99,W
01458:  MOVWF  01
0145A:  MOVF   x9A,W
0145C:  ADDWFC 03,F
0145E:  MOVF   01,W
01460:  XORLW  FF
01462:  ADDLW  01
01464:  MOVWF  x90
01466:  MOVLW  00
01468:  SUBFWB 03,W
0146A:  MOVWF  x91
....................  
....................    if(x1 > x2) 
0146C:  MOVF   x7C,W
0146E:  SUBWF  x7E,W
01470:  BC    148E
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
01472:  MOVFF  78F,794
01476:  MOVFF  78E,793
....................       c1 = c2; 
0147A:  MOVFF  791,78F
0147E:  MOVFF  790,78E
....................       c2 = temp; 
01482:  MOVFF  794,791
01486:  MOVFF  793,790
....................       addx = -1; 
0148A:  MOVLW  FF
0148C:  MOVWF  x87
....................    } 
....................    if(y1 > y2) 
0148E:  MOVF   x7D,W
01490:  SUBWF  x7F,W
01492:  BC    14B0
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
01494:  MOVFF  78F,796
01498:  MOVFF  78E,795
....................       c1 = c2; 
0149C:  MOVFF  791,78F
014A0:  MOVFF  790,78E
....................       c2 = temp; 
014A4:  MOVFF  796,791
014A8:  MOVFF  795,790
....................       addy = -1; 
014AC:  MOVLW  FF
014AE:  MOVWF  x88
....................    } 
....................  
....................    if(dx >= dy) 
014B0:  BTFSS  x84.7
014B2:  BRA    14BA
014B4:  BTFSS  x86.7
014B6:  BRA    14D0
014B8:  BRA    14BE
014BA:  BTFSC  x86.7
014BC:  BRA    1602
014BE:  MOVF   x84,W
014C0:  SUBWF  x86,W
014C2:  BTFSS  FD8.0
014C4:  BRA    1602
014C6:  BNZ   14D0
014C8:  MOVF   x83,W
014CA:  SUBWF  x85,W
014CC:  BTFSS  FD8.0
014CE:  BRA    1602
....................    { 
....................       P = 2*dy - dx; 
014D0:  CLRF   x9E
014D2:  MOVLW  02
014D4:  MOVWF  x9D
014D6:  MOVFF  784,7A0
014DA:  MOVFF  783,79F
014DE:  MOVLB  0
014E0:  RCALL  1334
014E2:  MOVLB  7
014E4:  MOVF   x85,W
014E6:  SUBWF  01,W
014E8:  MOVWF  x8A
014EA:  MOVF   x86,W
014EC:  SUBWFB 02,W
014EE:  MOVWF  x8B
....................       diff = P - dx; 
014F0:  MOVF   x85,W
014F2:  SUBWF  x8A,W
014F4:  MOVWF  x8C
014F6:  MOVF   x86,W
014F8:  SUBWFB x8B,W
014FA:  MOVWF  x8D
....................  
....................       for(i=0; i<=dx; ++i) 
014FC:  CLRF   x92
014FE:  BTFSC  x86.7
01500:  BRA    1600
01502:  MOVF   x86,F
01504:  BNZ   150E
01506:  MOVF   x92,W
01508:  SUBWF  x85,W
0150A:  BTFSS  FD8.0
0150C:  BRA    1600
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
0150E:  MOVLW  00
01510:  BSF    FD8.0
01512:  SUBFWB x82,W
01514:  MOVWF  x89
01516:  MOVF   x80,W
01518:  ANDLW  01
0151A:  ADDWF  x82,W
0151C:  BTFSC  x89.7
0151E:  BRA    1524
01520:  SUBWF  x89,W
01522:  BC    15BE
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
01524:  MOVFF  786,79E
01528:  MOVFF  785,79D
0152C:  CLRF   xA0
0152E:  MOVFF  77C,79F
01532:  MOVLB  0
01534:  RCALL  1334
01536:  MOVFF  02,79A
0153A:  MOVFF  01,799
0153E:  MOVLB  7
01540:  MOVF   x89,W
01542:  ADDWF  x7D,W
01544:  CLRF   03
01546:  MOVWF  00
01548:  BTFSC  FE8.7
0154A:  DECF   03,F
0154C:  MOVWF  x9B
0154E:  MOVFF  03,79C
01552:  MOVFF  784,79E
01556:  MOVFF  783,79D
0155A:  MOVFF  03,7A0
0155E:  MOVWF  x9F
01560:  MOVLB  0
01562:  RCALL  1334
01564:  MOVFF  02,03
01568:  MOVF   01,W
0156A:  MOVLB  7
0156C:  ADDWF  x99,W
0156E:  MOVWF  01
01570:  MOVF   x9A,W
01572:  ADDWFC 03,F
01574:  MOVFF  01,797
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
01578:  MOVF   x97,W
0157A:  ADDWF  x8E,W
0157C:  MOVWF  x99
0157E:  MOVLW  00
01580:  ADDWFC x8F,W
01582:  MOVWF  x9A
01584:  BTFSC  FE8.7
01586:  BRA    15BA
01588:  BRA    158A
0158A:  MOVF   x97,W
0158C:  ADDWF  x90,W
0158E:  MOVWF  x99
01590:  MOVLW  00
01592:  ADDWFC x91,W
01594:  MOVWF  x9A
01596:  BTFSC  FE8.7
01598:  BRA    15A4
0159A:  MOVF   x9A,F
0159C:  BNZ   15BA
0159E:  MOVF   x99,W
015A0:  SUBLW  00
015A2:  BNC   15BA
....................                glcd_pixel(x1, y1+j, color); 
015A4:  MOVF   x89,W
015A6:  ADDWF  x7D,W
015A8:  MOVWF  x99
015AA:  MOVFF  77C,79A
015AE:  MOVWF  x9B
015B0:  MOVFF  781,79C
015B4:  MOVLB  0
015B6:  RCALL  0EEE
015B8:  MOVLB  7
....................          } 
015BA:  INCF   x89,F
015BC:  BRA    1516
....................          if(P < 0) 
015BE:  BTFSC  x8B.7
015C0:  BRA    15C4
015C2:  BRA    15E8
....................          { 
....................             P  += 2*dy; 
015C4:  CLRF   x9E
015C6:  MOVLW  02
015C8:  MOVWF  x9D
015CA:  MOVFF  784,7A0
015CE:  MOVFF  783,79F
015D2:  MOVLB  0
015D4:  RCALL  1334
015D6:  MOVF   01,W
015D8:  MOVLB  7
015DA:  ADDWF  x8A,F
015DC:  MOVF   02,W
015DE:  ADDWFC x8B,F
....................             x1 += addx; 
015E0:  MOVF   x87,W
015E2:  ADDWF  x7C,W
015E4:  MOVWF  x7C
....................          } 
....................          else 
015E6:  BRA    15FC
....................          { 
....................             P  += diff; 
015E8:  MOVF   x8C,W
015EA:  ADDWF  x8A,F
015EC:  MOVF   x8D,W
015EE:  ADDWFC x8B,F
....................             x1 += addx; 
015F0:  MOVF   x87,W
015F2:  ADDWF  x7C,W
015F4:  MOVWF  x7C
....................             y1 += addy; 
015F6:  MOVF   x88,W
015F8:  ADDWF  x7D,W
015FA:  MOVWF  x7D
....................          } 
....................       } 
015FC:  INCF   x92,F
015FE:  BRA    14FE
....................    } 
....................    else 
01600:  BRA    1734
....................    { 
....................       P = 2*dx - dy; 
01602:  CLRF   x9E
01604:  MOVLW  02
01606:  MOVWF  x9D
01608:  MOVFF  786,7A0
0160C:  MOVFF  785,79F
01610:  MOVLB  0
01612:  RCALL  1334
01614:  MOVLB  7
01616:  MOVF   x83,W
01618:  SUBWF  01,W
0161A:  MOVWF  x8A
0161C:  MOVF   x84,W
0161E:  SUBWFB 02,W
01620:  MOVWF  x8B
....................       diff = P - dy; 
01622:  MOVF   x83,W
01624:  SUBWF  x8A,W
01626:  MOVWF  x8C
01628:  MOVF   x84,W
0162A:  SUBWFB x8B,W
0162C:  MOVWF  x8D
....................  
....................       for(i=0; i<=dy; ++i) 
0162E:  CLRF   x92
01630:  BTFSC  x84.7
01632:  BRA    1734
01634:  MOVF   x84,F
01636:  BNZ   1640
01638:  MOVF   x92,W
0163A:  SUBWF  x83,W
0163C:  BTFSS  FD8.0
0163E:  BRA    1734
....................       { 
....................          if(P < 0) 
01640:  BTFSC  x8B.7
01642:  BRA    1646
01644:  BRA    166A
....................          { 
....................             P  += 2*dx; 
01646:  CLRF   x9E
01648:  MOVLW  02
0164A:  MOVWF  x9D
0164C:  MOVFF  786,7A0
01650:  MOVFF  785,79F
01654:  MOVLB  0
01656:  RCALL  1334
01658:  MOVF   01,W
0165A:  MOVLB  7
0165C:  ADDWF  x8A,F
0165E:  MOVF   02,W
01660:  ADDWFC x8B,F
....................             y1 += addy; 
01662:  MOVF   x88,W
01664:  ADDWF  x7D,W
01666:  MOVWF  x7D
....................          } 
....................          else 
01668:  BRA    167E
....................          { 
....................             P  += diff; 
0166A:  MOVF   x8C,W
0166C:  ADDWF  x8A,F
0166E:  MOVF   x8D,W
01670:  ADDWFC x8B,F
....................             x1 += addx; 
01672:  MOVF   x87,W
01674:  ADDWF  x7C,W
01676:  MOVWF  x7C
....................             y1 += addy; 
01678:  MOVF   x88,W
0167A:  ADDWF  x7D,W
0167C:  MOVWF  x7D
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
0167E:  MOVLW  00
01680:  BSF    FD8.0
01682:  SUBFWB x82,W
01684:  MOVWF  x89
01686:  MOVF   x80,W
01688:  ANDLW  01
0168A:  ADDWF  x82,W
0168C:  BTFSC  x89.7
0168E:  BRA    1694
01690:  SUBWF  x89,W
01692:  BC    1730
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
01694:  MOVFF  786,79E
01698:  MOVFF  785,79D
0169C:  CLRF   xA0
0169E:  MOVFF  77C,79F
016A2:  MOVLB  0
016A4:  RCALL  1334
016A6:  MOVFF  02,79A
016AA:  MOVFF  01,799
016AE:  MOVLB  7
016B0:  MOVF   x89,W
016B2:  ADDWF  x7D,W
016B4:  CLRF   03
016B6:  MOVWF  00
016B8:  BTFSC  FE8.7
016BA:  DECF   03,F
016BC:  MOVWF  x9B
016BE:  MOVFF  03,79C
016C2:  MOVFF  784,79E
016C6:  MOVFF  783,79D
016CA:  MOVFF  03,7A0
016CE:  MOVWF  x9F
016D0:  MOVLB  0
016D2:  RCALL  1334
016D4:  MOVFF  02,03
016D8:  MOVF   01,W
016DA:  MOVLB  7
016DC:  ADDWF  x99,W
016DE:  MOVWF  01
016E0:  MOVF   x9A,W
016E2:  ADDWFC 03,F
016E4:  MOVFF  01,798
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
016E8:  MOVF   x98,W
016EA:  ADDWF  x8E,W
016EC:  MOVWF  x99
016EE:  MOVLW  00
016F0:  ADDWFC x8F,W
016F2:  MOVWF  x9A
016F4:  BTFSC  FE8.7
016F6:  BRA    172C
016F8:  BRA    16FA
016FA:  MOVF   x98,W
016FC:  ADDWF  x90,W
016FE:  MOVWF  x99
01700:  MOVLW  00
01702:  ADDWFC x91,W
01704:  MOVWF  x9A
01706:  BTFSC  FE8.7
01708:  BRA    1714
0170A:  MOVF   x9A,F
0170C:  BNZ   172C
0170E:  MOVF   x99,W
01710:  SUBLW  00
01712:  BNC   172C
....................                glcd_pixel(x1+j, y1, color); 
01714:  MOVF   x89,W
01716:  ADDWF  x7C,W
01718:  MOVWF  x99
0171A:  MOVWF  x9A
0171C:  MOVFF  77D,79B
01720:  MOVFF  781,79C
01724:  MOVLB  0
01726:  CALL   0EEE
0172A:  MOVLB  7
....................          } 
0172C:  INCF   x89,F
0172E:  BRA    1686
....................       } 
01730:  INCF   x92,F
01732:  BRA    1630
....................    } 
.................... } 
01734:  MOVLB  0
01736:  RETLW  00
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(int16 x, int16 y, int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(int8 x, int8 y, int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(int16 x, int16 y, char* textptr, int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(int8 x, int8 y, char* textptr, int8 size, int1 color) 
.................... #endif 
.................... { 
....................    int8 j, k, l, m;                       // Loop counters 
....................    int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
01738:  MOVFF  77F,03
0173C:  MOVLB  7
0173E:  MOVFF  77E,FE9
01742:  MOVFF  77F,FEA
01746:  MOVF   FEF,F
01748:  BTFSC  FD8.2
0174A:  BRA    18DE
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
0174C:  MOVFF  77F,03
01750:  MOVFF  77E,FE9
01754:  MOVFF  77F,FEA
01758:  MOVF   FEF,W
0175A:  SUBLW  52
0175C:  BNC   17A2
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
0175E:  MOVFF  77F,03
01762:  MOVFF  77E,FE9
01766:  MOVFF  77F,FEA
0176A:  MOVLW  20
0176C:  SUBWF  FEF,W
0176E:  MULLW  05
01770:  MOVF   FF3,W
01772:  CLRF   03
01774:  MOVWF  x8B
01776:  MOVLW  07
01778:  MOVWF  FEA
0177A:  MOVLW  86
0177C:  MOVWF  FE9
0177E:  CLRF   x8F
01780:  MOVFF  78B,78E
01784:  MOVLW  05
01786:  MOVWF  01
01788:  CLRF   FF7
0178A:  MOVF   x8B,W
0178C:  MOVLB  0
0178E:  CALL   05BA
01792:  TBLRD*-
01794:  TBLRD*+
01796:  MOVFF  FF5,FEE
0179A:  DECFSZ 01,F
0179C:  BRA    1794
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
0179E:  BRA    1804
017A0:  MOVLB  7
017A2:  MOVFF  77F,03
017A6:  MOVFF  77E,FE9
017AA:  MOVFF  77F,FEA
017AE:  MOVF   FEF,W
017B0:  SUBLW  7E
017B2:  BNC   17F8
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
017B4:  MOVFF  77F,03
017B8:  MOVFF  77E,FE9
017BC:  MOVFF  77F,FEA
017C0:  MOVLW  53
017C2:  SUBWF  FEF,W
017C4:  MULLW  05
017C6:  MOVF   FF3,W
017C8:  CLRF   03
017CA:  MOVWF  x8B
017CC:  MOVLW  07
017CE:  MOVWF  FEA
017D0:  MOVLW  86
017D2:  MOVWF  FE9
017D4:  CLRF   x8F
017D6:  MOVFF  78B,78E
017DA:  MOVLW  05
017DC:  MOVWF  01
017DE:  CLRF   FF7
017E0:  MOVF   x8B,W
017E2:  MOVLB  0
017E4:  CALL   06CA
017E8:  TBLRD*-
017EA:  TBLRD*+
017EC:  MOVFF  FF5,FEE
017F0:  DECFSZ 01,F
017F2:  BRA    17EA
....................       else 
017F4:  BRA    1804
017F6:  MOVLB  7
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
017F8:  CLRF   x86
017FA:  CLRF   x87
017FC:  CLRF   x88
017FE:  CLRF   x89
01800:  CLRF   x8A
01802:  MOVLB  0
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
....................       { 
01804:  MOVFF  77F,03
01808:  MOVLB  7
0180A:  MOVF   x7E,W
0180C:  MOVWF  FE9
0180E:  MOVFF  03,FEA
01812:  MOVF   FEF,W
01814:  XORLW  0A
01816:  MOVLB  0
01818:  BZ    1820
0181A:  XORLW  07
0181C:  BZ    1830
0181E:  BRA    1836
....................          case '\n': 
....................             y += 7*size + 1; 
01820:  MOVLB  7
01822:  MOVF   x80,W
01824:  MULLW  07
01826:  MOVF   FF3,W
01828:  ADDLW  01
0182A:  ADDWF  x7D,F
....................             continue; 
0182C:  BRA    18D0
0182E:  MOVLB  0
....................          case '\r': 
....................             x = 0; 
01830:  MOVLB  7
01832:  CLRF   x7C
....................             continue; 
01834:  BRA    18D0
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
01836:  MOVLB  7
01838:  MOVF   x80,W
0183A:  MULLW  05
0183C:  MOVF   FF3,W
0183E:  ADDWF  x7C,W
01840:  SUBLW  7F
01842:  BC    1850
....................       { 
....................          x = 0;                           // Set x at far left position 
01844:  CLRF   x7C
....................          y += 7*size + 1;                 // Set y at next position down 
01846:  MOVF   x80,W
01848:  MULLW  07
0184A:  MOVF   FF3,W
0184C:  ADDLW  01
0184E:  ADDWF  x7D,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
01850:  CLRF   x82
01852:  MOVF   x82,W
01854:  SUBLW  04
01856:  BNC   18D0
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
01858:  CLRF   x83
0185A:  MOVF   x83,W
0185C:  SUBLW  06
0185E:  BNC   18C8
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
01860:  CLRF   03
01862:  MOVF   x82,W
01864:  ADDLW  86
01866:  MOVWF  FE9
01868:  MOVLW  07
0186A:  ADDWFC 03,W
0186C:  MOVWF  FEA
0186E:  MOVFF  FEF,78B
01872:  MOVFF  78B,00
01876:  MOVF   x83,W
01878:  MOVWF  01
0187A:  BZ    1884
0187C:  BCF    FD8.0
0187E:  RRCF   00,F
01880:  DECFSZ 01,F
01882:  BRA    187C
01884:  BTFSS  00.0
01886:  BRA    18C4
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
01888:  CLRF   x84
0188A:  MOVF   x80,W
0188C:  SUBWF  x84,W
0188E:  BC    18C4
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
01890:  CLRF   x85
01892:  MOVF   x80,W
01894:  SUBWF  x85,W
01896:  BC    18C0
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
01898:  MOVF   x85,W
0189A:  ADDWF  x7C,W
0189C:  MOVWF  x8B
0189E:  MOVF   x83,W
018A0:  MULWF  x80
018A2:  MOVF   FF3,W
018A4:  ADDWF  x7D,W
018A6:  ADDWF  x84,W
018A8:  MOVWF  x8C
018AA:  MOVFF  78B,79A
018AE:  MOVWF  x9B
018B0:  MOVFF  781,79C
018B4:  MOVLB  0
018B6:  CALL   0EEE
....................                   } 
018BA:  MOVLB  7
018BC:  INCF   x85,F
018BE:  BRA    1892
....................                } 
018C0:  INCF   x84,F
018C2:  BRA    188A
....................             } 
....................          } 
018C4:  INCF   x83,F
018C6:  BRA    185A
....................       } 
018C8:  INCF   x82,F
018CA:  MOVF   x80,W
018CC:  ADDWF  x7C,F
018CE:  BRA    1852
....................    } 
018D0:  INCF   x7E,F
018D2:  BTFSC  FD8.2
018D4:  INCF   x7F,F
018D6:  INCF   x7C,F
018D8:  MOVLB  0
018DA:  BRA    1738
018DC:  MOVLB  7
.................... } 
018DE:  MOVLB  0
018E0:  RETLW  00
....................  
.................... #endif 
....................  
....................  
....................  
.................... //****************************************************************************// 
.................... // Purpose:       Draw less or equal 128x64 pixels of image to the graphic LCD// 
.................... //                screen on specified x, y coordinate                         //  
.................... // Inputs:        (x, y) - The start coordinate                               // 
.................... //                YES - Inverse of image (Raw data saved in ROM)              // 
.................... //                NO - Normal image (Raw data saved in ROM)                   // 
.................... // Dependencies:  glcd_pixel(), glcd_init()                                   // 
.................... //                                                                            // 
.................... //                       !!! PRLEASE BE CAREFULL !!                           // 
.................... //                                                                            // 
.................... //         First 2 bytes of your image data must be size of your BMP          // 
.................... //                                                                            // 
.................... // Example:       If your BMP image size is 64x32, first 2 bytes should       // 
.................... //                be 0x40, 0x20 --> (64 = 0x40, 32 = 0x20)                    // 
.................... //                                                                            // 
.................... //                      !! Check the "Bitmap.h" file !!                       // 
.................... //                                                                            // 
.................... //****************************************************************************// 
.................... /* 
.................... void glcd_image_xy(int x, int y, int1 inverse) 
.................... { 
....................    unsigned int i, j, k; 
....................    unsigned int16 count=2; 
....................    int width  = image_xy[0]; 
....................    int height = image_xy[1]; 
....................    //glcd_fillScreen(OFF);                        //Clears the screen (opt.) 
....................    if(inverse) 
....................    { 
....................       for(i=0;i<height;i+=8) 
....................       {    
....................          for(j=0;j<width;j++) 
....................          { 
....................             for(k=0;k<8;k++) 
....................             {  
....................                if(~bit_test(image_xy[count],k)) 
....................                { 
....................                   glcd_pixel(x+j,y+i+k,ON); 
....................                } 
....................             } 
....................             count++; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       for(i=0;i<height;i+=8) 
....................       {    
....................          for(j=0;j<width;j++) 
....................          { 
....................             for(k=0;k<8;k++) 
....................             {  
....................                if(bit_test(image_xy[count],k)) 
....................                { 
....................                   glcd_pixel(x+j,y+i+k,ON); 
....................                } 
....................             } 
....................             count++; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... */ 
.................... //****************************************************************************// 
.................... // Purpose:       Fill the graphic LCD screen with 128x64 bit converted image // 
.................... // Inputs:        YES - Inverse of image (Raw data saved in ROM)              // 
.................... //                NO - Normal image (Raw data saved in ROM)                   // 
.................... // Dependencies:  glcd_pixel(), glcd_init()                                   // 
.................... //                                                                            // 
.................... //                      !! Check the "Bitmap.h" file !!                       // 
.................... //                                                                            // 
.................... //****************************************************************************// 
.................... /* 
.................... void glcd_image(int1 inverse) 
.................... { 
....................    unsigned int i, j, k;  
....................    unsigned int16 count=0; 
....................    int width = 128;   
....................    int height = 64; 
....................    glcd_fillScreen(OFF);                        //Clears the screen (opt.) 
....................    if(inverse) 
....................    { 
....................       for(i=0;i<height;i+=8) 
....................       { 
....................          for(j=0;j<width;j++) 
....................          { 
....................             for(k=0;k<8;k++) 
....................             {  
....................                if(~bit_test(image[count],k)) 
....................                { 
....................                   glcd_pixel(j,i+k,ON); 
....................                }          
....................                 
....................             } 
....................             count++; 
....................          }   
....................       } 
....................    } 
....................    else 
....................    { 
....................       for(i=0;i<height;i+=8) 
....................       { 
....................          for(j=0;j<width;j++) 
....................          { 
....................             for(k=0;k<8;k++) 
....................             {  
....................                if(bit_test(image[count],k)) 
....................                { 
....................                   glcd_pixel(j,i+k,ON); 
....................                }          
....................                 
....................             } 
....................             count++; 
....................          }   
....................       } 
....................    } 
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... #include <internal_eeprom.c> 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////                          internal_eeprom.c                             //// 
.................... ////                                                                        //// 
.................... ////       Utilities to write various data types to internal eeprom         //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                        //// 
.................... ////   void write_int1_eeprom(address, int8 bitPosition, int1 data)         //// 
.................... ////     Call to write one bit of data                                      //// 
.................... ////                                                                        //// 
.................... ////   int1 read_int1_eeprom(address, int8 bitPosition)                     //// 
.................... ////     Call to read one bit of data                                       //// 
.................... ////                                                                        //// 
.................... ////                                                                        //// 
.................... ////   void write_int16_eeprom(address, int16 data)                         //// 
.................... ////     Call to write a 16 bit integer                                     //// 
.................... ////                                                                        //// 
.................... ////   void write_int16_eeprom(address, int16 data)                         //// 
.................... ////     Call to read a 16 bit integer                                      //// 
.................... ////                                                                        //// 
.................... ////                                                                        //// 
.................... ////   void write_int32_eeprom(address, int32 data)                         //// 
.................... ////     Call to write a 32 bit integer                                     //// 
.................... ////                                                                        //// 
.................... ////   int16 read_int32_eeprom(address)                                     //// 
.................... ////     Call to read a 32 bit integer                                      //// 
.................... ////                                                                        //// 
.................... ////                                                                        //// 
.................... ////   void write_float_eeprom(address, float data)                         //// 
.................... ////     Call to write a floating point number                              //// 
.................... ////                                                                        //// 
.................... ////   float read_float_eeprom(address)                                     //// 
.................... ////     Call to read a floating point number                               //// 
.................... ////                                                                        //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services               //// 
.................... //// This source code may only be used by licensed users of the CCS C       //// 
.................... //// compiler.  This source code may only be distributed to other licensed  //// 
.................... //// users of the CCS C compiler.  No other use, reproduction or            //// 
.................... //// distribution is permitted without written permission. Derivative       //// 
.................... //// programs created using this software in object code form are not       //// 
.................... //// restricted in any way.                                                 //// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef INTERNAL_EEPROM_UTILITIES 
.................... #define INTERNAL_EEPROM_UTILITIES 
....................  
.................... // Used to adjust the address range 
.................... #ifndef INT_EEPROM_ADDRESS 
.................... #define INT_EEPROM_ADDRESS  int8 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //// Internal EEPROM Functions 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Write one bit to internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The bit position (LSB == 0) 
.................... //             3) The bit to write 
.................... // Outputs:    None 
.................... void write_int1_eeprom(INT_EEPROM_ADDRESS address, int8 bitPosition, int1 data) 
.................... { 
....................    int8 stored_data; 
....................  
....................    stored_data = read_eeprom(address); 
....................  
....................    if(data) 
....................    { 
....................       bit_set(stored_data, bitPosition); 
....................    } 
....................    else 
....................    { 
....................       bit_clear(stored_data, bitPosition); 
....................    } 
....................  
....................    write_eeprom(address, stored_data); 
.................... } 
....................  
....................  
.................... // Purpose:    Read one bit from internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The bit position (LSB == 0) 
.................... // Outputs:    The bit read from internal eeprom 
.................... int1 read_int1_eeprom(INT_EEPROM_ADDRESS address, int8 bitPosition) 
.................... { 
....................    return bit_test(read_eeprom(address), bitPosition); 
.................... } 
....................  
....................  
.................... // Purpose:    Write a 16 bit number to internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The 16 bit number to write to internal eeprom 
.................... // Outputs:    None 
.................... void write_int16_eeprom(INT_EEPROM_ADDRESS address, int16 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 2; ++i) 
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:    Read a 16 bit number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 16 bit number read from internal eeprom 
.................... int16 read_int16_eeprom(INT_EEPROM_ADDRESS address) 
.................... { 
....................    int8  i; 
....................    int16 data; 
....................  
....................    for(i = 0; i < 2; ++i) 
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
....................    } 
....................  
....................    return(data); 
.................... } 
....................  
....................  
.................... // Purpose:    Write a 32 bit integer to internal eeprom 
.................... // Inputs:     1) An eeprom address 
.................... //             2) The 32 bit number to write to internal eeprom 
.................... // Outputs:    None 
.................... void write_int32_eeprom(INT_EEPROM_ADDRESS address, int32 data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:    Read a 32 bit integer from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The 32 bit integer read from internal eeprom 
.................... int32 read_int32_eeprom(INT_EEPROM_ADDRESS address) 
.................... { 
....................    int8  i; 
....................    int32 data; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
....................    } 
....................  
....................    return data; 
.................... } 
....................  
....................  
.................... // Purpose:    Write a floating point number to internal eeprom 
.................... // Inputs:     1) An eeprom address. Four eeprom locations will be used. 
.................... //             2) The floating point number to write to internal eeprom 
.................... // Outputs:    None 
.................... void write_float_eeprom(INT_EEPROM_ADDRESS address, float data) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      write_eeprom(address + i, *((int8 *)(&data) + i)); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:    Read a floating point number from internal eeprom 
.................... // Inputs:     An eeprom address 
.................... // Outputs:    The floating point number read from the internal eeprom 
.................... float read_float_eeprom(INT_EEPROM_ADDRESS address) 
.................... { 
....................    int8 i; 
....................    float data; 
....................  
....................    for(i = 0; i < 4; ++i) 
....................    { 
....................      *((int8 *)(&data) + i) = read_eeprom(address + i); 
....................    } 
....................  
....................    return data; 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
03EAA:  MOVFF  73E,742
03EAE:  MOVFF  73D,741
03EB2:  MOVFF  742,03
03EB6:  MOVLB  7
03EB8:  MOVFF  741,FE9
03EBC:  MOVFF  742,FEA
03EC0:  MOVF   FEF,F
03EC2:  BZ    3ED0
03EC4:  INCF   x41,F
03EC6:  BTFSC  FD8.2
03EC8:  INCF   x42,F
03ECA:  MOVLB  0
03ECC:  BRA    3EB2
03ECE:  MOVLB  7
....................    while(*s2 != '\0') 
....................    { 
03ED0:  MOVFF  740,03
03ED4:  MOVFF  73F,FE9
03ED8:  MOVFF  740,FEA
03EDC:  MOVF   FEF,F
03EDE:  BZ    3F06
....................       *s = *s2; 
03EE0:  MOVFF  73F,FE9
03EE4:  MOVFF  740,FEA
03EE8:  MOVFF  FEF,745
03EEC:  MOVFF  742,FEA
03EF0:  MOVFF  741,FE9
03EF4:  MOVFF  745,FEF
....................       ++s; 
03EF8:  INCF   x41,F
03EFA:  BTFSC  FD8.2
03EFC:  INCF   x42,F
....................       ++s2; 
03EFE:  INCF   x3F,F
03F00:  BTFSC  FD8.2
03F02:  INCF   x40,F
....................    } 
03F04:  BRA    3ED0
....................  
....................    *s = '\0'; 
03F06:  MOVFF  741,FE9
03F0A:  MOVFF  742,FEA
03F0E:  CLRF   FEF
....................    return(s1); 
03F10:  MOVFF  73D,01
03F14:  MOVFF  73E,02
.................... } 
03F18:  MOVLB  0
03F1A:  RETLW  00
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
024E0:  MOVLB  7
024E2:  CLRF   x4D
....................    sign = 0; 
024E4:  CLRF   x4B
....................    base = 10; 
024E6:  MOVLW  0A
024E8:  MOVWF  x4C
....................    result = 0; 
024EA:  CLRF   x4A
....................  
....................    if (!s) 
024EC:  MOVF   x48,W
024EE:  IORWF  x49,W
024F0:  BNZ   24F8
....................       return 0; 
024F2:  MOVLW  00
024F4:  MOVWF  01
024F6:  BRA    267E
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
024F8:  MOVF   x4D,W
024FA:  INCF   x4D,F
024FC:  CLRF   03
024FE:  ADDWF  x48,W
02500:  MOVWF  FE9
02502:  MOVF   x49,W
02504:  ADDWFC 03,W
02506:  MOVWF  FEA
02508:  MOVFF  FEF,74E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0250C:  MOVF   x4E,W
0250E:  SUBLW  2D
02510:  BNZ   252C
....................    { 
....................       sign = 1;         // Set the sign to negative 
02512:  MOVLW  01
02514:  MOVWF  x4B
....................       c = s[index++]; 
02516:  MOVF   x4D,W
02518:  INCF   x4D,F
0251A:  CLRF   03
0251C:  ADDWF  x48,W
0251E:  MOVWF  FE9
02520:  MOVF   x49,W
02522:  ADDWFC 03,W
02524:  MOVWF  FEA
02526:  MOVFF  FEF,74E
....................    } 
....................    else if (c == '+') 
0252A:  BRA    2546
0252C:  MOVF   x4E,W
0252E:  SUBLW  2B
02530:  BNZ   2546
....................    { 
....................       c = s[index++]; 
02532:  MOVF   x4D,W
02534:  INCF   x4D,F
02536:  CLRF   03
02538:  ADDWF  x48,W
0253A:  MOVWF  FE9
0253C:  MOVF   x49,W
0253E:  ADDWFC 03,W
02540:  MOVWF  FEA
02542:  MOVFF  FEF,74E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
02546:  MOVF   x4E,W
02548:  SUBLW  2F
0254A:  BTFSC  FD8.0
0254C:  BRA    266E
0254E:  MOVF   x4E,W
02550:  SUBLW  39
02552:  BTFSS  FD8.0
02554:  BRA    266E
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
02556:  MOVF   x4E,W
02558:  SUBLW  30
0255A:  BNZ   259E
0255C:  CLRF   03
0255E:  MOVF   x4D,W
02560:  ADDWF  x48,W
02562:  MOVWF  FE9
02564:  MOVF   x49,W
02566:  ADDWFC 03,W
02568:  MOVWF  FEA
0256A:  MOVF   FEF,W
0256C:  SUBLW  78
0256E:  BZ    2584
02570:  CLRF   03
02572:  MOVF   x4D,W
02574:  ADDWF  x48,W
02576:  MOVWF  FE9
02578:  MOVF   x49,W
0257A:  ADDWFC 03,W
0257C:  MOVWF  FEA
0257E:  MOVF   FEF,W
02580:  SUBLW  58
02582:  BNZ   259E
....................       { 
....................          base = 16; 
02584:  MOVLW  10
02586:  MOVWF  x4C
....................          index++; 
02588:  INCF   x4D,F
....................          c = s[index++]; 
0258A:  MOVF   x4D,W
0258C:  INCF   x4D,F
0258E:  CLRF   03
02590:  ADDWF  x48,W
02592:  MOVWF  FE9
02594:  MOVF   x49,W
02596:  ADDWFC 03,W
02598:  MOVWF  FEA
0259A:  MOVFF  FEF,74E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0259E:  MOVF   x4C,W
025A0:  SUBLW  0A
025A2:  BNZ   25DE
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
025A4:  MOVF   x4E,W
025A6:  SUBLW  2F
025A8:  BC    25DC
025AA:  MOVF   x4E,W
025AC:  SUBLW  39
025AE:  BNC   25DC
....................             result = 10*result + (c - '0'); 
025B0:  MOVLW  0A
025B2:  MOVWF  x4F
025B4:  MOVFF  74A,750
025B8:  MOVLB  0
025BA:  BRA    2490
025BC:  MOVLW  30
025BE:  MOVLB  7
025C0:  SUBWF  x4E,W
025C2:  ADDWF  01,W
025C4:  MOVWF  x4A
....................             c = s[index++]; 
025C6:  MOVF   x4D,W
025C8:  INCF   x4D,F
025CA:  CLRF   03
025CC:  ADDWF  x48,W
025CE:  MOVWF  FE9
025D0:  MOVF   x49,W
025D2:  ADDWFC 03,W
025D4:  MOVWF  FEA
025D6:  MOVFF  FEF,74E
....................          } 
025DA:  BRA    25A4
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
025DC:  BRA    266E
025DE:  MOVF   x4C,W
025E0:  SUBLW  10
025E2:  BNZ   266E
....................       { 
....................          c = toupper(c); 
025E4:  MOVF   x4E,W
025E6:  SUBLW  60
025E8:  BC    25F6
025EA:  MOVF   x4E,W
025EC:  SUBLW  7A
025EE:  BNC   25F6
025F0:  MOVF   x4E,W
025F2:  ANDLW  DF
025F4:  BRA    25F8
025F6:  MOVF   x4E,W
025F8:  MOVWF  x4E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
025FA:  MOVF   x4E,W
025FC:  SUBLW  2F
025FE:  BC    2606
02600:  MOVF   x4E,W
02602:  SUBLW  39
02604:  BC    2612
02606:  MOVF   x4E,W
02608:  SUBLW  40
0260A:  BC    266E
0260C:  MOVF   x4E,W
0260E:  SUBLW  46
02610:  BNC   266E
....................             if (c >= '0' && c <= '9') 
02612:  MOVF   x4E,W
02614:  SUBLW  2F
02616:  BC    2630
02618:  MOVF   x4E,W
0261A:  SUBLW  39
0261C:  BNC   2630
....................                result = (result << 4) + (c - '0'); 
0261E:  SWAPF  x4A,W
02620:  MOVWF  x4F
02622:  MOVLW  F0
02624:  ANDWF  x4F,F
02626:  MOVLW  30
02628:  SUBWF  x4E,W
0262A:  ADDWF  x4F,W
0262C:  MOVWF  x4A
....................             else 
0262E:  BRA    2642
....................                result = (result << 4) + (c - 'A' + 10); 
02630:  SWAPF  x4A,W
02632:  MOVWF  x4F
02634:  MOVLW  F0
02636:  ANDWF  x4F,F
02638:  MOVLW  41
0263A:  SUBWF  x4E,W
0263C:  ADDLW  0A
0263E:  ADDWF  x4F,W
02640:  MOVWF  x4A
....................  
....................             c = s[index++]; 
02642:  MOVF   x4D,W
02644:  INCF   x4D,F
02646:  CLRF   03
02648:  ADDWF  x48,W
0264A:  MOVWF  FE9
0264C:  MOVF   x49,W
0264E:  ADDWFC 03,W
02650:  MOVWF  FEA
02652:  MOVFF  FEF,74E
....................             c = toupper(c); 
02656:  MOVF   x4E,W
02658:  SUBLW  60
0265A:  BC    2668
0265C:  MOVF   x4E,W
0265E:  SUBLW  7A
02660:  BNC   2668
02662:  MOVF   x4E,W
02664:  ANDLW  DF
02666:  BRA    266A
02668:  MOVF   x4E,W
0266A:  MOVWF  x4E
....................          } 
0266C:  BRA    25FA
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0266E:  DECFSZ x4B,W
02670:  BRA    267A
02672:  MOVF   x4C,W
02674:  SUBLW  0A
02676:  BNZ   267A
....................        result = -result; 
02678:  NEGF   x4A
....................  
....................    return(result); 
0267A:  MOVFF  74A,01
.................... } 
0267E:  MOVLB  0
02680:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
03B1E:  MOVLB  7
03B20:  CLRF   x43
....................    sign = 0; 
03B22:  CLRF   x41
....................    base = 10; 
03B24:  MOVLW  0A
03B26:  MOVWF  x42
....................    result = 0; 
03B28:  CLRF   x40
03B2A:  CLRF   x3F
....................  
....................    if (!s) 
03B2C:  MOVF   x3D,W
03B2E:  IORWF  x3E,W
03B30:  BNZ   3B3A
....................       return 0; 
03B32:  MOVLW  00
03B34:  MOVWF  01
03B36:  MOVWF  02
03B38:  BRA    3D0C
....................    c = s[index++]; 
03B3A:  MOVF   x43,W
03B3C:  INCF   x43,F
03B3E:  CLRF   03
03B40:  ADDWF  x3D,W
03B42:  MOVWF  FE9
03B44:  MOVF   x3E,W
03B46:  ADDWFC 03,W
03B48:  MOVWF  FEA
03B4A:  MOVFF  FEF,744
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
03B4E:  MOVF   x44,W
03B50:  SUBLW  2D
03B52:  BNZ   3B6E
....................    { 
....................       sign = 1;         // Set the sign to negative 
03B54:  MOVLW  01
03B56:  MOVWF  x41
....................       c = s[index++]; 
03B58:  MOVF   x43,W
03B5A:  INCF   x43,F
03B5C:  CLRF   03
03B5E:  ADDWF  x3D,W
03B60:  MOVWF  FE9
03B62:  MOVF   x3E,W
03B64:  ADDWFC 03,W
03B66:  MOVWF  FEA
03B68:  MOVFF  FEF,744
....................    } 
....................    else if (c == '+') 
03B6C:  BRA    3B88
03B6E:  MOVF   x44,W
03B70:  SUBLW  2B
03B72:  BNZ   3B88
....................    { 
....................       c = s[index++]; 
03B74:  MOVF   x43,W
03B76:  INCF   x43,F
03B78:  CLRF   03
03B7A:  ADDWF  x3D,W
03B7C:  MOVWF  FE9
03B7E:  MOVF   x3E,W
03B80:  ADDWFC 03,W
03B82:  MOVWF  FEA
03B84:  MOVFF  FEF,744
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
03B88:  MOVF   x44,W
03B8A:  SUBLW  2F
03B8C:  BTFSC  FD8.0
03B8E:  BRA    3CF0
03B90:  MOVF   x44,W
03B92:  SUBLW  39
03B94:  BTFSS  FD8.0
03B96:  BRA    3CF0
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
03B98:  MOVF   x44,W
03B9A:  SUBLW  30
03B9C:  BNZ   3BE0
03B9E:  CLRF   03
03BA0:  MOVF   x43,W
03BA2:  ADDWF  x3D,W
03BA4:  MOVWF  FE9
03BA6:  MOVF   x3E,W
03BA8:  ADDWFC 03,W
03BAA:  MOVWF  FEA
03BAC:  MOVF   FEF,W
03BAE:  SUBLW  78
03BB0:  BZ    3BC6
03BB2:  CLRF   03
03BB4:  MOVF   x43,W
03BB6:  ADDWF  x3D,W
03BB8:  MOVWF  FE9
03BBA:  MOVF   x3E,W
03BBC:  ADDWFC 03,W
03BBE:  MOVWF  FEA
03BC0:  MOVF   FEF,W
03BC2:  SUBLW  58
03BC4:  BNZ   3BE0
....................       { 
....................          base = 16; 
03BC6:  MOVLW  10
03BC8:  MOVWF  x42
....................          index++; 
03BCA:  INCF   x43,F
....................          c = s[index++]; 
03BCC:  MOVF   x43,W
03BCE:  INCF   x43,F
03BD0:  CLRF   03
03BD2:  ADDWF  x3D,W
03BD4:  MOVWF  FE9
03BD6:  MOVF   x3E,W
03BD8:  ADDWFC 03,W
03BDA:  MOVWF  FEA
03BDC:  MOVFF  FEF,744
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
03BE0:  MOVF   x42,W
03BE2:  SUBLW  0A
03BE4:  BNZ   3C2E
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
03BE6:  MOVF   x44,W
03BE8:  SUBLW  2F
03BEA:  BC    3C2C
03BEC:  MOVF   x44,W
03BEE:  SUBLW  39
03BF0:  BNC   3C2C
....................             result = 10*result + (c - '0'); 
03BF2:  CLRF   x9E
03BF4:  MOVLW  0A
03BF6:  MOVWF  x9D
03BF8:  MOVFF  740,7A0
03BFC:  MOVFF  73F,79F
03C00:  MOVLB  0
03C02:  CALL   1334
03C06:  MOVLW  30
03C08:  MOVLB  7
03C0A:  SUBWF  x44,W
03C0C:  ADDWF  01,W
03C0E:  MOVWF  x3F
03C10:  MOVLW  00
03C12:  ADDWFC 02,W
03C14:  MOVWF  x40
....................             c = s[index++]; 
03C16:  MOVF   x43,W
03C18:  INCF   x43,F
03C1A:  CLRF   03
03C1C:  ADDWF  x3D,W
03C1E:  MOVWF  FE9
03C20:  MOVF   x3E,W
03C22:  ADDWFC 03,W
03C24:  MOVWF  FEA
03C26:  MOVFF  FEF,744
....................          } 
03C2A:  BRA    3BE6
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
03C2C:  BRA    3CF0
03C2E:  MOVF   x42,W
03C30:  SUBLW  10
03C32:  BNZ   3CF0
....................       { 
....................          c = toupper(c); 
03C34:  MOVF   x44,W
03C36:  SUBLW  60
03C38:  BC    3C46
03C3A:  MOVF   x44,W
03C3C:  SUBLW  7A
03C3E:  BNC   3C46
03C40:  MOVF   x44,W
03C42:  ANDLW  DF
03C44:  BRA    3C48
03C46:  MOVF   x44,W
03C48:  MOVWF  x44
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
03C4A:  MOVF   x44,W
03C4C:  SUBLW  2F
03C4E:  BC    3C56
03C50:  MOVF   x44,W
03C52:  SUBLW  39
03C54:  BC    3C62
03C56:  MOVF   x44,W
03C58:  SUBLW  40
03C5A:  BC    3CF0
03C5C:  MOVF   x44,W
03C5E:  SUBLW  46
03C60:  BNC   3CF0
....................             if (c >= '0' && c <= '9') 
03C62:  MOVF   x44,W
03C64:  SUBLW  2F
03C66:  BC    3C9A
03C68:  MOVF   x44,W
03C6A:  SUBLW  39
03C6C:  BNC   3C9A
....................                result = (result << 4) + (c - '0'); 
03C6E:  RLCF   x3F,W
03C70:  MOVWF  x45
03C72:  RLCF   x40,W
03C74:  MOVWF  x46
03C76:  RLCF   x45,F
03C78:  RLCF   x46,F
03C7A:  RLCF   x45,F
03C7C:  RLCF   x46,F
03C7E:  RLCF   x45,F
03C80:  RLCF   x46,F
03C82:  MOVLW  F0
03C84:  ANDWF  x45,F
03C86:  MOVLW  30
03C88:  SUBWF  x44,W
03C8A:  ADDWF  x45,W
03C8C:  MOVWF  01
03C8E:  MOVLW  00
03C90:  ADDWFC x46,W
03C92:  MOVFF  01,73F
03C96:  MOVWF  x40
....................             else 
03C98:  BRA    3CC6
....................                result = (result << 4) + (c - 'A' + 10); 
03C9A:  RLCF   x3F,W
03C9C:  MOVWF  x45
03C9E:  RLCF   x40,W
03CA0:  MOVWF  x46
03CA2:  RLCF   x45,F
03CA4:  RLCF   x46,F
03CA6:  RLCF   x45,F
03CA8:  RLCF   x46,F
03CAA:  RLCF   x45,F
03CAC:  RLCF   x46,F
03CAE:  MOVLW  F0
03CB0:  ANDWF  x45,F
03CB2:  MOVLW  41
03CB4:  SUBWF  x44,W
03CB6:  ADDLW  0A
03CB8:  ADDWF  x45,W
03CBA:  MOVWF  01
03CBC:  MOVLW  00
03CBE:  ADDWFC x46,W
03CC0:  MOVFF  01,73F
03CC4:  MOVWF  x40
....................  
....................             c = s[index++];c = toupper(c); 
03CC6:  MOVF   x43,W
03CC8:  INCF   x43,F
03CCA:  CLRF   03
03CCC:  ADDWF  x3D,W
03CCE:  MOVWF  FE9
03CD0:  MOVF   x3E,W
03CD2:  ADDWFC 03,W
03CD4:  MOVWF  FEA
03CD6:  MOVF   FEF,W
03CD8:  MOVWF  x44
03CDA:  SUBLW  60
03CDC:  BC    3CEA
03CDE:  MOVF   x44,W
03CE0:  SUBLW  7A
03CE2:  BNC   3CEA
03CE4:  MOVF   x44,W
03CE6:  ANDLW  DF
03CE8:  BRA    3CEC
03CEA:  MOVF   x44,W
03CEC:  MOVWF  x44
....................          } 
03CEE:  BRA    3C4A
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
03CF0:  MOVF   x42,W
03CF2:  SUBLW  0A
03CF4:  BNZ   3D04
03CF6:  DECFSZ x41,W
03CF8:  BRA    3D04
....................       result = -result; 
03CFA:  COMF   x3F,F
03CFC:  COMF   x40,F
03CFE:  INCF   x3F,F
03D00:  BTFSC  FD8.2
03D02:  INCF   x40,F
....................  
....................    return(result); 
03D04:  MOVFF  73F,01
03D08:  MOVFF  740,02
.................... } 
03D0C:  MOVLB  0
03D0E:  GOTO   4FFC (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
04012:  MOVLB  7
04014:  CLRF   x45
....................    sign = 0; 
04016:  CLRF   x43
....................    base = 10; 
04018:  MOVLW  0A
0401A:  MOVWF  x44
....................    result = 0; 
0401C:  CLRF   x42
0401E:  CLRF   x41
04020:  CLRF   x40
04022:  CLRF   x3F
....................  
....................    if (!s) 
04024:  MOVF   x3D,W
04026:  IORWF  x3E,W
04028:  BNZ   4034
....................       return 0; 
0402A:  CLRF   00
0402C:  CLRF   01
0402E:  CLRF   02
04030:  CLRF   03
04032:  BRA    42AE
....................    c = s[index++]; 
04034:  MOVF   x45,W
04036:  INCF   x45,F
04038:  CLRF   03
0403A:  ADDWF  x3D,W
0403C:  MOVWF  FE9
0403E:  MOVF   x3E,W
04040:  ADDWFC 03,W
04042:  MOVWF  FEA
04044:  MOVFF  FEF,746
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
04048:  MOVF   x46,W
0404A:  SUBLW  2D
0404C:  BNZ   4068
....................    { 
....................       sign = 1;         // Set the sign to negative 
0404E:  MOVLW  01
04050:  MOVWF  x43
....................       c = s[index++]; 
04052:  MOVF   x45,W
04054:  INCF   x45,F
04056:  CLRF   03
04058:  ADDWF  x3D,W
0405A:  MOVWF  FE9
0405C:  MOVF   x3E,W
0405E:  ADDWFC 03,W
04060:  MOVWF  FEA
04062:  MOVFF  FEF,746
....................    } 
....................    else if (c == '+') 
04066:  BRA    4082
04068:  MOVF   x46,W
0406A:  SUBLW  2B
0406C:  BNZ   4082
....................    { 
....................       c = s[index++]; 
0406E:  MOVF   x45,W
04070:  INCF   x45,F
04072:  CLRF   03
04074:  ADDWF  x3D,W
04076:  MOVWF  FE9
04078:  MOVF   x3E,W
0407A:  ADDWFC 03,W
0407C:  MOVWF  FEA
0407E:  MOVFF  FEF,746
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
04082:  MOVF   x46,W
04084:  SUBLW  2F
04086:  BTFSC  FD8.0
04088:  BRA    427E
0408A:  MOVF   x46,W
0408C:  SUBLW  39
0408E:  BTFSS  FD8.0
04090:  BRA    427E
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
04092:  MOVF   x46,W
04094:  SUBLW  30
04096:  BNZ   40DA
04098:  CLRF   03
0409A:  MOVF   x45,W
0409C:  ADDWF  x3D,W
0409E:  MOVWF  FE9
040A0:  MOVF   x3E,W
040A2:  ADDWFC 03,W
040A4:  MOVWF  FEA
040A6:  MOVF   FEF,W
040A8:  SUBLW  78
040AA:  BZ    40C0
040AC:  CLRF   03
040AE:  MOVF   x45,W
040B0:  ADDWF  x3D,W
040B2:  MOVWF  FE9
040B4:  MOVF   x3E,W
040B6:  ADDWFC 03,W
040B8:  MOVWF  FEA
040BA:  MOVF   FEF,W
040BC:  SUBLW  58
040BE:  BNZ   40DA
....................       { 
....................          base = 16; 
040C0:  MOVLW  10
040C2:  MOVWF  x44
....................          index++; 
040C4:  INCF   x45,F
....................          c = s[index++]; 
040C6:  MOVF   x45,W
040C8:  INCF   x45,F
040CA:  CLRF   03
040CC:  ADDWF  x3D,W
040CE:  MOVWF  FE9
040D0:  MOVF   x3E,W
040D2:  ADDWFC 03,W
040D4:  MOVWF  FEA
040D6:  MOVFF  FEF,746
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
040DA:  MOVF   x44,W
040DC:  SUBLW  0A
040DE:  BNZ   4168
....................       { 
....................          while (c >= '0' && c <= '9') { 
040E0:  MOVF   x46,W
040E2:  SUBLW  2F
040E4:  BC    4166
040E6:  MOVF   x46,W
040E8:  SUBLW  39
040EA:  BNC   4166
....................             result = (result << 1) + (result << 3);  // result *= 10; 
040EC:  BCF    FD8.0
040EE:  RLCF   x3F,W
040F0:  MOVWF  x48
040F2:  RLCF   x40,W
040F4:  MOVWF  x49
040F6:  RLCF   x41,W
040F8:  MOVWF  x4A
040FA:  RLCF   x42,W
040FC:  MOVWF  x4B
040FE:  RLCF   x3F,W
04100:  MOVWF  00
04102:  RLCF   x40,W
04104:  MOVWF  01
04106:  RLCF   x41,W
04108:  MOVWF  02
0410A:  RLCF   x42,W
0410C:  MOVWF  03
0410E:  RLCF   00,F
04110:  RLCF   01,F
04112:  RLCF   02,F
04114:  RLCF   03,F
04116:  RLCF   00,F
04118:  RLCF   01,F
0411A:  RLCF   02,F
0411C:  RLCF   03,F
0411E:  MOVLW  F8
04120:  ANDWF  00,F
04122:  MOVF   x48,W
04124:  ADDWF  00,F
04126:  MOVF   x49,W
04128:  ADDWFC 01,F
0412A:  MOVF   x4A,W
0412C:  ADDWFC 02,F
0412E:  MOVF   x4B,W
04130:  ADDWFC 03,F
04132:  MOVFF  03,742
04136:  MOVFF  02,741
0413A:  MOVFF  01,740
0413E:  MOVFF  00,73F
....................             result += (c - '0'); 
04142:  MOVLW  30
04144:  SUBWF  x46,W
04146:  ADDWF  x3F,F
04148:  MOVLW  00
0414A:  ADDWFC x40,F
0414C:  ADDWFC x41,F
0414E:  ADDWFC x42,F
....................             c = s[index++]; 
04150:  MOVF   x45,W
04152:  INCF   x45,F
04154:  CLRF   03
04156:  ADDWF  x3D,W
04158:  MOVWF  FE9
0415A:  MOVF   x3E,W
0415C:  ADDWFC 03,W
0415E:  MOVWF  FEA
04160:  MOVFF  FEF,746
....................          } 
04164:  BRA    40E0
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
04166:  BRA    427E
04168:  MOVF   x44,W
0416A:  SUBLW  10
0416C:  BTFSS  FD8.2
0416E:  BRA    427E
....................       { 
....................          c = toupper(c); 
04170:  MOVF   x46,W
04172:  SUBLW  60
04174:  BC    4182
04176:  MOVF   x46,W
04178:  SUBLW  7A
0417A:  BNC   4182
0417C:  MOVF   x46,W
0417E:  ANDLW  DF
04180:  BRA    4184
04182:  MOVF   x46,W
04184:  MOVWF  x46
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
04186:  MOVF   x46,W
04188:  SUBLW  2F
0418A:  BC    4192
0418C:  MOVF   x46,W
0418E:  SUBLW  39
04190:  BC    41A0
04192:  MOVF   x46,W
04194:  SUBLW  40
04196:  BTFSC  FD8.0
04198:  BRA    427E
0419A:  MOVF   x46,W
0419C:  SUBLW  46
0419E:  BNC   427E
....................             if (c >= '0' && c <= '9') 
041A0:  MOVF   x46,W
041A2:  SUBLW  2F
041A4:  BC    4200
041A6:  MOVF   x46,W
041A8:  SUBLW  39
041AA:  BNC   4200
....................                result = (result << 4) + (c - '0'); 
041AC:  RLCF   x3F,W
041AE:  MOVWF  x48
041B0:  RLCF   x40,W
041B2:  MOVWF  x49
041B4:  RLCF   x41,W
041B6:  MOVWF  x4A
041B8:  RLCF   x42,W
041BA:  MOVWF  x4B
041BC:  RLCF   x48,F
041BE:  RLCF   x49,F
041C0:  RLCF   x4A,F
041C2:  RLCF   x4B,F
041C4:  RLCF   x48,F
041C6:  RLCF   x49,F
041C8:  RLCF   x4A,F
041CA:  RLCF   x4B,F
041CC:  RLCF   x48,F
041CE:  RLCF   x49,F
041D0:  RLCF   x4A,F
041D2:  RLCF   x4B,F
041D4:  MOVLW  F0
041D6:  ANDWF  x48,F
041D8:  MOVLW  30
041DA:  SUBWF  x46,W
041DC:  ADDWF  x48,W
041DE:  MOVWF  00
041E0:  MOVLW  00
041E2:  ADDWFC x49,W
041E4:  MOVWF  01
041E6:  MOVLW  00
041E8:  ADDWFC x4A,W
041EA:  MOVWF  02
041EC:  MOVLW  00
041EE:  ADDWFC x4B,W
041F0:  MOVWF  x42
041F2:  MOVFF  02,741
041F6:  MOVFF  01,740
041FA:  MOVFF  00,73F
....................             else 
041FE:  BRA    4254
....................                result = (result << 4) + (c - 'A' + 10); 
04200:  RLCF   x3F,W
04202:  MOVWF  x48
04204:  RLCF   x40,W
04206:  MOVWF  x49
04208:  RLCF   x41,W
0420A:  MOVWF  x4A
0420C:  RLCF   x42,W
0420E:  MOVWF  x4B
04210:  RLCF   x48,F
04212:  RLCF   x49,F
04214:  RLCF   x4A,F
04216:  RLCF   x4B,F
04218:  RLCF   x48,F
0421A:  RLCF   x49,F
0421C:  RLCF   x4A,F
0421E:  RLCF   x4B,F
04220:  RLCF   x48,F
04222:  RLCF   x49,F
04224:  RLCF   x4A,F
04226:  RLCF   x4B,F
04228:  MOVLW  F0
0422A:  ANDWF  x48,F
0422C:  MOVLW  41
0422E:  SUBWF  x46,W
04230:  ADDLW  0A
04232:  ADDWF  x48,W
04234:  MOVWF  00
04236:  MOVLW  00
04238:  ADDWFC x49,W
0423A:  MOVWF  01
0423C:  MOVLW  00
0423E:  ADDWFC x4A,W
04240:  MOVWF  02
04242:  MOVLW  00
04244:  ADDWFC x4B,W
04246:  MOVWF  x42
04248:  MOVFF  02,741
0424C:  MOVFF  01,740
04250:  MOVFF  00,73F
....................  
....................             c = s[index++];c = toupper(c); 
04254:  MOVF   x45,W
04256:  INCF   x45,F
04258:  CLRF   03
0425A:  ADDWF  x3D,W
0425C:  MOVWF  FE9
0425E:  MOVF   x3E,W
04260:  ADDWFC 03,W
04262:  MOVWF  FEA
04264:  MOVF   FEF,W
04266:  MOVWF  x46
04268:  SUBLW  60
0426A:  BC    4278
0426C:  MOVF   x46,W
0426E:  SUBLW  7A
04270:  BNC   4278
04272:  MOVF   x46,W
04274:  ANDLW  DF
04276:  BRA    427A
04278:  MOVF   x46,W
0427A:  MOVWF  x46
....................          } 
0427C:  BRA    4186
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0427E:  MOVF   x44,W
04280:  SUBLW  0A
04282:  BNZ   429E
04284:  DECFSZ x43,W
04286:  BRA    429E
....................       result = -result; 
04288:  COMF   x3F,F
0428A:  COMF   x40,F
0428C:  COMF   x41,F
0428E:  COMF   x42,F
04290:  INCF   x3F,F
04292:  BTFSC  FD8.2
04294:  INCF   x40,F
04296:  BTFSC  FD8.2
04298:  INCF   x41,F
0429A:  BTFSC  FD8.2
0429C:  INCF   x42,F
....................  
....................    return(result); 
0429E:  MOVFF  73F,00
042A2:  MOVFF  740,01
042A6:  MOVFF  741,02
042AA:  MOVFF  742,03
.................... } 
042AE:  MOVLB  0
042B0:  GOTO   50F2 (RETURN)
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
*
027CA:  MOVLB  7
027CC:  CLRF   x52
027CE:  CLRF   x51
027D0:  CLRF   x50
027D2:  MOVLW  01
027D4:  MOVWF  x4F
027D6:  CLRF   x54
027D8:  CLRF   x55
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
027DA:  BTFSC  x4B.7
027DC:  BRA    27E0
027DE:  BRA    2814
....................          sign=1;        // Check for negative number 
027E0:  MOVLW  01
027E2:  MOVWF  x54
....................          num*=-1; 
027E4:  MOVFF  74B,75A
027E8:  MOVFF  74A,759
027EC:  MOVFF  749,758
027F0:  MOVFF  748,757
027F4:  MOVLW  FF
027F6:  MOVWF  x5E
027F8:  MOVWF  x5D
027FA:  MOVWF  x5C
027FC:  MOVWF  x5B
027FE:  MOVLB  0
02800:  BRA    2682
02802:  MOVFF  03,74B
02806:  MOVFF  02,74A
0280A:  MOVFF  01,749
0280E:  MOVFF  00,748
02812:  MOVLB  7
....................      } 
....................  
....................      while(temp>0) { 
02814:  MOVF   x4F,F
02816:  BNZ   2824
02818:  MOVF   x50,F
0281A:  BNZ   2824
0281C:  MOVF   x51,F
0281E:  BNZ   2824
02820:  MOVF   x52,F
02822:  BZ    28FE
....................          temp=(num/base); 
02824:  BCF    FD8.1
02826:  MOVFF  74B,762
0282A:  MOVFF  74A,761
0282E:  MOVFF  749,760
02832:  MOVFF  748,75F
02836:  CLRF   x66
02838:  CLRF   x65
0283A:  CLRF   x64
0283C:  MOVFF  74C,763
02840:  MOVLB  0
02842:  RCALL  26E0
02844:  MOVFF  03,752
02848:  MOVFF  02,751
0284C:  MOVFF  01,750
02850:  MOVFF  00,74F
....................          s[cnt]=(num%base)+'0';    // Conversion 
02854:  CLRF   03
02856:  MOVLB  7
02858:  MOVF   x55,W
0285A:  ADDWF  x4D,W
0285C:  MOVWF  01
0285E:  MOVF   x4E,W
02860:  ADDWFC 03,F
02862:  MOVFF  01,757
02866:  MOVFF  03,758
0286A:  MOVFF  FEA,75A
0286E:  MOVFF  FE9,759
02872:  BSF    FD8.1
02874:  MOVLW  07
02876:  MOVWF  FEA
02878:  MOVLW  5B
0287A:  MOVWF  FE9
0287C:  MOVFF  74B,762
02880:  MOVFF  74A,761
02884:  MOVFF  749,760
02888:  MOVFF  748,75F
0288C:  CLRF   x66
0288E:  CLRF   x65
02890:  CLRF   x64
02892:  MOVFF  74C,763
02896:  MOVLB  0
02898:  RCALL  26E0
0289A:  MOVFF  75A,FEA
0289E:  MOVFF  759,FE9
028A2:  MOVLW  30
028A4:  MOVLB  7
028A6:  ADDWF  x5B,W
028A8:  MOVWF  00
028AA:  MOVLW  00
028AC:  ADDWFC x5C,W
028AE:  MOVLW  00
028B0:  ADDWFC x5D,W
028B2:  MOVLW  00
028B4:  ADDWFC x5E,W
028B6:  MOVFF  758,FEA
028BA:  MOVFF  757,FE9
028BE:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
028C2:  CLRF   03
028C4:  MOVF   x55,W
028C6:  ADDWF  x4D,W
028C8:  MOVWF  FE9
028CA:  MOVF   x4E,W
028CC:  ADDWFC 03,W
028CE:  MOVWF  FEA
028D0:  MOVF   FEF,W
028D2:  SUBLW  39
028D4:  BC    28EA
....................             s[cnt]+=0x7; 
028D6:  CLRF   03
028D8:  MOVF   x55,W
028DA:  ADDWF  x4D,W
028DC:  MOVWF  FE9
028DE:  MOVF   x4E,W
028E0:  ADDWFC 03,W
028E2:  MOVWF  FEA
028E4:  MOVLW  07
028E6:  ADDWF  FEF,W
028E8:  MOVWF  FEF
....................  
....................          cnt++; 
028EA:  INCF   x55,F
....................          num=temp; 
028EC:  MOVFF  752,74B
028F0:  MOVFF  751,74A
028F4:  MOVFF  750,749
028F8:  MOVFF  74F,748
....................      } 
028FC:  BRA    2814
....................  
....................      if(sign==1) { 
028FE:  DECFSZ x54,W
02900:  BRA    2916
....................          s[cnt]=0x2D;      // Negative sign 
02902:  CLRF   03
02904:  MOVF   x55,W
02906:  ADDWF  x4D,W
02908:  MOVWF  FE9
0290A:  MOVF   x4E,W
0290C:  ADDWFC 03,W
0290E:  MOVWF  FEA
02910:  MOVLW  2D
02912:  MOVWF  FEF
....................          cnt++; 
02914:  INCF   x55,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
02916:  CLRF   x53
02918:  BCF    FD8.0
0291A:  RRCF   x55,W
0291C:  SUBWF  x53,W
0291E:  BC    297E
....................  
....................          c=s[i]; 
02920:  CLRF   03
02922:  MOVF   x53,W
02924:  ADDWF  x4D,W
02926:  MOVWF  FE9
02928:  MOVF   x4E,W
0292A:  ADDWFC 03,W
0292C:  MOVWF  FEA
0292E:  MOVFF  FEF,756
....................          s[i]=s[cnt-i-1];        // Reverse the number 
02932:  CLRF   03
02934:  MOVF   x53,W
02936:  ADDWF  x4D,W
02938:  MOVWF  01
0293A:  MOVF   x4E,W
0293C:  ADDWFC 03,F
0293E:  MOVFF  03,758
02942:  MOVF   x53,W
02944:  SUBWF  x55,W
02946:  ADDLW  FF
02948:  CLRF   03
0294A:  ADDWF  x4D,W
0294C:  MOVWF  FE9
0294E:  MOVF   x4E,W
02950:  ADDWFC 03,W
02952:  MOVWF  FEA
02954:  MOVFF  FEF,759
02958:  MOVFF  758,FEA
0295C:  MOVFF  01,FE9
02960:  MOVFF  759,FEF
....................          s[cnt-i-1]=c; 
02964:  MOVF   x53,W
02966:  SUBWF  x55,W
02968:  ADDLW  FF
0296A:  CLRF   03
0296C:  ADDWF  x4D,W
0296E:  MOVWF  FE9
02970:  MOVF   x4E,W
02972:  ADDWFC 03,W
02974:  MOVWF  FEA
02976:  MOVFF  756,FEF
....................      } 
0297A:  INCF   x53,F
0297C:  BRA    2918
....................      s[cnt]='\0';     // End the string 
0297E:  CLRF   03
02980:  MOVF   x55,W
02982:  ADDWF  x4D,W
02984:  MOVWF  FE9
02986:  MOVF   x4E,W
02988:  ADDWFC 03,W
0298A:  MOVWF  FEA
0298C:  CLRF   FEF
....................      return s; 
0298E:  MOVFF  74D,01
02992:  MOVFF  74E,02
.................... } 
02996:  MOVLB  0
02998:  RETLW  00
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "../config/menu.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           Menu.c                                //// 
.................... ////                                                                 //// 
.................... //// Ester archivo contiene las funciones para implementar un menu   //// 
.................... //// en una pantalla lcd grafica de 128x64 con controlador KS0108    //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  readbuttons(void)                                              //// 
.................... ////     * Lee los estados de los botones          .                 //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... ////  menu_entrar(int8 tb, int8 color)                               //// 
.................... ////     * Dibuja una flecha al final de una linea de texto.         //// 
.................... ////       - tb es el pixel donde comienza el texto.                 //// 
.................... ////       - color puede ser ON o OFF                                //// 
.................... ////                                                                 //// 
.................... ////  menu_select(char item, char menu)                              //// 
.................... ////     * Selecciona una linea de texto invirtiendo los colores.    //// 
.................... ////       - item es la linea a seleccionar.                         //// 
.................... ////       - menu identifica el menu principal o submenu             //// 
.................... ////                                                                 //// 
.................... ////  menu_submenu(char menu)                                        //// 
.................... ////     * Selecciona el submenu a dibujar                           //// 
.................... ////       - menu es el numero de submenu                            //// 
.................... ////                                                                 //// 
.................... ////  menu_mainmenu(void)                                            //// 
.................... ////     * Dibuja el menu principal y maneja los submenu             //// 
.................... ////                                                                 //// 
.................... ////  menu_timemenu(void)                                            //// 
.................... ////     * Dibuja y maneja el setup de fecha y hora                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef PIN_UP  
.................... #DEFINE PIN_UP       PIN_A0 
.................... #endif 
....................  
.................... #ifndef PIN_LEFT  
.................... #DEFINE PIN_LEFT     PIN_A1 
.................... #endif 
....................  
.................... #ifndef PIN_RIGHT 
.................... #DEFINE PIN_RIGHT    PIN_A2 
.................... #endif 
....................  
.................... #ifndef PIN_DOWN 
.................... #DEFINE PIN_DOWN     PIN_A3 
.................... #endif 
....................  
.................... #ifndef PIN_ENTER 
.................... #DEFINE PIN_ENTER    PIN_A4 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void readbuttons(void); 
.................... void menu_entrar(int8 tb, int8 color); 
.................... void menu_select(char item, char menu); 
.................... void menu_submenu(char menu); 
.................... void menu_mainmenu(void); 
.................... void menu_timemenu(void); 
.................... void menu_drawmain(void); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void readbuttons(void) 
.................... { 
.................... while (pressed==0) 
....................        { 
*
01D64:  MOVF   3E,F
01D66:  BNZ   1DC8
....................          lastup = up; 
01D68:  MOVFF  44,45
....................          lastdown = down; 
01D6C:  MOVFF  46,47
....................          lastleft = left; 
01D70:  MOVFF  4A,4B
....................          lastright = right; 
01D74:  MOVFF  4D,4C
....................          lastenter = enter; 
01D78:  MOVFF  48,49
....................          up = input(PIN_UP); 
01D7C:  BSF    F92.0
01D7E:  CLRF   44
01D80:  BTFSC  F80.0
01D82:  INCF   44,F
....................          down = input(PIN_DOWN); 
01D84:  BSF    F92.3
01D86:  CLRF   46
01D88:  BTFSC  F80.3
01D8A:  INCF   46,F
....................          left = input(PIN_LEFT); 
01D8C:  BSF    F92.1
01D8E:  CLRF   4A
01D90:  BTFSC  F80.1
01D92:  INCF   4A,F
....................          right = input(PIN_RIGHT); 
01D94:  BSF    F92.2
01D96:  CLRF   4D
01D98:  BTFSC  F80.2
01D9A:  INCF   4D,F
....................          enter = input(PIN_ENTER); 
01D9C:  BSF    F92.4
01D9E:  CLRF   48
01DA0:  BTFSC  F80.4
01DA2:  INCF   48,F
....................          if ((up!=lastup)||(down!=lastdown)||(enter!=lastenter)||(lastleft!=left)||(lastright!=right)) 
01DA4:  MOVF   45,W
01DA6:  SUBWF  44,W
01DA8:  BNZ   1DC2
01DAA:  MOVF   47,W
01DAC:  SUBWF  46,W
01DAE:  BNZ   1DC2
01DB0:  MOVF   49,W
01DB2:  SUBWF  48,W
01DB4:  BNZ   1DC2
01DB6:  MOVF   4A,W
01DB8:  SUBWF  4B,W
01DBA:  BNZ   1DC2
01DBC:  MOVF   4D,W
01DBE:  SUBWF  4C,W
01DC0:  BZ    1DC6
....................          { 
....................             pressed = 1; 
01DC2:  MOVLW  01
01DC4:  MOVWF  3E
....................          }         
....................        } 
01DC6:  BRA    1D64
.................... } 
01DC8:  RETLW  00
....................  
....................  
.................... void menu_entrar(int8 tb, int8 color) 
.................... { 
....................    glcd_line(124,tb,124,tb+7,color); 
*
01BA6:  MOVLW  07
01BA8:  MOVLB  7
01BAA:  ADDWF  x40,W
01BAC:  MOVWF  x42
01BAE:  MOVLW  7C
01BB0:  MOVWF  x87
01BB2:  MOVFF  740,788
01BB6:  MOVWF  x89
01BB8:  MOVFF  742,78A
01BBC:  MOVFF  741,78B
01BC0:  MOVLB  0
01BC2:  CALL   0FAA
....................    glcd_line(125,tb+1,125,tb+6,color); 
01BC6:  MOVLW  01
01BC8:  MOVLB  7
01BCA:  ADDWF  x40,W
01BCC:  MOVWF  x42
01BCE:  MOVLW  06
01BD0:  ADDWF  x40,W
01BD2:  MOVWF  x43
01BD4:  MOVLW  7D
01BD6:  MOVWF  x87
01BD8:  MOVFF  742,788
01BDC:  MOVWF  x89
01BDE:  MOVFF  743,78A
01BE2:  MOVFF  741,78B
01BE6:  MOVLB  0
01BE8:  CALL   0FAA
....................    glcd_line(126,tb+2,126,tb+5,color); 
01BEC:  MOVLW  02
01BEE:  MOVLB  7
01BF0:  ADDWF  x40,W
01BF2:  MOVWF  x42
01BF4:  MOVLW  05
01BF6:  ADDWF  x40,W
01BF8:  MOVWF  x43
01BFA:  MOVLW  7E
01BFC:  MOVWF  x87
01BFE:  MOVFF  742,788
01C02:  MOVWF  x89
01C04:  MOVFF  743,78A
01C08:  MOVFF  741,78B
01C0C:  MOVLB  0
01C0E:  CALL   0FAA
....................    glcd_line(127,tb+3,127,tb+4,color); 
01C12:  MOVLW  03
01C14:  MOVLB  7
01C16:  ADDWF  x40,W
01C18:  MOVWF  x42
01C1A:  MOVLW  04
01C1C:  ADDWF  x40,W
01C1E:  MOVWF  x43
01C20:  MOVLW  7F
01C22:  MOVWF  x87
01C24:  MOVFF  742,788
01C28:  MOVWF  x89
01C2A:  MOVFF  743,78A
01C2E:  MOVFF  741,78B
01C32:  MOVLB  0
01C34:  CALL   0FAA
....................     
.................... } 
01C38:  RETLW  00
....................  
....................  
.................... void menu_select(char item, char menu) 
.................... { 
....................    switch (menu) 
....................    { 
*
01DCA:  MOVLB  7
01DCC:  MOVF   x3F,W
01DCE:  ADDLW  FB
01DD0:  BTFSC  FD8.0
01DD2:  BRA    2446
01DD4:  ADDLW  05
01DD6:  MOVLB  0
01DD8:  GOTO   246C
....................       case 0: 
....................       { 
....................          switch (item) 
....................          { 
01DDC:  MOVLW  01
01DDE:  MOVLB  7
01DE0:  SUBWF  x3E,W
01DE2:  ADDLW  FC
01DE4:  BTFSC  FD8.0
01DE6:  BRA    1F7C
01DE8:  ADDLW  04
01DEA:  MOVLB  0
01DEC:  GOTO   244A
....................             case 1: 
....................             { 
....................                menu_drawmain(); 
01DF0:  RCALL  1C3A
....................                 
....................                glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
01DF2:  MOVLB  7
01DF4:  CLRF   x7C
01DF6:  MOVLW  11
01DF8:  MOVWF  x7D
01DFA:  MOVLW  7F
01DFC:  MOVWF  x7E
01DFE:  MOVLW  11
01E00:  MOVWF  x7F
01E02:  MOVLW  09
01E04:  MOVWF  x80
01E06:  MOVLW  01
01E08:  MOVWF  x81
01E0A:  MOVLB  0
01E0C:  CALL   1388
....................                glcd_text57(0, 14, MENU1, 1, OFF); 
01E10:  MOVLB  7
01E12:  CLRF   x7C
01E14:  MOVLW  0E
01E16:  MOVWF  x7D
01E18:  CLRF   x7F
01E1A:  MOVLW  5C
01E1C:  MOVWF  x7E
01E1E:  MOVLW  01
01E20:  MOVWF  x80
01E22:  CLRF   x81
01E24:  MOVLB  0
01E26:  RCALL  1738
....................                menu_entrar(14,OFF); 
01E28:  MOVLW  0E
01E2A:  MOVLB  7
01E2C:  MOVWF  x40
01E2E:  CLRF   x41
01E30:  MOVLB  0
01E32:  RCALL  1BA6
....................                 
....................                glcd_update(); 
01E34:  CALL   0D8C
....................                break; 
01E38:  MOVLB  7
01E3A:  BRA    1F7C
01E3C:  MOVLB  0
....................             } 
....................             case 2: 
....................             { 
....................                menu_drawmain();   
01E3E:  RCALL  1C3A
....................                 
....................                glcd_bar(0, 26, 127, 26, 9, ON);    //selected 
01E40:  MOVLB  7
01E42:  CLRF   x7C
01E44:  MOVLW  1A
01E46:  MOVWF  x7D
01E48:  MOVLW  7F
01E4A:  MOVWF  x7E
01E4C:  MOVLW  1A
01E4E:  MOVWF  x7F
01E50:  MOVLW  09
01E52:  MOVWF  x80
01E54:  MOVLW  01
01E56:  MOVWF  x81
01E58:  MOVLB  0
01E5A:  CALL   1388
....................                glcd_text57(0, 23, MENU2, 1, OFF); 
01E5E:  MOVLB  7
01E60:  CLRF   x7C
01E62:  MOVLW  17
01E64:  MOVWF  x7D
01E66:  CLRF   x7F
01E68:  MOVLW  6A
01E6A:  MOVWF  x7E
01E6C:  MOVLW  01
01E6E:  MOVWF  x80
01E70:  CLRF   x81
01E72:  MOVLB  0
01E74:  RCALL  1738
....................                glcd_text57(100, 23, UniTemp, 1, OFF); 
01E76:  MOVLW  64
01E78:  MOVLB  7
01E7A:  MOVWF  x7C
01E7C:  MOVLW  17
01E7E:  MOVWF  x7D
01E80:  CLRF   x7F
01E82:  MOVLW  DE
01E84:  MOVWF  x7E
01E86:  MOVLW  01
01E88:  MOVWF  x80
01E8A:  CLRF   x81
01E8C:  MOVLB  0
01E8E:  RCALL  1738
....................                menu_entrar(23,OFF); 
01E90:  MOVLW  17
01E92:  MOVLB  7
01E94:  MOVWF  x40
01E96:  CLRF   x41
01E98:  MOVLB  0
01E9A:  RCALL  1BA6
....................                 
....................                glcd_update(); 
01E9C:  CALL   0D8C
....................                break; 
01EA0:  MOVLB  7
01EA2:  BRA    1F7C
01EA4:  MOVLB  0
....................             } 
....................             case 3: 
....................             { 
....................                menu_drawmain();   
01EA6:  RCALL  1C3A
....................                
....................                glcd_bar(0, 35, 127, 35, 9, ON); //selected 
01EA8:  MOVLB  7
01EAA:  CLRF   x7C
01EAC:  MOVLW  23
01EAE:  MOVWF  x7D
01EB0:  MOVLW  7F
01EB2:  MOVWF  x7E
01EB4:  MOVLW  23
01EB6:  MOVWF  x7F
01EB8:  MOVLW  09
01EBA:  MOVWF  x80
01EBC:  MOVLW  01
01EBE:  MOVWF  x81
01EC0:  MOVLB  0
01EC2:  CALL   1388
....................                glcd_text57(0, 32, MENU3, 1, OFF); 
01EC6:  MOVLB  7
01EC8:  CLRF   x7C
01ECA:  MOVLW  20
01ECC:  MOVWF  x7D
01ECE:  CLRF   x7F
01ED0:  MOVLW  90
01ED2:  MOVWF  x7E
01ED4:  MOVLW  01
01ED6:  MOVWF  x80
01ED8:  CLRF   x81
01EDA:  MOVLB  0
01EDC:  RCALL  1738
....................                glcd_text57(100, 32, UniPres, 1, OFF); 
01EDE:  MOVLW  64
01EE0:  MOVLB  7
01EE2:  MOVWF  x7C
01EE4:  MOVLW  20
01EE6:  MOVWF  x7D
01EE8:  CLRF   x7F
01EEA:  MOVLW  E1
01EEC:  MOVWF  x7E
01EEE:  MOVLW  01
01EF0:  MOVWF  x80
01EF2:  CLRF   x81
01EF4:  MOVLB  0
01EF6:  RCALL  1738
....................                menu_entrar(32,OFF); 
01EF8:  MOVLW  20
01EFA:  MOVLB  7
01EFC:  MOVWF  x40
01EFE:  CLRF   x41
01F00:  MOVLB  0
01F02:  RCALL  1BA6
....................                 
....................                
....................                glcd_update(); 
01F04:  CALL   0D8C
....................                break; 
01F08:  MOVLB  7
01F0A:  BRA    1F7C
01F0C:  MOVLB  0
....................             } 
....................             case 4: 
....................             { 
....................                menu_drawmain();  
01F0E:  RCALL  1C3A
....................                 
....................                glcd_bar(0, 44, 127, 44, 9, ON); //selected 
01F10:  MOVLB  7
01F12:  CLRF   x7C
01F14:  MOVLW  2C
01F16:  MOVWF  x7D
01F18:  MOVLW  7F
01F1A:  MOVWF  x7E
01F1C:  MOVLW  2C
01F1E:  MOVWF  x7F
01F20:  MOVLW  09
01F22:  MOVWF  x80
01F24:  MOVLW  01
01F26:  MOVWF  x81
01F28:  MOVLB  0
01F2A:  CALL   1388
....................                glcd_text57(0, 41, MENU4, 1, OFF); 
01F2E:  MOVLB  7
01F30:  CLRF   x7C
01F32:  MOVLW  29
01F34:  MOVWF  x7D
01F36:  CLRF   x7F
01F38:  MOVLW  AC
01F3A:  MOVWF  x7E
01F3C:  MOVLW  01
01F3E:  MOVWF  x80
01F40:  CLRF   x81
01F42:  MOVLB  0
01F44:  CALL   1738
....................                glcd_text57(100, 41, UniVel, 1, OFF); 
01F48:  MOVLW  64
01F4A:  MOVLB  7
01F4C:  MOVWF  x7C
01F4E:  MOVLW  29
01F50:  MOVWF  x7D
01F52:  CLRF   x7F
01F54:  MOVLW  E5
01F56:  MOVWF  x7E
01F58:  MOVLW  01
01F5A:  MOVWF  x80
01F5C:  CLRF   x81
01F5E:  MOVLB  0
01F60:  CALL   1738
....................                menu_entrar(41,OFF); 
01F64:  MOVLW  29
01F66:  MOVLB  7
01F68:  MOVWF  x40
01F6A:  CLRF   x41
01F6C:  MOVLB  0
01F6E:  RCALL  1BA6
....................                 
....................           
....................                 
....................                glcd_update(); 
01F70:  CALL   0D8C
....................                break; 
01F74:  MOVLB  7
01F76:  BRA    1F7C
01F78:  MOVLB  0
01F7A:  MOVLB  7
....................             }             
....................          } 
....................          break; 
01F7C:  BRA    2446
01F7E:  MOVLB  0
....................       } 
....................       case 1: 
....................       { 
....................           
....................          break; 
01F80:  MOVLB  7
01F82:  BRA    2446
01F84:  MOVLB  0
....................       } 
....................       case 2: 
....................       { 
....................          switch (item) 
....................          { 
01F86:  MOVLB  7
01F88:  MOVF   x3E,W
01F8A:  XORLW  01
01F8C:  MOVLB  0
01F8E:  BZ    1F96
01F90:  XORLW  03
01F92:  BZ    202E
01F94:  BRA    20C6
....................             case 1: 
....................             { 
....................                glcd_fillScreen(OFF); 
01F96:  MOVLB  7
01F98:  CLRF   x48
01F9A:  MOVLB  0
01F9C:  CALL   0D32
....................                glcd_text57(0, 0, MENU2, 1, ON)   ; //Titulo 
01FA0:  MOVLB  7
01FA2:  CLRF   x7C
01FA4:  CLRF   x7D
01FA6:  CLRF   x7F
01FA8:  MOVLW  6A
01FAA:  MOVWF  x7E
01FAC:  MOVLW  01
01FAE:  MOVWF  x80
01FB0:  MOVWF  x81
01FB2:  MOVLB  0
01FB4:  CALL   1738
....................                glcd_bar(0, 9, 127, 9, 2, ON);      //div 
01FB8:  MOVLB  7
01FBA:  CLRF   x7C
01FBC:  MOVLW  09
01FBE:  MOVWF  x7D
01FC0:  MOVLW  7F
01FC2:  MOVWF  x7E
01FC4:  MOVLW  09
01FC6:  MOVWF  x7F
01FC8:  MOVLW  02
01FCA:  MOVWF  x80
01FCC:  MOVLW  01
01FCE:  MOVWF  x81
01FD0:  MOVLB  0
01FD2:  CALL   1388
....................                glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
01FD6:  MOVLB  7
01FD8:  CLRF   x7C
01FDA:  MOVLW  11
01FDC:  MOVWF  x7D
01FDE:  MOVLW  7F
01FE0:  MOVWF  x7E
01FE2:  MOVLW  11
01FE4:  MOVWF  x7F
01FE6:  MOVLW  09
01FE8:  MOVWF  x80
01FEA:  MOVLW  01
01FEC:  MOVWF  x81
01FEE:  MOVLB  0
01FF0:  CALL   1388
....................                glcd_text57(0, 14, MENU2ITEM1, 1, OFF); 
01FF4:  MOVLB  7
01FF6:  CLRF   x7C
01FF8:  MOVLW  0E
01FFA:  MOVWF  x7D
01FFC:  CLRF   x7F
01FFE:  MOVLW  7A
02000:  MOVWF  x7E
02002:  MOVLW  01
02004:  MOVWF  x80
02006:  CLRF   x81
02008:  MOVLB  0
0200A:  CALL   1738
....................                   
....................                glcd_text57(0, 23, MENU2ITEM2, 1, ON)   ; 
0200E:  MOVLB  7
02010:  CLRF   x7C
02012:  MOVLW  17
02014:  MOVWF  x7D
02016:  CLRF   x7F
02018:  MOVLW  84
0201A:  MOVWF  x7E
0201C:  MOVLW  01
0201E:  MOVWF  x80
02020:  MOVWF  x81
02022:  MOVLB  0
02024:  CALL   1738
....................                 
....................                glcd_update(); 
02028:  CALL   0D8C
....................                break; 
0202C:  BRA    20C6
....................             } 
....................             case 2: 
....................             { 
....................                glcd_fillScreen(OFF); 
0202E:  MOVLB  7
02030:  CLRF   x48
02032:  MOVLB  0
02034:  CALL   0D32
....................                glcd_text57(0, 0, MENU2, 1, ON);       //Titulo 
02038:  MOVLB  7
0203A:  CLRF   x7C
0203C:  CLRF   x7D
0203E:  CLRF   x7F
02040:  MOVLW  6A
02042:  MOVWF  x7E
02044:  MOVLW  01
02046:  MOVWF  x80
02048:  MOVWF  x81
0204A:  MOVLB  0
0204C:  CALL   1738
....................                glcd_bar(0, 9, 127, 9, 2, ON);         //div 
02050:  MOVLB  7
02052:  CLRF   x7C
02054:  MOVLW  09
02056:  MOVWF  x7D
02058:  MOVLW  7F
0205A:  MOVWF  x7E
0205C:  MOVLW  09
0205E:  MOVWF  x7F
02060:  MOVLW  02
02062:  MOVWF  x80
02064:  MOVLW  01
02066:  MOVWF  x81
02068:  MOVLB  0
0206A:  CALL   1388
....................                glcd_text57(0, 14, MENU2ITEM1, 1, ON); 
0206E:  MOVLB  7
02070:  CLRF   x7C
02072:  MOVLW  0E
02074:  MOVWF  x7D
02076:  CLRF   x7F
02078:  MOVLW  7A
0207A:  MOVWF  x7E
0207C:  MOVLW  01
0207E:  MOVWF  x80
02080:  MOVWF  x81
02082:  MOVLB  0
02084:  CALL   1738
....................                glcd_bar(0, 26, 127, 26, 9, ON);       //selected 
02088:  MOVLB  7
0208A:  CLRF   x7C
0208C:  MOVLW  1A
0208E:  MOVWF  x7D
02090:  MOVLW  7F
02092:  MOVWF  x7E
02094:  MOVLW  1A
02096:  MOVWF  x7F
02098:  MOVLW  09
0209A:  MOVWF  x80
0209C:  MOVLW  01
0209E:  MOVWF  x81
020A0:  MOVLB  0
020A2:  CALL   1388
....................                glcd_text57(0, 23, MENU2ITEM2, 1, OFF); 
020A6:  MOVLB  7
020A8:  CLRF   x7C
020AA:  MOVLW  17
020AC:  MOVWF  x7D
020AE:  CLRF   x7F
020B0:  MOVLW  84
020B2:  MOVWF  x7E
020B4:  MOVLW  01
020B6:  MOVWF  x80
020B8:  CLRF   x81
020BA:  MOVLB  0
020BC:  CALL   1738
....................           
....................                
....................                glcd_update(); 
020C0:  CALL   0D8C
....................                break; 
020C4:  BRA    20C6
....................             } 
....................              
....................          } 
....................        break; 
020C6:  MOVLB  7
020C8:  BRA    2446
020CA:  MOVLB  0
....................       } 
....................       case 3: 
....................       { 
....................          switch (item) 
....................                { 
020CC:  MOVLB  7
020CE:  MOVF   x3E,W
020D0:  XORLW  01
020D2:  MOVLB  0
020D4:  BZ    20DC
020D6:  XORLW  03
020D8:  BZ    2174
020DA:  BRA    220C
....................                   case 1: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
020DC:  MOVLB  7
020DE:  CLRF   x48
020E0:  MOVLB  0
020E2:  CALL   0D32
....................                      glcd_text57(0, 0, MENU3, 1, ON)   ; //Titulo 
020E6:  MOVLB  7
020E8:  CLRF   x7C
020EA:  CLRF   x7D
020EC:  CLRF   x7F
020EE:  MOVLW  90
020F0:  MOVWF  x7E
020F2:  MOVLW  01
020F4:  MOVWF  x80
020F6:  MOVWF  x81
020F8:  MOVLB  0
020FA:  CALL   1738
....................                      glcd_bar(0, 9, 127, 9, 2, ON);      //div 
020FE:  MOVLB  7
02100:  CLRF   x7C
02102:  MOVLW  09
02104:  MOVWF  x7D
02106:  MOVLW  7F
02108:  MOVWF  x7E
0210A:  MOVLW  09
0210C:  MOVWF  x7F
0210E:  MOVLW  02
02110:  MOVWF  x80
02112:  MOVLW  01
02114:  MOVWF  x81
02116:  MOVLB  0
02118:  CALL   1388
....................                      glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
0211C:  MOVLB  7
0211E:  CLRF   x7C
02120:  MOVLW  11
02122:  MOVWF  x7D
02124:  MOVLW  7F
02126:  MOVWF  x7E
02128:  MOVLW  11
0212A:  MOVWF  x7F
0212C:  MOVLW  09
0212E:  MOVWF  x80
02130:  MOVLW  01
02132:  MOVWF  x81
02134:  MOVLB  0
02136:  CALL   1388
....................                      glcd_text57(0, 14, MENU3ITEM1, 1, OFF); 
0213A:  MOVLB  7
0213C:  CLRF   x7C
0213E:  MOVLW  0E
02140:  MOVWF  x7D
02142:  CLRF   x7F
02144:  MOVLW  99
02146:  MOVWF  x7E
02148:  MOVLW  01
0214A:  MOVWF  x80
0214C:  CLRF   x81
0214E:  MOVLB  0
02150:  CALL   1738
....................                         
....................                      glcd_text57(0, 23, MENU3ITEM2, 1, ON)   ; 
02154:  MOVLB  7
02156:  CLRF   x7C
02158:  MOVLW  17
0215A:  MOVWF  x7D
0215C:  CLRF   x7F
0215E:  MOVLW  A2
02160:  MOVWF  x7E
02162:  MOVLW  01
02164:  MOVWF  x80
02166:  MOVWF  x81
02168:  MOVLB  0
0216A:  CALL   1738
....................                       
....................                      glcd_update(); 
0216E:  CALL   0D8C
....................                      break; 
02172:  BRA    220C
....................                   } 
....................                   case 2: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
02174:  MOVLB  7
02176:  CLRF   x48
02178:  MOVLB  0
0217A:  CALL   0D32
....................                      glcd_text57(0, 0, MENU3, 1, ON);       //Titulo 
0217E:  MOVLB  7
02180:  CLRF   x7C
02182:  CLRF   x7D
02184:  CLRF   x7F
02186:  MOVLW  90
02188:  MOVWF  x7E
0218A:  MOVLW  01
0218C:  MOVWF  x80
0218E:  MOVWF  x81
02190:  MOVLB  0
02192:  CALL   1738
....................                      glcd_bar(0, 9, 127, 9, 2, ON);         //div 
02196:  MOVLB  7
02198:  CLRF   x7C
0219A:  MOVLW  09
0219C:  MOVWF  x7D
0219E:  MOVLW  7F
021A0:  MOVWF  x7E
021A2:  MOVLW  09
021A4:  MOVWF  x7F
021A6:  MOVLW  02
021A8:  MOVWF  x80
021AA:  MOVLW  01
021AC:  MOVWF  x81
021AE:  MOVLB  0
021B0:  CALL   1388
....................                      glcd_text57(0, 14, MENU3ITEM1, 1, ON); 
021B4:  MOVLB  7
021B6:  CLRF   x7C
021B8:  MOVLW  0E
021BA:  MOVWF  x7D
021BC:  CLRF   x7F
021BE:  MOVLW  99
021C0:  MOVWF  x7E
021C2:  MOVLW  01
021C4:  MOVWF  x80
021C6:  MOVWF  x81
021C8:  MOVLB  0
021CA:  CALL   1738
....................                      glcd_bar(0, 26, 127, 26, 9, ON);       //selected 
021CE:  MOVLB  7
021D0:  CLRF   x7C
021D2:  MOVLW  1A
021D4:  MOVWF  x7D
021D6:  MOVLW  7F
021D8:  MOVWF  x7E
021DA:  MOVLW  1A
021DC:  MOVWF  x7F
021DE:  MOVLW  09
021E0:  MOVWF  x80
021E2:  MOVLW  01
021E4:  MOVWF  x81
021E6:  MOVLB  0
021E8:  CALL   1388
....................                      glcd_text57(0, 23, MENU3ITEM2, 1, OFF); 
021EC:  MOVLB  7
021EE:  CLRF   x7C
021F0:  MOVLW  17
021F2:  MOVWF  x7D
021F4:  CLRF   x7F
021F6:  MOVLW  A2
021F8:  MOVWF  x7E
021FA:  MOVLW  01
021FC:  MOVWF  x80
021FE:  CLRF   x81
02200:  MOVLB  0
02202:  CALL   1738
....................                 
....................                      
....................                      glcd_update(); 
02206:  CALL   0D8C
....................                      break; 
0220A:  BRA    220C
....................                   } 
....................                } 
....................                break; 
0220C:  MOVLB  7
0220E:  BRA    2446
02210:  MOVLB  0
....................       } 
....................       case 4: 
....................       { 
....................          switch (item) 
....................                { 
02212:  MOVLB  7
02214:  MOVF   x3E,W
02216:  XORLW  01
02218:  MOVLB  0
0221A:  BZ    2228
0221C:  XORLW  03
0221E:  BZ    22DA
02220:  XORLW  01
02222:  BTFSC  FD8.2
02224:  BRA    238C
02226:  BRA    243E
....................                   case 1: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
02228:  MOVLB  7
0222A:  CLRF   x48
0222C:  MOVLB  0
0222E:  CALL   0D32
....................                      glcd_text57(0, 0, MENU4, 1, ON)   ; //Titulo 
02232:  MOVLB  7
02234:  CLRF   x7C
02236:  CLRF   x7D
02238:  CLRF   x7F
0223A:  MOVLW  AC
0223C:  MOVWF  x7E
0223E:  MOVLW  01
02240:  MOVWF  x80
02242:  MOVWF  x81
02244:  MOVLB  0
02246:  CALL   1738
....................                      glcd_bar(0, 9, 127, 9, 2, ON);      //div 
0224A:  MOVLB  7
0224C:  CLRF   x7C
0224E:  MOVLW  09
02250:  MOVWF  x7D
02252:  MOVLW  7F
02254:  MOVWF  x7E
02256:  MOVLW  09
02258:  MOVWF  x7F
0225A:  MOVLW  02
0225C:  MOVWF  x80
0225E:  MOVLW  01
02260:  MOVWF  x81
02262:  MOVLB  0
02264:  CALL   1388
....................                      glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
02268:  MOVLB  7
0226A:  CLRF   x7C
0226C:  MOVLW  11
0226E:  MOVWF  x7D
02270:  MOVLW  7F
02272:  MOVWF  x7E
02274:  MOVLW  11
02276:  MOVWF  x7F
02278:  MOVLW  09
0227A:  MOVWF  x80
0227C:  MOVLW  01
0227E:  MOVWF  x81
02280:  MOVLB  0
02282:  CALL   1388
....................                      glcd_text57(0, 14, MENU4ITEM1, 1, OFF); 
02286:  MOVLB  7
02288:  CLRF   x7C
0228A:  MOVLW  0E
0228C:  MOVWF  x7D
0228E:  CLRF   x7F
02290:  MOVLW  B7
02292:  MOVWF  x7E
02294:  MOVLW  01
02296:  MOVWF  x80
02298:  CLRF   x81
0229A:  MOVLB  0
0229C:  CALL   1738
....................                         
....................                      glcd_text57(0, 23, MENU4ITEM2, 1, ON)   ; 
022A0:  MOVLB  7
022A2:  CLRF   x7C
022A4:  MOVLW  17
022A6:  MOVWF  x7D
022A8:  CLRF   x7F
022AA:  MOVLW  BD
022AC:  MOVWF  x7E
022AE:  MOVLW  01
022B0:  MOVWF  x80
022B2:  MOVWF  x81
022B4:  MOVLB  0
022B6:  CALL   1738
....................                      glcd_text57(0, 32, MENU4ITEM3, 1, ON)   ; 
022BA:  MOVLB  7
022BC:  CLRF   x7C
022BE:  MOVLW  20
022C0:  MOVWF  x7D
022C2:  CLRF   x7F
022C4:  MOVLW  C4
022C6:  MOVWF  x7E
022C8:  MOVLW  01
022CA:  MOVWF  x80
022CC:  MOVWF  x81
022CE:  MOVLB  0
022D0:  CALL   1738
....................                      glcd_update(); 
022D4:  CALL   0D8C
....................                      break; 
022D8:  BRA    243E
....................                   } 
....................                   case 2: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
022DA:  MOVLB  7
022DC:  CLRF   x48
022DE:  MOVLB  0
022E0:  CALL   0D32
....................                      glcd_text57(0, 0, MENU4, 1, ON);       //Titulo 
022E4:  MOVLB  7
022E6:  CLRF   x7C
022E8:  CLRF   x7D
022EA:  CLRF   x7F
022EC:  MOVLW  AC
022EE:  MOVWF  x7E
022F0:  MOVLW  01
022F2:  MOVWF  x80
022F4:  MOVWF  x81
022F6:  MOVLB  0
022F8:  CALL   1738
....................                      glcd_bar(0, 9, 127, 9, 2, ON);         //div 
022FC:  MOVLB  7
022FE:  CLRF   x7C
02300:  MOVLW  09
02302:  MOVWF  x7D
02304:  MOVLW  7F
02306:  MOVWF  x7E
02308:  MOVLW  09
0230A:  MOVWF  x7F
0230C:  MOVLW  02
0230E:  MOVWF  x80
02310:  MOVLW  01
02312:  MOVWF  x81
02314:  MOVLB  0
02316:  CALL   1388
....................                      glcd_text57(0, 14, MENU4ITEM1, 1, ON); 
0231A:  MOVLB  7
0231C:  CLRF   x7C
0231E:  MOVLW  0E
02320:  MOVWF  x7D
02322:  CLRF   x7F
02324:  MOVLW  B7
02326:  MOVWF  x7E
02328:  MOVLW  01
0232A:  MOVWF  x80
0232C:  MOVWF  x81
0232E:  MOVLB  0
02330:  CALL   1738
....................                      glcd_bar(0, 26, 127, 26, 9, ON);       //selected 
02334:  MOVLB  7
02336:  CLRF   x7C
02338:  MOVLW  1A
0233A:  MOVWF  x7D
0233C:  MOVLW  7F
0233E:  MOVWF  x7E
02340:  MOVLW  1A
02342:  MOVWF  x7F
02344:  MOVLW  09
02346:  MOVWF  x80
02348:  MOVLW  01
0234A:  MOVWF  x81
0234C:  MOVLB  0
0234E:  CALL   1388
....................                      glcd_text57(0, 23, MENU4ITEM2, 1, OFF); 
02352:  MOVLB  7
02354:  CLRF   x7C
02356:  MOVLW  17
02358:  MOVWF  x7D
0235A:  CLRF   x7F
0235C:  MOVLW  BD
0235E:  MOVWF  x7E
02360:  MOVLW  01
02362:  MOVWF  x80
02364:  CLRF   x81
02366:  MOVLB  0
02368:  CALL   1738
....................                      glcd_text57(0, 32, MENU4ITEM3, 1, ON)   ; 
0236C:  MOVLB  7
0236E:  CLRF   x7C
02370:  MOVLW  20
02372:  MOVWF  x7D
02374:  CLRF   x7F
02376:  MOVLW  C4
02378:  MOVWF  x7E
0237A:  MOVLW  01
0237C:  MOVWF  x80
0237E:  MOVWF  x81
02380:  MOVLB  0
02382:  CALL   1738
....................                      
....................                      glcd_update(); 
02386:  CALL   0D8C
....................                      break; 
0238A:  BRA    243E
....................                   } 
....................                   case 3: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
0238C:  MOVLB  7
0238E:  CLRF   x48
02390:  MOVLB  0
02392:  CALL   0D32
....................                      glcd_text57(0, 0, MENU4, 1, ON);       //Titulo 
02396:  MOVLB  7
02398:  CLRF   x7C
0239A:  CLRF   x7D
0239C:  CLRF   x7F
0239E:  MOVLW  AC
023A0:  MOVWF  x7E
023A2:  MOVLW  01
023A4:  MOVWF  x80
023A6:  MOVWF  x81
023A8:  MOVLB  0
023AA:  CALL   1738
....................                      glcd_bar(0, 9, 127, 9, 2, ON);         //div 
023AE:  MOVLB  7
023B0:  CLRF   x7C
023B2:  MOVLW  09
023B4:  MOVWF  x7D
023B6:  MOVLW  7F
023B8:  MOVWF  x7E
023BA:  MOVLW  09
023BC:  MOVWF  x7F
023BE:  MOVLW  02
023C0:  MOVWF  x80
023C2:  MOVLW  01
023C4:  MOVWF  x81
023C6:  MOVLB  0
023C8:  CALL   1388
....................                      glcd_text57(0, 14, MENU4ITEM1, 1, ON); 
023CC:  MOVLB  7
023CE:  CLRF   x7C
023D0:  MOVLW  0E
023D2:  MOVWF  x7D
023D4:  CLRF   x7F
023D6:  MOVLW  B7
023D8:  MOVWF  x7E
023DA:  MOVLW  01
023DC:  MOVWF  x80
023DE:  MOVWF  x81
023E0:  MOVLB  0
023E2:  CALL   1738
....................                      
....................                      glcd_text57(0, 23, MENU4ITEM2, 1, ON); 
023E6:  MOVLB  7
023E8:  CLRF   x7C
023EA:  MOVLW  17
023EC:  MOVWF  x7D
023EE:  CLRF   x7F
023F0:  MOVLW  BD
023F2:  MOVWF  x7E
023F4:  MOVLW  01
023F6:  MOVWF  x80
023F8:  MOVWF  x81
023FA:  MOVLB  0
023FC:  CALL   1738
....................                      glcd_bar(0, 35, 127, 35, 9, ON); //selected 
02400:  MOVLB  7
02402:  CLRF   x7C
02404:  MOVLW  23
02406:  MOVWF  x7D
02408:  MOVLW  7F
0240A:  MOVWF  x7E
0240C:  MOVLW  23
0240E:  MOVWF  x7F
02410:  MOVLW  09
02412:  MOVWF  x80
02414:  MOVLW  01
02416:  MOVWF  x81
02418:  MOVLB  0
0241A:  CALL   1388
....................                      glcd_text57(0, 32, MENU4ITEM3, 1, OFF)   ; 
0241E:  MOVLB  7
02420:  CLRF   x7C
02422:  MOVLW  20
02424:  MOVWF  x7D
02426:  CLRF   x7F
02428:  MOVLW  C4
0242A:  MOVWF  x7E
0242C:  MOVLW  01
0242E:  MOVWF  x80
02430:  CLRF   x81
02432:  MOVLB  0
02434:  CALL   1738
....................                      
....................                      glcd_update(); 
02438:  CALL   0D8C
....................                      break; 
0243C:  BRA    243E
....................                   } 
....................                } 
....................                break; 
0243E:  MOVLB  7
02440:  BRA    2446
02442:  MOVLB  0
02444:  MOVLB  7
....................       } 
....................     
....................    } 
.................... } 
02446:  MOVLB  0
02448:  RETLW  00
....................  
.................... void menu_submenu(char menu) 
.................... { 
....................    switch (menu) 
....................    { 
*
03746:  MOVLW  01
03748:  MOVLB  7
0374A:  SUBWF  x3D,W
0374C:  ADDLW  FC
0374E:  BTFSC  FD8.0
03750:  BRA    3904
03752:  ADDLW  04
03754:  MOVLB  0
03756:  GOTO   3A50
....................       case 1: 
....................       {   
....................          menu_timemenu(); 
0375A:  GOTO   299A
....................          i=0; 
0375E:  CLRF   3C
....................          return; 
03760:  BRA    3A4C
....................          break; 
03762:  MOVLB  7
03764:  BRA    3904
03766:  MOVLB  0
....................       } 
....................       case 2: 
....................       {   
....................           
....................          glcd_fillScreen(OFF); 
03768:  MOVLB  7
0376A:  CLRF   x48
0376C:  MOVLB  0
0376E:  CALL   0D32
....................          glcd_text57(0, 0, MENU2, 1, ON)   ; 
03772:  MOVLB  7
03774:  CLRF   x7C
03776:  CLRF   x7D
03778:  CLRF   x7F
0377A:  MOVLW  6A
0377C:  MOVWF  x7E
0377E:  MOVLW  01
03780:  MOVWF  x80
03782:  MOVWF  x81
03784:  MOVLB  0
03786:  CALL   1738
....................          glcd_bar(0, 9, 127, 9, 2, ON); //div 
0378A:  MOVLB  7
0378C:  CLRF   x7C
0378E:  MOVLW  09
03790:  MOVWF  x7D
03792:  MOVLW  7F
03794:  MOVWF  x7E
03796:  MOVLW  09
03798:  MOVWF  x7F
0379A:  MOVLW  02
0379C:  MOVWF  x80
0379E:  MOVLW  01
037A0:  MOVWF  x81
037A2:  MOVLB  0
037A4:  CALL   1388
....................          glcd_text57(0, 14, MENU2ITEM1, 1, ON)   ; 
037A8:  MOVLB  7
037AA:  CLRF   x7C
037AC:  MOVLW  0E
037AE:  MOVWF  x7D
037B0:  CLRF   x7F
037B2:  MOVLW  7A
037B4:  MOVWF  x7E
037B6:  MOVLW  01
037B8:  MOVWF  x80
037BA:  MOVWF  x81
037BC:  MOVLB  0
037BE:  CALL   1738
....................          glcd_text57(0, 23, MENU2ITEM2, 1, ON)   ; 
037C2:  MOVLB  7
037C4:  CLRF   x7C
037C6:  MOVLW  17
037C8:  MOVWF  x7D
037CA:  CLRF   x7F
037CC:  MOVLW  84
037CE:  MOVWF  x7E
037D0:  MOVLW  01
037D2:  MOVWF  x80
037D4:  MOVWF  x81
037D6:  MOVLB  0
037D8:  CALL   1738
....................          glcd_update(); 
037DC:  CALL   0D8C
....................          i = 0; 
037E0:  CLRF   3C
....................          break; 
037E2:  MOVLB  7
037E4:  BRA    3904
037E6:  MOVLB  0
....................       } 
....................       case 3: 
....................       {   
....................          glcd_fillScreen(OFF); 
037E8:  MOVLB  7
037EA:  CLRF   x48
037EC:  MOVLB  0
037EE:  CALL   0D32
....................          glcd_text57(0, 0, MENU3, 1, ON)   ; 
037F2:  MOVLB  7
037F4:  CLRF   x7C
037F6:  CLRF   x7D
037F8:  CLRF   x7F
037FA:  MOVLW  90
037FC:  MOVWF  x7E
037FE:  MOVLW  01
03800:  MOVWF  x80
03802:  MOVWF  x81
03804:  MOVLB  0
03806:  CALL   1738
....................          glcd_bar(0, 9, 127, 9, 2, ON); //div 
0380A:  MOVLB  7
0380C:  CLRF   x7C
0380E:  MOVLW  09
03810:  MOVWF  x7D
03812:  MOVLW  7F
03814:  MOVWF  x7E
03816:  MOVLW  09
03818:  MOVWF  x7F
0381A:  MOVLW  02
0381C:  MOVWF  x80
0381E:  MOVLW  01
03820:  MOVWF  x81
03822:  MOVLB  0
03824:  CALL   1388
....................          glcd_text57(0, 14, MENU3ITEM1, 1, ON)   ; 
03828:  MOVLB  7
0382A:  CLRF   x7C
0382C:  MOVLW  0E
0382E:  MOVWF  x7D
03830:  CLRF   x7F
03832:  MOVLW  99
03834:  MOVWF  x7E
03836:  MOVLW  01
03838:  MOVWF  x80
0383A:  MOVWF  x81
0383C:  MOVLB  0
0383E:  CALL   1738
....................          glcd_text57(0, 23, MENU3ITEM2, 1, ON)   ; 
03842:  MOVLB  7
03844:  CLRF   x7C
03846:  MOVLW  17
03848:  MOVWF  x7D
0384A:  CLRF   x7F
0384C:  MOVLW  A2
0384E:  MOVWF  x7E
03850:  MOVLW  01
03852:  MOVWF  x80
03854:  MOVWF  x81
03856:  MOVLB  0
03858:  CALL   1738
....................          glcd_update(); 
0385C:  CALL   0D8C
....................          i = 0; 
03860:  CLRF   3C
....................          break; 
03862:  MOVLB  7
03864:  BRA    3904
03866:  MOVLB  0
....................       } 
....................       case 4: 
....................       {   
....................          glcd_fillScreen(OFF); 
03868:  MOVLB  7
0386A:  CLRF   x48
0386C:  MOVLB  0
0386E:  CALL   0D32
....................          glcd_text57(0, 0, MENU4, 1, ON)   ; 
03872:  MOVLB  7
03874:  CLRF   x7C
03876:  CLRF   x7D
03878:  CLRF   x7F
0387A:  MOVLW  AC
0387C:  MOVWF  x7E
0387E:  MOVLW  01
03880:  MOVWF  x80
03882:  MOVWF  x81
03884:  MOVLB  0
03886:  CALL   1738
....................          glcd_bar(0, 9, 127, 9, 2, ON); //div 
0388A:  MOVLB  7
0388C:  CLRF   x7C
0388E:  MOVLW  09
03890:  MOVWF  x7D
03892:  MOVLW  7F
03894:  MOVWF  x7E
03896:  MOVLW  09
03898:  MOVWF  x7F
0389A:  MOVLW  02
0389C:  MOVWF  x80
0389E:  MOVLW  01
038A0:  MOVWF  x81
038A2:  MOVLB  0
038A4:  CALL   1388
....................          glcd_text57(0, 14, MENU4ITEM1, 1, ON)   ; 
038A8:  MOVLB  7
038AA:  CLRF   x7C
038AC:  MOVLW  0E
038AE:  MOVWF  x7D
038B0:  CLRF   x7F
038B2:  MOVLW  B7
038B4:  MOVWF  x7E
038B6:  MOVLW  01
038B8:  MOVWF  x80
038BA:  MOVWF  x81
038BC:  MOVLB  0
038BE:  CALL   1738
....................          glcd_text57(0, 23, MENU4ITEM2, 1, ON)   ; 
038C2:  MOVLB  7
038C4:  CLRF   x7C
038C6:  MOVLW  17
038C8:  MOVWF  x7D
038CA:  CLRF   x7F
038CC:  MOVLW  BD
038CE:  MOVWF  x7E
038D0:  MOVLW  01
038D2:  MOVWF  x80
038D4:  MOVWF  x81
038D6:  MOVLB  0
038D8:  CALL   1738
....................          glcd_text57(0, 32, MENU4ITEM3, 1, ON)   ; 
038DC:  MOVLB  7
038DE:  CLRF   x7C
038E0:  MOVLW  20
038E2:  MOVWF  x7D
038E4:  CLRF   x7F
038E6:  MOVLW  C4
038E8:  MOVWF  x7E
038EA:  MOVLW  01
038EC:  MOVWF  x80
038EE:  MOVWF  x81
038F0:  MOVLB  0
038F2:  CALL   1738
....................          glcd_update(); 
038F6:  CALL   0D8C
....................          i = 0; 
038FA:  CLRF   3C
....................          break; 
038FC:  MOVLB  7
038FE:  BRA    3904
03900:  MOVLB  0
03902:  MOVLB  7
....................       } 
....................    } 
....................     
....................    while(1) 
....................    { 
....................       readbuttons(); 
03904:  MOVLB  0
03906:  CALL   1D64
....................       if ((up==0)&&(down==1)) 
0390A:  MOVF   44,F
0390C:  BNZ   3922
0390E:  DECFSZ 46,W
03910:  BRA    3922
....................       { 
....................          i+=1; 
03912:  MOVLW  01
03914:  ADDWF  3C,F
....................          menu_select(i,menu); 
03916:  MOVFF  3C,73E
0391A:  MOVFF  73D,73F
0391E:  CALL   1DCA
....................           
....................       } 
....................       if ((up==1)&&(down==0)) 
03922:  DECFSZ 44,W
03924:  BRA    393A
03926:  MOVF   46,F
03928:  BNZ   393A
....................       { 
....................          i-=1; 
0392A:  MOVLW  01
0392C:  SUBWF  3C,F
....................          menu_select(i,menu); 
0392E:  MOVFF  3C,73E
03932:  MOVFF  73D,73F
03936:  CALL   1DCA
....................           
....................       } 
....................       if (left==1) 
0393A:  DECFSZ 4A,W
0393C:  BRA    3944
....................       { 
....................          i = 0; 
0393E:  CLRF   3C
....................           
....................          pressed = 0; 
03940:  CLRF   3E
....................          break; 
03942:  BRA    3A4A
....................       } 
....................       if (enter==1) 
03944:  DECFSZ 48,W
03946:  BRA    3A46
....................       { 
....................          switch (menu) 
....................          { 
03948:  MOVLB  7
0394A:  MOVF   x3D,W
0394C:  XORLW  02
0394E:  MOVLB  0
03950:  BZ    395C
03952:  XORLW  01
03954:  BZ    399E
03956:  XORLW  07
03958:  BZ    39E0
0395A:  BRA    3A40
....................             case 2: 
....................             { 
....................                switch (i) 
....................                { 
0395C:  MOVF   3C,W
0395E:  XORLW  01
03960:  BZ    3968
03962:  XORLW  03
03964:  BZ    3982
03966:  BRA    399C
....................                   case 1: 
....................                   { 
....................                      UniTemp = "C"; 
03968:  CLRF   FEA
0396A:  MOVLW  DE
0396C:  MOVWF  FE9
0396E:  MOVLW  00
03970:  CALL   07B6
03974:  TBLRD*-
03976:  TBLRD*+
03978:  MOVF   FF5,W
0397A:  MOVWF  FEE
0397C:  IORLW  00
0397E:  BNZ   3976
....................                       
....................                      break; 
03980:  BRA    399C
....................                   } 
....................                   case 2: 
....................                   { 
....................                      UniTemp = "F"; 
03982:  CLRF   FEA
03984:  MOVLW  DE
03986:  MOVWF  FE9
03988:  MOVLW  00
0398A:  CALL   07C8
0398E:  TBLRD*-
03990:  TBLRD*+
03992:  MOVF   FF5,W
03994:  MOVWF  FEE
03996:  IORLW  00
03998:  BNZ   3990
....................                       
....................                      break; 
0399A:  BRA    399C
....................                   } 
....................                } 
....................                break; 
0399C:  BRA    3A40
....................             } 
....................             case 3: 
....................             { 
....................                switch (i) 
....................                { 
0399E:  MOVF   3C,W
039A0:  XORLW  01
039A2:  BZ    39AA
039A4:  XORLW  03
039A6:  BZ    39C4
039A8:  BRA    39DE
....................                   case 1: 
....................                   { 
....................                      UniPres = "Pa"; 
039AA:  CLRF   FEA
039AC:  MOVLW  E1
039AE:  MOVWF  FE9
039B0:  MOVLW  00
039B2:  CALL   07DA
039B6:  TBLRD*-
039B8:  TBLRD*+
039BA:  MOVF   FF5,W
039BC:  MOVWF  FEE
039BE:  IORLW  00
039C0:  BNZ   39B8
....................                       
....................                      break; 
039C2:  BRA    39DE
....................                   } 
....................                   case 2: 
....................                   { 
....................                      UniPres = "mBa";                      
039C4:  CLRF   FEA
039C6:  MOVLW  E1
039C8:  MOVWF  FE9
039CA:  MOVLW  00
039CC:  CALL   07EE
039D0:  TBLRD*-
039D2:  TBLRD*+
039D4:  MOVF   FF5,W
039D6:  MOVWF  FEE
039D8:  IORLW  00
039DA:  BNZ   39D2
....................                      break; 
039DC:  BRA    39DE
....................                   } 
....................                } 
....................                break; 
039DE:  BRA    3A40
....................             } 
....................             case 4: 
....................             { 
....................                switch (i) 
....................                { 
039E0:  MOVF   3C,W
039E2:  XORLW  01
039E4:  BZ    39F0
039E6:  XORLW  03
039E8:  BZ    3A0A
039EA:  XORLW  01
039EC:  BZ    3A24
039EE:  BRA    3A3E
....................                   case 1: 
....................                   { 
....................                      UniVel = "m/s"; 
039F0:  CLRF   FEA
039F2:  MOVLW  E5
039F4:  MOVWF  FE9
039F6:  MOVLW  00
039F8:  CALL   0802
039FC:  TBLRD*-
039FE:  TBLRD*+
03A00:  MOVF   FF5,W
03A02:  MOVWF  FEE
03A04:  IORLW  00
03A06:  BNZ   39FE
....................                       
....................                      break; 
03A08:  BRA    3A3E
....................                   } 
....................                   case 2: 
....................                   { 
....................                      UniVel = "km/h"; 
03A0A:  CLRF   FEA
03A0C:  MOVLW  E5
03A0E:  MOVWF  FE9
03A10:  MOVLW  00
03A12:  CALL   0816
03A16:  TBLRD*-
03A18:  TBLRD*+
03A1A:  MOVF   FF5,W
03A1C:  MOVWF  FEE
03A1E:  IORLW  00
03A20:  BNZ   3A18
....................                       
....................                      break; 
03A22:  BRA    3A3E
....................                   } 
....................                   case 3: 
....................                   { 
....................                      UniVel = "Nud";  
03A24:  CLRF   FEA
03A26:  MOVLW  E5
03A28:  MOVWF  FE9
03A2A:  MOVLW  00
03A2C:  CALL   082C
03A30:  TBLRD*-
03A32:  TBLRD*+
03A34:  MOVF   FF5,W
03A36:  MOVWF  FEE
03A38:  IORLW  00
03A3A:  BNZ   3A32
....................                      break; 
03A3C:  BRA    3A3E
....................                   } 
....................                } 
....................                break; 
03A3E:  BRA    3A40
....................             } 
....................                 
....................          } 
....................          i=0; 
03A40:  CLRF   3C
....................          pressed=0; 
03A42:  CLRF   3E
....................          break; 
03A44:  BRA    3A4A
....................       } 
....................       pressed = 0; 
03A46:  CLRF   3E
....................    } 
03A48:  BRA    3906
....................    pressed = 0; 
03A4A:  CLRF   3E
.................... } 
03A4C:  GOTO   3AC2 (RETURN)
....................  
.................... void menu_mainmenu(void) 
.................... { 
....................    menu_drawmain(); 
*
03A72:  CALL   1C3A
....................    while (1) 
....................    { 
....................       readbuttons(); 
03A76:  CALL   1D64
....................       if (enter==1) 
03A7A:  DECFSZ 48,W
03A7C:  BRA    3A80
....................       { 
....................          return; 
03A7E:  BRA    3ACE
....................       } 
....................       if ((up==0)&&(down==1)) 
03A80:  MOVF   44,F
03A82:  BNZ   3A9A
03A84:  DECFSZ 46,W
03A86:  BRA    3A9A
....................       { 
....................          i+=1; 
03A88:  MOVLW  01
03A8A:  ADDWF  3C,F
....................          menu_select(i,0); 
03A8C:  MOVFF  3C,73E
03A90:  MOVLB  7
03A92:  CLRF   x3F
03A94:  MOVLB  0
03A96:  CALL   1DCA
....................           
....................       } 
....................       if ((up==1)&&(down==0)) 
03A9A:  DECFSZ 44,W
03A9C:  BRA    3AB4
03A9E:  MOVF   46,F
03AA0:  BNZ   3AB4
....................       { 
....................          i-=1; 
03AA2:  MOVLW  01
03AA4:  SUBWF  3C,F
....................          menu_select(i,0); 
03AA6:  MOVFF  3C,73E
03AAA:  MOVLB  7
03AAC:  CLRF   x3F
03AAE:  MOVLB  0
03AB0:  CALL   1DCA
....................           
....................       } 
....................       if (right==1) 
03AB4:  DECFSZ 4D,W
03AB6:  BRA    3ACA
....................       { 
....................          if (i) 
03AB8:  MOVF   3C,F
03ABA:  BZ    3AC2
....................          { 
....................             menu_submenu(i); 
03ABC:  MOVFF  3C,73D
03AC0:  BRA    3746
....................          } 
....................          if (i==0) 
03AC2:  MOVF   3C,F
03AC4:  BNZ   3ACA
....................          { 
....................             menu_drawmain(); 
03AC6:  CALL   1C3A
....................          } 
....................           
....................                    
....................       } 
....................        
....................       pressed = 0; 
03ACA:  CLRF   3E
....................    } 
03ACC:  BRA    3A76
.................... } 
03ACE:  RETLW  00
....................  
.................... void menu_timemenu(void) 
.................... { 
....................    glcd_fillScreen(OFF); 
*
0299A:  MOVLB  7
0299C:  CLRF   x48
0299E:  MOVLB  0
029A0:  CALL   0D32
....................    glcd_text57(0, 0, MENU1, 1, ON); 
029A4:  MOVLB  7
029A6:  CLRF   x7C
029A8:  CLRF   x7D
029AA:  CLRF   x7F
029AC:  MOVLW  5C
029AE:  MOVWF  x7E
029B0:  MOVLW  01
029B2:  MOVWF  x80
029B4:  MOVWF  x81
029B6:  MOVLB  0
029B8:  CALL   1738
....................    glcd_bar(0, 9, 127, 9, 2, ON); //div 
029BC:  MOVLB  7
029BE:  CLRF   x7C
029C0:  MOVLW  09
029C2:  MOVWF  x7D
029C4:  MOVLW  7F
029C6:  MOVWF  x7E
029C8:  MOVLW  09
029CA:  MOVWF  x7F
029CC:  MOVLW  02
029CE:  MOVWF  x80
029D0:  MOVLW  01
029D2:  MOVWF  x81
029D4:  MOVLB  0
029D6:  CALL   1388
....................     
....................    glcd_rect(5, 20, 25, 35, NO, ON);         //Dia    
029DA:  MOVLW  05
029DC:  MOVLB  7
029DE:  MOVWF  x7C
029E0:  MOVLW  14
029E2:  MOVWF  x7D
029E4:  MOVLW  19
029E6:  MOVWF  x7E
029E8:  MOVLW  23
029EA:  MOVWF  x7F
029EC:  CLRF   x80
029EE:  MOVLW  01
029F0:  MOVWF  x81
029F2:  MOVLB  0
029F4:  CALL   10E8
....................    glcd_text57(9, 24, dia, 1, ON); 
029F8:  MOVLW  09
029FA:  MOVLB  7
029FC:  MOVWF  x7C
029FE:  MOVLW  18
02A00:  MOVWF  x7D
02A02:  CLRF   x7F
02A04:  MOVLW  CC
02A06:  MOVWF  x7E
02A08:  MOVLW  01
02A0A:  MOVWF  x80
02A0C:  MOVWF  x81
02A0E:  MOVLB  0
02A10:  CALL   1738
....................     
....................    glcd_rect(35, 20, 55, 35, NO, ON);        //Mes 
02A14:  MOVLW  23
02A16:  MOVLB  7
02A18:  MOVWF  x7C
02A1A:  MOVLW  14
02A1C:  MOVWF  x7D
02A1E:  MOVLW  37
02A20:  MOVWF  x7E
02A22:  MOVLW  23
02A24:  MOVWF  x7F
02A26:  CLRF   x80
02A28:  MOVLW  01
02A2A:  MOVWF  x81
02A2C:  MOVLB  0
02A2E:  CALL   10E8
....................    glcd_text57(39, 24, mes, 1, ON); 
02A32:  MOVLW  27
02A34:  MOVLB  7
02A36:  MOVWF  x7C
02A38:  MOVLW  18
02A3A:  MOVWF  x7D
02A3C:  CLRF   x7F
02A3E:  MOVLW  CF
02A40:  MOVWF  x7E
02A42:  MOVLW  01
02A44:  MOVWF  x80
02A46:  MOVWF  x81
02A48:  MOVLB  0
02A4A:  CALL   1738
....................     
....................    glcd_rect(65, 20, 85, 35, NO, ON);        //Ao 
02A4E:  MOVLW  41
02A50:  MOVLB  7
02A52:  MOVWF  x7C
02A54:  MOVLW  14
02A56:  MOVWF  x7D
02A58:  MOVLW  55
02A5A:  MOVWF  x7E
02A5C:  MOVLW  23
02A5E:  MOVWF  x7F
02A60:  CLRF   x80
02A62:  MOVLW  01
02A64:  MOVWF  x81
02A66:  MOVLB  0
02A68:  CALL   10E8
....................    glcd_text57(69, 24, ao, 1, ON); 
02A6C:  MOVLW  45
02A6E:  MOVLB  7
02A70:  MOVWF  x7C
02A72:  MOVLW  18
02A74:  MOVWF  x7D
02A76:  CLRF   x7F
02A78:  MOVLW  D2
02A7A:  MOVWF  x7E
02A7C:  MOVLW  01
02A7E:  MOVWF  x80
02A80:  MOVWF  x81
02A82:  MOVLB  0
02A84:  CALL   1738
....................     
....................     
....................    glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
02A88:  MOVLW  05
02A8A:  MOVLB  7
02A8C:  MOVWF  x7C
02A8E:  MOVLW  2D
02A90:  MOVWF  x7D
02A92:  MOVLW  19
02A94:  MOVWF  x7E
02A96:  MOVLW  3C
02A98:  MOVWF  x7F
02A9A:  CLRF   x80
02A9C:  MOVLW  01
02A9E:  MOVWF  x81
02AA0:  MOVLB  0
02AA2:  CALL   10E8
....................    glcd_text57(9, 49, hora, 1, ON); 
02AA6:  MOVLW  09
02AA8:  MOVLB  7
02AAA:  MOVWF  x7C
02AAC:  MOVLW  31
02AAE:  MOVWF  x7D
02AB0:  CLRF   x7F
02AB2:  MOVLW  D5
02AB4:  MOVWF  x7E
02AB6:  MOVLW  01
02AB8:  MOVWF  x80
02ABA:  MOVWF  x81
02ABC:  MOVLB  0
02ABE:  CALL   1738
....................     
....................    glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
02AC2:  MOVLW  23
02AC4:  MOVLB  7
02AC6:  MOVWF  x7C
02AC8:  MOVLW  2D
02ACA:  MOVWF  x7D
02ACC:  MOVLW  37
02ACE:  MOVWF  x7E
02AD0:  MOVLW  3C
02AD2:  MOVWF  x7F
02AD4:  CLRF   x80
02AD6:  MOVLW  01
02AD8:  MOVWF  x81
02ADA:  MOVLB  0
02ADC:  CALL   10E8
....................    glcd_text57(39, 49, min, 1, ON); 
02AE0:  MOVLW  27
02AE2:  MOVLB  7
02AE4:  MOVWF  x7C
02AE6:  MOVLW  31
02AE8:  MOVWF  x7D
02AEA:  CLRF   x7F
02AEC:  MOVLW  D8
02AEE:  MOVWF  x7E
02AF0:  MOVLW  01
02AF2:  MOVWF  x80
02AF4:  MOVWF  x81
02AF6:  MOVLB  0
02AF8:  CALL   1738
....................     
....................    glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
02AFC:  MOVLW  41
02AFE:  MOVLB  7
02B00:  MOVWF  x7C
02B02:  MOVLW  2D
02B04:  MOVWF  x7D
02B06:  MOVLW  55
02B08:  MOVWF  x7E
02B0A:  MOVLW  3C
02B0C:  MOVWF  x7F
02B0E:  CLRF   x80
02B10:  MOVLW  01
02B12:  MOVWF  x81
02B14:  MOVLB  0
02B16:  CALL   10E8
....................    glcd_text57(69, 49, aop, 1, ON); 
02B1A:  MOVLW  45
02B1C:  MOVLB  7
02B1E:  MOVWF  x7C
02B20:  MOVLW  31
02B22:  MOVWF  x7D
02B24:  CLRF   x7F
02B26:  MOVLW  DB
02B28:  MOVWF  x7E
02B2A:  MOVLW  01
02B2C:  MOVWF  x80
02B2E:  MOVWF  x81
02B30:  MOVLB  0
02B32:  CALL   1738
....................     
....................     
....................    glcd_update(); 
02B36:  CALL   0D8C
....................     
....................  
....................     
....................    while (1) 
....................    { 
....................       readbuttons(); 
02B3A:  CALL   1D64
....................       if ((right==1)) 
02B3E:  DECFSZ 4D,W
02B40:  BRA    2B50
....................       { 
....................          control+=1; 
02B42:  MOVLW  01
02B44:  ADDWF  3D,F
....................          if (control>=7) 
02B46:  MOVF   3D,W
02B48:  SUBLW  06
02B4A:  BC    2B50
....................          { 
....................             control = 1; 
02B4C:  MOVLW  01
02B4E:  MOVWF  3D
....................          } 
....................       } 
....................       if (left==1) 
02B50:  DECFSZ 4A,W
02B52:  BRA    2B60
....................       { 
....................          control-=1; 
02B54:  MOVLW  01
02B56:  SUBWF  3D,F
....................          if (control<=0) 
02B58:  MOVF   3D,F
02B5A:  BNZ   2B60
....................          { 
....................             control = 6; 
02B5C:  MOVLW  06
02B5E:  MOVWF  3D
....................          } 
....................       } 
....................       if (enter==1) 
02B60:  DECFSZ 48,W
02B62:  BRA    2B68
....................       { 
....................          control = 10; 
02B64:  MOVLW  0A
02B66:  MOVWF  3D
....................       } 
....................           
....................           
....................          switch (control) 
....................          { 
02B68:  MOVLW  01
02B6A:  SUBWF  3D,W
02B6C:  ADDLW  F6
02B6E:  BTFSC  FD8.0
02B70:  GOTO   3706
02B74:  ADDLW  0A
02B76:  GOTO   3718
....................             case 1:           // DIA 
....................             { 
....................                             
....................                glcd_rect(65, 45, 85, 60, YES, OFF);  
02B7A:  MOVLW  41
02B7C:  MOVLB  7
02B7E:  MOVWF  x7C
02B80:  MOVLW  2D
02B82:  MOVWF  x7D
02B84:  MOVLW  55
02B86:  MOVWF  x7E
02B88:  MOVLW  3C
02B8A:  MOVWF  x7F
02B8C:  MOVLW  01
02B8E:  MOVWF  x80
02B90:  CLRF   x81
02B92:  MOVLB  0
02B94:  CALL   10E8
....................                glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
02B98:  MOVLW  41
02B9A:  MOVLB  7
02B9C:  MOVWF  x7C
02B9E:  MOVLW  2D
02BA0:  MOVWF  x7D
02BA2:  MOVLW  55
02BA4:  MOVWF  x7E
02BA6:  MOVLW  3C
02BA8:  MOVWF  x7F
02BAA:  CLRF   x80
02BAC:  MOVLW  01
02BAE:  MOVWF  x81
02BB0:  MOVLB  0
02BB2:  CALL   10E8
....................                glcd_text57(69, 49, aop, 1, ON); 
02BB6:  MOVLW  45
02BB8:  MOVLB  7
02BBA:  MOVWF  x7C
02BBC:  MOVLW  31
02BBE:  MOVWF  x7D
02BC0:  CLRF   x7F
02BC2:  MOVLW  DB
02BC4:  MOVWF  x7E
02BC6:  MOVLW  01
02BC8:  MOVWF  x80
02BCA:  MOVWF  x81
02BCC:  MOVLB  0
02BCE:  CALL   1738
....................                 
....................                glcd_rect(35, 20, 55, 35, YES, OFF);  
02BD2:  MOVLW  23
02BD4:  MOVLB  7
02BD6:  MOVWF  x7C
02BD8:  MOVLW  14
02BDA:  MOVWF  x7D
02BDC:  MOVLW  37
02BDE:  MOVWF  x7E
02BE0:  MOVLW  23
02BE2:  MOVWF  x7F
02BE4:  MOVLW  01
02BE6:  MOVWF  x80
02BE8:  CLRF   x81
02BEA:  MOVLB  0
02BEC:  CALL   10E8
....................                glcd_rect(35, 20, 55, 35, NO, ON);         //Mes         
02BF0:  MOVLW  23
02BF2:  MOVLB  7
02BF4:  MOVWF  x7C
02BF6:  MOVLW  14
02BF8:  MOVWF  x7D
02BFA:  MOVLW  37
02BFC:  MOVWF  x7E
02BFE:  MOVLW  23
02C00:  MOVWF  x7F
02C02:  CLRF   x80
02C04:  MOVLW  01
02C06:  MOVWF  x81
02C08:  MOVLB  0
02C0A:  CALL   10E8
....................                glcd_text57(39, 24, mes, 1, ON); 
02C0E:  MOVLW  27
02C10:  MOVLB  7
02C12:  MOVWF  x7C
02C14:  MOVLW  18
02C16:  MOVWF  x7D
02C18:  CLRF   x7F
02C1A:  MOVLW  CF
02C1C:  MOVWF  x7E
02C1E:  MOVLW  01
02C20:  MOVWF  x80
02C22:  MOVWF  x81
02C24:  MOVLB  0
02C26:  CALL   1738
....................                 
....................                if ((up==0)&&(down==1)) 
02C2A:  MOVF   44,F
02C2C:  BNZ   2CCC
02C2E:  DECFSZ 46,W
02C30:  BRA    2CCC
....................                {   
....................                   int8 auxdia; 
....................                   auxdia = atoi(dia); 
02C32:  MOVLB  7
02C34:  CLRF   x49
02C36:  MOVLW  CC
02C38:  MOVWF  x48
02C3A:  MOVLB  0
02C3C:  RCALL  24E0
02C3E:  MOVFF  01,73E
....................                   auxdia -=1; 
02C42:  MOVLW  01
02C44:  MOVLB  7
02C46:  SUBWF  x3E,F
....................                   if (auxdia==0) 
02C48:  MOVF   x3E,F
02C4A:  BNZ   2C76
....................                   { 
....................                      if (mes=="2") 
02C4C:  MOVLW  00
02C4E:  MOVWF  02
02C50:  MOVLW  0C
02C52:  MOVWF  01
02C54:  MOVLW  76
02C56:  MOVWF  00
02C58:  CLRF   03
02C5A:  MOVF   00,W
02C5C:  SUBLW  CF
02C5E:  BNZ   2C72
02C60:  MOVF   01,F
02C62:  BNZ   2C72
02C64:  MOVF   02,F
02C66:  BNZ   2C72
02C68:  MOVF   03,F
02C6A:  BNZ   2C72
....................                      { 
....................                         auxdia = 28; 
02C6C:  MOVLW  1C
02C6E:  MOVWF  x3E
....................                      } 
....................                      else 
02C70:  BRA    2C76
....................                      { 
....................                         auxdia = 31; 
02C72:  MOVLW  1F
02C74:  MOVWF  x3E
....................                      } 
....................                   } 
....................                   itoa(auxdia,10,dia); 
02C76:  CLRF   x4B
02C78:  CLRF   x4A
02C7A:  CLRF   x49
02C7C:  MOVFF  73E,748
02C80:  MOVLW  0A
02C82:  MOVWF  x4C
02C84:  CLRF   x4E
02C86:  MOVLW  CC
02C88:  MOVWF  x4D
02C8A:  MOVLB  0
02C8C:  RCALL  27CA
....................                   glcd_rect(5, 20, 25, 35, YES, ON);         //Dia 
02C8E:  MOVLW  05
02C90:  MOVLB  7
02C92:  MOVWF  x7C
02C94:  MOVLW  14
02C96:  MOVWF  x7D
02C98:  MOVLW  19
02C9A:  MOVWF  x7E
02C9C:  MOVLW  23
02C9E:  MOVWF  x7F
02CA0:  MOVLW  01
02CA2:  MOVWF  x80
02CA4:  MOVWF  x81
02CA6:  MOVLB  0
02CA8:  CALL   10E8
....................                    
....................                   glcd_text57(9, 24, dia, 1, OFF); 
02CAC:  MOVLW  09
02CAE:  MOVLB  7
02CB0:  MOVWF  x7C
02CB2:  MOVLW  18
02CB4:  MOVWF  x7D
02CB6:  CLRF   x7F
02CB8:  MOVLW  CC
02CBA:  MOVWF  x7E
02CBC:  MOVLW  01
02CBE:  MOVWF  x80
02CC0:  CLRF   x81
02CC2:  MOVLB  0
02CC4:  CALL   1738
....................                   glcd_update(); 
02CC8:  CALL   0D8C
....................                } 
....................                if ((up==1)&&(down==0)) 
02CCC:  DECFSZ 44,W
02CCE:  BRA    2D4A
02CD0:  MOVF   46,F
02CD2:  BNZ   2D4A
....................                { 
....................                   int8 auxdia; 
....................                   auxdia = atoi(dia); 
02CD4:  MOVLB  7
02CD6:  CLRF   x49
02CD8:  MOVLW  CC
02CDA:  MOVWF  x48
02CDC:  MOVLB  0
02CDE:  RCALL  24E0
02CE0:  MOVFF  01,73F
....................                   auxdia +=1; 
02CE4:  MOVLW  01
02CE6:  MOVLB  7
02CE8:  ADDWF  x3F,F
....................                   if (auxdia==32) 
02CEA:  MOVF   x3F,W
02CEC:  SUBLW  20
02CEE:  BNZ   2CF4
....................                   { 
....................                      auxdia = 1; 
02CF0:  MOVLW  01
02CF2:  MOVWF  x3F
....................                   } 
....................                   itoa(auxdia,10,dia); 
02CF4:  CLRF   x4B
02CF6:  CLRF   x4A
02CF8:  CLRF   x49
02CFA:  MOVFF  73F,748
02CFE:  MOVLW  0A
02D00:  MOVWF  x4C
02D02:  CLRF   x4E
02D04:  MOVLW  CC
02D06:  MOVWF  x4D
02D08:  MOVLB  0
02D0A:  RCALL  27CA
....................                   glcd_rect(5, 20, 25, 35, YES, ON);         //Dia 
02D0C:  MOVLW  05
02D0E:  MOVLB  7
02D10:  MOVWF  x7C
02D12:  MOVLW  14
02D14:  MOVWF  x7D
02D16:  MOVLW  19
02D18:  MOVWF  x7E
02D1A:  MOVLW  23
02D1C:  MOVWF  x7F
02D1E:  MOVLW  01
02D20:  MOVWF  x80
02D22:  MOVWF  x81
02D24:  MOVLB  0
02D26:  CALL   10E8
....................                    
....................                   glcd_text57(9, 24, dia, 1, OFF); 
02D2A:  MOVLW  09
02D2C:  MOVLB  7
02D2E:  MOVWF  x7C
02D30:  MOVLW  18
02D32:  MOVWF  x7D
02D34:  CLRF   x7F
02D36:  MOVLW  CC
02D38:  MOVWF  x7E
02D3A:  MOVLW  01
02D3C:  MOVWF  x80
02D3E:  CLRF   x81
02D40:  MOVLB  0
02D42:  CALL   1738
....................                   glcd_update(); 
02D46:  CALL   0D8C
....................           
....................                } 
....................                break; 
02D4A:  GOTO   3706
....................             } 
....................             case 2:           // MES 
....................             { 
....................                glcd_rect(5, 20, 25, 35, YES, OFF);  
02D4E:  MOVLW  05
02D50:  MOVLB  7
02D52:  MOVWF  x7C
02D54:  MOVLW  14
02D56:  MOVWF  x7D
02D58:  MOVLW  19
02D5A:  MOVWF  x7E
02D5C:  MOVLW  23
02D5E:  MOVWF  x7F
02D60:  MOVLW  01
02D62:  MOVWF  x80
02D64:  CLRF   x81
02D66:  MOVLB  0
02D68:  CALL   10E8
....................                glcd_rect(5, 20, 25, 35, NO, ON);         //Dia 
02D6C:  MOVLW  05
02D6E:  MOVLB  7
02D70:  MOVWF  x7C
02D72:  MOVLW  14
02D74:  MOVWF  x7D
02D76:  MOVLW  19
02D78:  MOVWF  x7E
02D7A:  MOVLW  23
02D7C:  MOVWF  x7F
02D7E:  CLRF   x80
02D80:  MOVLW  01
02D82:  MOVWF  x81
02D84:  MOVLB  0
02D86:  CALL   10E8
....................                glcd_text57(9, 24, dia, 1, ON); 
02D8A:  MOVLW  09
02D8C:  MOVLB  7
02D8E:  MOVWF  x7C
02D90:  MOVLW  18
02D92:  MOVWF  x7D
02D94:  CLRF   x7F
02D96:  MOVLW  CC
02D98:  MOVWF  x7E
02D9A:  MOVLW  01
02D9C:  MOVWF  x80
02D9E:  MOVWF  x81
02DA0:  MOVLB  0
02DA2:  CALL   1738
....................                 
....................                glcd_rect(65, 20, 85, 35, YES, OFF);  
02DA6:  MOVLW  41
02DA8:  MOVLB  7
02DAA:  MOVWF  x7C
02DAC:  MOVLW  14
02DAE:  MOVWF  x7D
02DB0:  MOVLW  55
02DB2:  MOVWF  x7E
02DB4:  MOVLW  23
02DB6:  MOVWF  x7F
02DB8:  MOVLW  01
02DBA:  MOVWF  x80
02DBC:  CLRF   x81
02DBE:  MOVLB  0
02DC0:  CALL   10E8
....................                glcd_rect(65, 20, 85, 35, NO, ON);         //Ao 
02DC4:  MOVLW  41
02DC6:  MOVLB  7
02DC8:  MOVWF  x7C
02DCA:  MOVLW  14
02DCC:  MOVWF  x7D
02DCE:  MOVLW  55
02DD0:  MOVWF  x7E
02DD2:  MOVLW  23
02DD4:  MOVWF  x7F
02DD6:  CLRF   x80
02DD8:  MOVLW  01
02DDA:  MOVWF  x81
02DDC:  MOVLB  0
02DDE:  CALL   10E8
....................                glcd_text57(69, 24, ao, 1, ON); 
02DE2:  MOVLW  45
02DE4:  MOVLB  7
02DE6:  MOVWF  x7C
02DE8:  MOVLW  18
02DEA:  MOVWF  x7D
02DEC:  CLRF   x7F
02DEE:  MOVLW  D2
02DF0:  MOVWF  x7E
02DF2:  MOVLW  01
02DF4:  MOVWF  x80
02DF6:  MOVWF  x81
02DF8:  MOVLB  0
02DFA:  CALL   1738
....................                 
....................                if ((up==0)&&(down==1)) 
02DFE:  MOVF   44,F
02E00:  BNZ   2E7C
02E02:  DECFSZ 46,W
02E04:  BRA    2E7C
....................                {   
....................                   int8 auxmes; 
....................                   auxmes = atoi(mes); 
02E06:  MOVLB  7
02E08:  CLRF   x49
02E0A:  MOVLW  CF
02E0C:  MOVWF  x48
02E0E:  MOVLB  0
02E10:  CALL   24E0
02E14:  MOVFF  01,740
....................                   auxmes -=1; 
02E18:  MOVLW  01
02E1A:  MOVLB  7
02E1C:  SUBWF  x40,F
....................                   if (auxmes==0) 
02E1E:  MOVF   x40,F
02E20:  BNZ   2E26
....................                   { 
....................                      auxmes = 12; 
02E22:  MOVLW  0C
02E24:  MOVWF  x40
....................                   } 
....................                   itoa(auxmes,10,mes); 
02E26:  CLRF   x4B
02E28:  CLRF   x4A
02E2A:  CLRF   x49
02E2C:  MOVFF  740,748
02E30:  MOVLW  0A
02E32:  MOVWF  x4C
02E34:  CLRF   x4E
02E36:  MOVLW  CF
02E38:  MOVWF  x4D
02E3A:  MOVLB  0
02E3C:  RCALL  27CA
....................                   glcd_rect(35, 20, 55, 35, YES, ON);         //Mes 
02E3E:  MOVLW  23
02E40:  MOVLB  7
02E42:  MOVWF  x7C
02E44:  MOVLW  14
02E46:  MOVWF  x7D
02E48:  MOVLW  37
02E4A:  MOVWF  x7E
02E4C:  MOVLW  23
02E4E:  MOVWF  x7F
02E50:  MOVLW  01
02E52:  MOVWF  x80
02E54:  MOVWF  x81
02E56:  MOVLB  0
02E58:  CALL   10E8
....................                    
....................                   glcd_text57(39, 24, mes, 1, OFF); 
02E5C:  MOVLW  27
02E5E:  MOVLB  7
02E60:  MOVWF  x7C
02E62:  MOVLW  18
02E64:  MOVWF  x7D
02E66:  CLRF   x7F
02E68:  MOVLW  CF
02E6A:  MOVWF  x7E
02E6C:  MOVLW  01
02E6E:  MOVWF  x80
02E70:  CLRF   x81
02E72:  MOVLB  0
02E74:  CALL   1738
....................                   glcd_update(); 
02E78:  CALL   0D8C
....................                } 
....................                if ((up==1)&&(down==0)) 
02E7C:  DECFSZ 44,W
02E7E:  BRA    2EFC
02E80:  MOVF   46,F
02E82:  BNZ   2EFC
....................                { 
....................                   int8 auxmes; 
....................                   auxmes = atoi(mes); 
02E84:  MOVLB  7
02E86:  CLRF   x49
02E88:  MOVLW  CF
02E8A:  MOVWF  x48
02E8C:  MOVLB  0
02E8E:  CALL   24E0
02E92:  MOVFF  01,741
....................                   auxmes +=1; 
02E96:  MOVLW  01
02E98:  MOVLB  7
02E9A:  ADDWF  x41,F
....................                   if (auxmes==13) 
02E9C:  MOVF   x41,W
02E9E:  SUBLW  0D
02EA0:  BNZ   2EA6
....................                   { 
....................                      auxmes = 1; 
02EA2:  MOVLW  01
02EA4:  MOVWF  x41
....................                   } 
....................                   itoa(auxmes,10,mes); 
02EA6:  CLRF   x4B
02EA8:  CLRF   x4A
02EAA:  CLRF   x49
02EAC:  MOVFF  741,748
02EB0:  MOVLW  0A
02EB2:  MOVWF  x4C
02EB4:  CLRF   x4E
02EB6:  MOVLW  CF
02EB8:  MOVWF  x4D
02EBA:  MOVLB  0
02EBC:  RCALL  27CA
....................                   glcd_rect(35, 20, 55, 35, YES, ON);         //Mes 
02EBE:  MOVLW  23
02EC0:  MOVLB  7
02EC2:  MOVWF  x7C
02EC4:  MOVLW  14
02EC6:  MOVWF  x7D
02EC8:  MOVLW  37
02ECA:  MOVWF  x7E
02ECC:  MOVLW  23
02ECE:  MOVWF  x7F
02ED0:  MOVLW  01
02ED2:  MOVWF  x80
02ED4:  MOVWF  x81
02ED6:  MOVLB  0
02ED8:  CALL   10E8
....................                    
....................                   glcd_text57(39, 24, mes, 1, OFF); 
02EDC:  MOVLW  27
02EDE:  MOVLB  7
02EE0:  MOVWF  x7C
02EE2:  MOVLW  18
02EE4:  MOVWF  x7D
02EE6:  CLRF   x7F
02EE8:  MOVLW  CF
02EEA:  MOVWF  x7E
02EEC:  MOVLW  01
02EEE:  MOVWF  x80
02EF0:  CLRF   x81
02EF2:  MOVLB  0
02EF4:  CALL   1738
....................                   glcd_update(); 
02EF8:  CALL   0D8C
....................           
....................                } 
....................                break; 
02EFC:  GOTO   3706
....................             } 
....................             case 3:           // AO 
....................             { 
....................                 
....................                glcd_rect(35, 20, 55, 35, YES, OFF);  
02F00:  MOVLW  23
02F02:  MOVLB  7
02F04:  MOVWF  x7C
02F06:  MOVLW  14
02F08:  MOVWF  x7D
02F0A:  MOVLW  37
02F0C:  MOVWF  x7E
02F0E:  MOVLW  23
02F10:  MOVWF  x7F
02F12:  MOVLW  01
02F14:  MOVWF  x80
02F16:  CLRF   x81
02F18:  MOVLB  0
02F1A:  CALL   10E8
....................                glcd_rect(35, 20, 55, 35, NO, ON);         //Mes          
02F1E:  MOVLW  23
02F20:  MOVLB  7
02F22:  MOVWF  x7C
02F24:  MOVLW  14
02F26:  MOVWF  x7D
02F28:  MOVLW  37
02F2A:  MOVWF  x7E
02F2C:  MOVLW  23
02F2E:  MOVWF  x7F
02F30:  CLRF   x80
02F32:  MOVLW  01
02F34:  MOVWF  x81
02F36:  MOVLB  0
02F38:  CALL   10E8
....................                glcd_text57(39, 24, mes, 1, ON); 
02F3C:  MOVLW  27
02F3E:  MOVLB  7
02F40:  MOVWF  x7C
02F42:  MOVLW  18
02F44:  MOVWF  x7D
02F46:  CLRF   x7F
02F48:  MOVLW  CF
02F4A:  MOVWF  x7E
02F4C:  MOVLW  01
02F4E:  MOVWF  x80
02F50:  MOVWF  x81
02F52:  MOVLB  0
02F54:  CALL   1738
....................                 
....................                glcd_rect(5, 45, 25, 60, YES, OFF);  
02F58:  MOVLW  05
02F5A:  MOVLB  7
02F5C:  MOVWF  x7C
02F5E:  MOVLW  2D
02F60:  MOVWF  x7D
02F62:  MOVLW  19
02F64:  MOVWF  x7E
02F66:  MOVLW  3C
02F68:  MOVWF  x7F
02F6A:  MOVLW  01
02F6C:  MOVWF  x80
02F6E:  CLRF   x81
02F70:  MOVLB  0
02F72:  CALL   10E8
....................                glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
02F76:  MOVLW  05
02F78:  MOVLB  7
02F7A:  MOVWF  x7C
02F7C:  MOVLW  2D
02F7E:  MOVWF  x7D
02F80:  MOVLW  19
02F82:  MOVWF  x7E
02F84:  MOVLW  3C
02F86:  MOVWF  x7F
02F88:  CLRF   x80
02F8A:  MOVLW  01
02F8C:  MOVWF  x81
02F8E:  MOVLB  0
02F90:  CALL   10E8
....................                glcd_text57(9, 49, hora, 1, ON); 
02F94:  MOVLW  09
02F96:  MOVLB  7
02F98:  MOVWF  x7C
02F9A:  MOVLW  31
02F9C:  MOVWF  x7D
02F9E:  CLRF   x7F
02FA0:  MOVLW  D5
02FA2:  MOVWF  x7E
02FA4:  MOVLW  01
02FA6:  MOVWF  x80
02FA8:  MOVWF  x81
02FAA:  MOVLB  0
02FAC:  CALL   1738
....................                 
....................                if ((up==0)&&(down==1)) 
02FB0:  MOVF   44,F
02FB2:  BNZ   3030
02FB4:  DECFSZ 46,W
02FB6:  BRA    3030
....................                {   
....................                   int8 auxao; 
....................                   auxao = atoi(ao); 
02FB8:  MOVLB  7
02FBA:  CLRF   x49
02FBC:  MOVLW  D2
02FBE:  MOVWF  x48
02FC0:  MOVLB  0
02FC2:  CALL   24E0
02FC6:  MOVFF  01,742
....................                   auxao -=1; 
02FCA:  MOVLW  01
02FCC:  MOVLB  7
02FCE:  SUBWF  x42,F
....................                   if (auxao==0) 
02FD0:  MOVF   x42,F
02FD2:  BNZ   2FD8
....................                   { 
....................                      auxao = 99; 
02FD4:  MOVLW  63
02FD6:  MOVWF  x42
....................                   } 
....................                   itoa(auxao,10,ao); 
02FD8:  CLRF   x4B
02FDA:  CLRF   x4A
02FDC:  CLRF   x49
02FDE:  MOVFF  742,748
02FE2:  MOVLW  0A
02FE4:  MOVWF  x4C
02FE6:  CLRF   x4E
02FE8:  MOVLW  D2
02FEA:  MOVWF  x4D
02FEC:  MOVLB  0
02FEE:  CALL   27CA
....................                   glcd_rect(65, 20, 85, 35, YES, ON);         //Ao 
02FF2:  MOVLW  41
02FF4:  MOVLB  7
02FF6:  MOVWF  x7C
02FF8:  MOVLW  14
02FFA:  MOVWF  x7D
02FFC:  MOVLW  55
02FFE:  MOVWF  x7E
03000:  MOVLW  23
03002:  MOVWF  x7F
03004:  MOVLW  01
03006:  MOVWF  x80
03008:  MOVWF  x81
0300A:  MOVLB  0
0300C:  CALL   10E8
....................                    
....................                   glcd_text57(69, 24, ao, 1, OFF); 
03010:  MOVLW  45
03012:  MOVLB  7
03014:  MOVWF  x7C
03016:  MOVLW  18
03018:  MOVWF  x7D
0301A:  CLRF   x7F
0301C:  MOVLW  D2
0301E:  MOVWF  x7E
03020:  MOVLW  01
03022:  MOVWF  x80
03024:  CLRF   x81
03026:  MOVLB  0
03028:  CALL   1738
....................                   glcd_update(); 
0302C:  CALL   0D8C
....................                } 
....................                if ((up==1)&&(down==0)) 
03030:  DECFSZ 44,W
03032:  BRA    30B0
03034:  MOVF   46,F
03036:  BNZ   30B0
....................                { 
....................                   int8 auxao; 
....................                   auxao = atoi(ao); 
03038:  MOVLB  7
0303A:  CLRF   x49
0303C:  MOVLW  D2
0303E:  MOVWF  x48
03040:  MOVLB  0
03042:  CALL   24E0
03046:  MOVFF  01,743
....................                   auxao +=1; 
0304A:  MOVLW  01
0304C:  MOVLB  7
0304E:  ADDWF  x43,F
....................                   if (auxao==99) 
03050:  MOVF   x43,W
03052:  SUBLW  63
03054:  BNZ   3058
....................                   { 
....................                      auxao = 0; 
03056:  CLRF   x43
....................                   } 
....................                   itoa(auxao,10,ao); 
03058:  CLRF   x4B
0305A:  CLRF   x4A
0305C:  CLRF   x49
0305E:  MOVFF  743,748
03062:  MOVLW  0A
03064:  MOVWF  x4C
03066:  CLRF   x4E
03068:  MOVLW  D2
0306A:  MOVWF  x4D
0306C:  MOVLB  0
0306E:  CALL   27CA
....................                   glcd_rect(65, 20, 85, 35, YES, ON);         //Ao 
03072:  MOVLW  41
03074:  MOVLB  7
03076:  MOVWF  x7C
03078:  MOVLW  14
0307A:  MOVWF  x7D
0307C:  MOVLW  55
0307E:  MOVWF  x7E
03080:  MOVLW  23
03082:  MOVWF  x7F
03084:  MOVLW  01
03086:  MOVWF  x80
03088:  MOVWF  x81
0308A:  MOVLB  0
0308C:  CALL   10E8
....................                    
....................                   glcd_text57(69, 24, ao, 1, OFF); 
03090:  MOVLW  45
03092:  MOVLB  7
03094:  MOVWF  x7C
03096:  MOVLW  18
03098:  MOVWF  x7D
0309A:  CLRF   x7F
0309C:  MOVLW  D2
0309E:  MOVWF  x7E
030A0:  MOVLW  01
030A2:  MOVWF  x80
030A4:  CLRF   x81
030A6:  MOVLB  0
030A8:  CALL   1738
....................                   glcd_update(); 
030AC:  CALL   0D8C
....................           
....................                } 
....................                break; 
030B0:  BRA    3706
....................             } 
....................             case 4:           // HORA 
....................             { 
....................                 
....................                glcd_rect(65, 20, 85, 35, YES, OFF);  
030B2:  MOVLW  41
030B4:  MOVLB  7
030B6:  MOVWF  x7C
030B8:  MOVLW  14
030BA:  MOVWF  x7D
030BC:  MOVLW  55
030BE:  MOVWF  x7E
030C0:  MOVLW  23
030C2:  MOVWF  x7F
030C4:  MOVLW  01
030C6:  MOVWF  x80
030C8:  CLRF   x81
030CA:  MOVLB  0
030CC:  CALL   10E8
....................                glcd_rect(65, 20, 85, 35, NO, ON);         //Ao 
030D0:  MOVLW  41
030D2:  MOVLB  7
030D4:  MOVWF  x7C
030D6:  MOVLW  14
030D8:  MOVWF  x7D
030DA:  MOVLW  55
030DC:  MOVWF  x7E
030DE:  MOVLW  23
030E0:  MOVWF  x7F
030E2:  CLRF   x80
030E4:  MOVLW  01
030E6:  MOVWF  x81
030E8:  MOVLB  0
030EA:  CALL   10E8
....................                glcd_text57(69, 24, ao, 1, ON); 
030EE:  MOVLW  45
030F0:  MOVLB  7
030F2:  MOVWF  x7C
030F4:  MOVLW  18
030F6:  MOVWF  x7D
030F8:  CLRF   x7F
030FA:  MOVLW  D2
030FC:  MOVWF  x7E
030FE:  MOVLW  01
03100:  MOVWF  x80
03102:  MOVWF  x81
03104:  MOVLB  0
03106:  CALL   1738
....................                 
....................                glcd_rect(35, 45, 55, 60, YES, OFF);  
0310A:  MOVLW  23
0310C:  MOVLB  7
0310E:  MOVWF  x7C
03110:  MOVLW  2D
03112:  MOVWF  x7D
03114:  MOVLW  37
03116:  MOVWF  x7E
03118:  MOVLW  3C
0311A:  MOVWF  x7F
0311C:  MOVLW  01
0311E:  MOVWF  x80
03120:  CLRF   x81
03122:  MOVLB  0
03124:  CALL   10E8
....................                glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
03128:  MOVLW  23
0312A:  MOVLB  7
0312C:  MOVWF  x7C
0312E:  MOVLW  2D
03130:  MOVWF  x7D
03132:  MOVLW  37
03134:  MOVWF  x7E
03136:  MOVLW  3C
03138:  MOVWF  x7F
0313A:  CLRF   x80
0313C:  MOVLW  01
0313E:  MOVWF  x81
03140:  MOVLB  0
03142:  CALL   10E8
....................                glcd_text57(39, 49, min, 1, ON); 
03146:  MOVLW  27
03148:  MOVLB  7
0314A:  MOVWF  x7C
0314C:  MOVLW  31
0314E:  MOVWF  x7D
03150:  CLRF   x7F
03152:  MOVLW  D8
03154:  MOVWF  x7E
03156:  MOVLW  01
03158:  MOVWF  x80
0315A:  MOVWF  x81
0315C:  MOVLB  0
0315E:  CALL   1738
....................                 
....................                 
....................                if ((up==0)&&(down==1)) 
03162:  MOVF   44,F
03164:  BNZ   31E2
03166:  DECFSZ 46,W
03168:  BRA    31E2
....................                {   
....................                   int8 auxhora; 
....................                   auxhora = atoi(hora); 
0316A:  MOVLB  7
0316C:  CLRF   x49
0316E:  MOVLW  D5
03170:  MOVWF  x48
03172:  MOVLB  0
03174:  CALL   24E0
03178:  MOVFF  01,744
....................                   auxhora -=1; 
0317C:  MOVLW  01
0317E:  MOVLB  7
03180:  SUBWF  x44,F
....................                   if (auxhora<=0) 
03182:  MOVF   x44,F
03184:  BNZ   318A
....................                   { 
....................                      auxhora = 12; 
03186:  MOVLW  0C
03188:  MOVWF  x44
....................                   } 
....................                   itoa(auxhora,10,hora); 
0318A:  CLRF   x4B
0318C:  CLRF   x4A
0318E:  CLRF   x49
03190:  MOVFF  744,748
03194:  MOVLW  0A
03196:  MOVWF  x4C
03198:  CLRF   x4E
0319A:  MOVLW  D5
0319C:  MOVWF  x4D
0319E:  MOVLB  0
031A0:  CALL   27CA
....................                    
....................                   glcd_rect(5, 45, 25, 60, YES, ON);         //Hora 
031A4:  MOVLW  05
031A6:  MOVLB  7
031A8:  MOVWF  x7C
031AA:  MOVLW  2D
031AC:  MOVWF  x7D
031AE:  MOVLW  19
031B0:  MOVWF  x7E
031B2:  MOVLW  3C
031B4:  MOVWF  x7F
031B6:  MOVLW  01
031B8:  MOVWF  x80
031BA:  MOVWF  x81
031BC:  MOVLB  0
031BE:  CALL   10E8
....................                    
....................                   glcd_text57(9, 49, hora, 1, OFF); 
031C2:  MOVLW  09
031C4:  MOVLB  7
031C6:  MOVWF  x7C
031C8:  MOVLW  31
031CA:  MOVWF  x7D
031CC:  CLRF   x7F
031CE:  MOVLW  D5
031D0:  MOVWF  x7E
031D2:  MOVLW  01
031D4:  MOVWF  x80
031D6:  CLRF   x81
031D8:  MOVLB  0
031DA:  CALL   1738
....................                   glcd_update(); 
031DE:  CALL   0D8C
....................                } 
....................                if ((up==1)&&(down==0)) 
031E2:  DECFSZ 44,W
031E4:  BRA    3264
031E6:  MOVF   46,F
031E8:  BNZ   3264
....................                { 
....................                   int8 auxhora; 
....................                   auxhora = atoi(hora); 
031EA:  MOVLB  7
031EC:  CLRF   x49
031EE:  MOVLW  D5
031F0:  MOVWF  x48
031F2:  MOVLB  0
031F4:  CALL   24E0
031F8:  MOVFF  01,745
....................                   auxhora +=1; 
031FC:  MOVLW  01
031FE:  MOVLB  7
03200:  ADDWF  x45,F
....................                   if (auxhora>=12) 
03202:  MOVF   x45,W
03204:  SUBLW  0B
03206:  BC    320C
....................                   { 
....................                      auxhora = 1; 
03208:  MOVLW  01
0320A:  MOVWF  x45
....................                   } 
....................                   itoa(auxhora,10,hora); 
0320C:  CLRF   x4B
0320E:  CLRF   x4A
03210:  CLRF   x49
03212:  MOVFF  745,748
03216:  MOVLW  0A
03218:  MOVWF  x4C
0321A:  CLRF   x4E
0321C:  MOVLW  D5
0321E:  MOVWF  x4D
03220:  MOVLB  0
03222:  CALL   27CA
....................                   glcd_rect(5, 45, 25, 60, YES, ON);         //Hora 
03226:  MOVLW  05
03228:  MOVLB  7
0322A:  MOVWF  x7C
0322C:  MOVLW  2D
0322E:  MOVWF  x7D
03230:  MOVLW  19
03232:  MOVWF  x7E
03234:  MOVLW  3C
03236:  MOVWF  x7F
03238:  MOVLW  01
0323A:  MOVWF  x80
0323C:  MOVWF  x81
0323E:  MOVLB  0
03240:  CALL   10E8
....................                    
....................                   glcd_text57(9, 49, hora, 1, OFF); 
03244:  MOVLW  09
03246:  MOVLB  7
03248:  MOVWF  x7C
0324A:  MOVLW  31
0324C:  MOVWF  x7D
0324E:  CLRF   x7F
03250:  MOVLW  D5
03252:  MOVWF  x7E
03254:  MOVLW  01
03256:  MOVWF  x80
03258:  CLRF   x81
0325A:  MOVLB  0
0325C:  CALL   1738
....................                   glcd_update(); 
03260:  CALL   0D8C
....................           
....................                }   
....................                 
....................                break; 
03264:  BRA    3706
....................             } 
....................             case 5:           // MINUTOS 
....................             { 
....................                glcd_rect(5, 45, 25, 60, YES, OFF);  
03266:  MOVLW  05
03268:  MOVLB  7
0326A:  MOVWF  x7C
0326C:  MOVLW  2D
0326E:  MOVWF  x7D
03270:  MOVLW  19
03272:  MOVWF  x7E
03274:  MOVLW  3C
03276:  MOVWF  x7F
03278:  MOVLW  01
0327A:  MOVWF  x80
0327C:  CLRF   x81
0327E:  MOVLB  0
03280:  CALL   10E8
....................                glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
03284:  MOVLW  05
03286:  MOVLB  7
03288:  MOVWF  x7C
0328A:  MOVLW  2D
0328C:  MOVWF  x7D
0328E:  MOVLW  19
03290:  MOVWF  x7E
03292:  MOVLW  3C
03294:  MOVWF  x7F
03296:  CLRF   x80
03298:  MOVLW  01
0329A:  MOVWF  x81
0329C:  MOVLB  0
0329E:  CALL   10E8
....................                glcd_text57(9, 49, hora, 1, ON); 
032A2:  MOVLW  09
032A4:  MOVLB  7
032A6:  MOVWF  x7C
032A8:  MOVLW  31
032AA:  MOVWF  x7D
032AC:  CLRF   x7F
032AE:  MOVLW  D5
032B0:  MOVWF  x7E
032B2:  MOVLW  01
032B4:  MOVWF  x80
032B6:  MOVWF  x81
032B8:  MOVLB  0
032BA:  CALL   1738
....................                 
....................                glcd_rect(65, 45, 85, 60, YES, OFF);  
032BE:  MOVLW  41
032C0:  MOVLB  7
032C2:  MOVWF  x7C
032C4:  MOVLW  2D
032C6:  MOVWF  x7D
032C8:  MOVLW  55
032CA:  MOVWF  x7E
032CC:  MOVLW  3C
032CE:  MOVWF  x7F
032D0:  MOVLW  01
032D2:  MOVWF  x80
032D4:  CLRF   x81
032D6:  MOVLB  0
032D8:  CALL   10E8
....................                glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
032DC:  MOVLW  41
032DE:  MOVLB  7
032E0:  MOVWF  x7C
032E2:  MOVLW  2D
032E4:  MOVWF  x7D
032E6:  MOVLW  55
032E8:  MOVWF  x7E
032EA:  MOVLW  3C
032EC:  MOVWF  x7F
032EE:  CLRF   x80
032F0:  MOVLW  01
032F2:  MOVWF  x81
032F4:  MOVLB  0
032F6:  CALL   10E8
....................                glcd_text57(69, 49, aop, 1, ON); 
032FA:  MOVLW  45
032FC:  MOVLB  7
032FE:  MOVWF  x7C
03300:  MOVLW  31
03302:  MOVWF  x7D
03304:  CLRF   x7F
03306:  MOVLW  DB
03308:  MOVWF  x7E
0330A:  MOVLW  01
0330C:  MOVWF  x80
0330E:  MOVWF  x81
03310:  MOVLB  0
03312:  CALL   1738
....................                                      
....................                 
....................     
....................                if ((up==0)&&(down==1)) 
03316:  MOVF   44,F
03318:  BNZ   3396
0331A:  DECFSZ 46,W
0331C:  BRA    3396
....................                {   
....................                   int8 auxmin; 
....................                   auxmin = atoi(min); 
0331E:  MOVLB  7
03320:  CLRF   x49
03322:  MOVLW  D8
03324:  MOVWF  x48
03326:  MOVLB  0
03328:  CALL   24E0
0332C:  MOVFF  01,746
....................                    
....................                   if (auxmin==0) 
03330:  MOVLB  7
03332:  MOVF   x46,F
03334:  BNZ   333A
....................                   { 
....................                      auxmin = 60; 
03336:  MOVLW  3C
03338:  MOVWF  x46
....................                   } 
....................                   auxmin -=1; 
0333A:  MOVLW  01
0333C:  SUBWF  x46,F
....................                   itoa(auxmin,10,min); 
0333E:  CLRF   x4B
03340:  CLRF   x4A
03342:  CLRF   x49
03344:  MOVFF  746,748
03348:  MOVLW  0A
0334A:  MOVWF  x4C
0334C:  CLRF   x4E
0334E:  MOVLW  D8
03350:  MOVWF  x4D
03352:  MOVLB  0
03354:  CALL   27CA
....................                    
....................                   glcd_rect(35, 45, 55, 60, YES, ON);        //Minuto 
03358:  MOVLW  23
0335A:  MOVLB  7
0335C:  MOVWF  x7C
0335E:  MOVLW  2D
03360:  MOVWF  x7D
03362:  MOVLW  37
03364:  MOVWF  x7E
03366:  MOVLW  3C
03368:  MOVWF  x7F
0336A:  MOVLW  01
0336C:  MOVWF  x80
0336E:  MOVWF  x81
03370:  MOVLB  0
03372:  CALL   10E8
....................                   glcd_text57(39, 49, min, 1, OFF); 
03376:  MOVLW  27
03378:  MOVLB  7
0337A:  MOVWF  x7C
0337C:  MOVLW  31
0337E:  MOVWF  x7D
03380:  CLRF   x7F
03382:  MOVLW  D8
03384:  MOVWF  x7E
03386:  MOVLW  01
03388:  MOVWF  x80
0338A:  CLRF   x81
0338C:  MOVLB  0
0338E:  CALL   1738
....................                   glcd_update(); 
03392:  CALL   0D8C
....................                } 
....................                if ((up==1)&&(down==0)) 
03396:  DECFSZ 44,W
03398:  BRA    3416
0339A:  MOVF   46,F
0339C:  BNZ   3416
....................                { 
....................                   int8 auxmin; 
....................                   auxmin = atoi(min); 
0339E:  MOVLB  7
033A0:  CLRF   x49
033A2:  MOVLW  D8
033A4:  MOVWF  x48
033A6:  MOVLB  0
033A8:  CALL   24E0
033AC:  MOVFF  01,747
....................                   auxmin +=1; 
033B0:  MOVLW  01
033B2:  MOVLB  7
033B4:  ADDWF  x47,F
....................                   if (auxmin>=60) 
033B6:  MOVF   x47,W
033B8:  SUBLW  3B
033BA:  BC    33BE
....................                   { 
....................                      auxmin = 0; 
033BC:  CLRF   x47
....................                   } 
....................                   itoa(auxmin,10,min); 
033BE:  CLRF   x4B
033C0:  CLRF   x4A
033C2:  CLRF   x49
033C4:  MOVFF  747,748
033C8:  MOVLW  0A
033CA:  MOVWF  x4C
033CC:  CLRF   x4E
033CE:  MOVLW  D8
033D0:  MOVWF  x4D
033D2:  MOVLB  0
033D4:  CALL   27CA
....................                    
....................                   glcd_rect(35, 45, 55, 60, YES, ON);        //Minuto 
033D8:  MOVLW  23
033DA:  MOVLB  7
033DC:  MOVWF  x7C
033DE:  MOVLW  2D
033E0:  MOVWF  x7D
033E2:  MOVLW  37
033E4:  MOVWF  x7E
033E6:  MOVLW  3C
033E8:  MOVWF  x7F
033EA:  MOVLW  01
033EC:  MOVWF  x80
033EE:  MOVWF  x81
033F0:  MOVLB  0
033F2:  CALL   10E8
....................                   glcd_text57(39, 49, min, 1, OFF); 
033F6:  MOVLW  27
033F8:  MOVLB  7
033FA:  MOVWF  x7C
033FC:  MOVLW  31
033FE:  MOVWF  x7D
03400:  CLRF   x7F
03402:  MOVLW  D8
03404:  MOVWF  x7E
03406:  MOVLW  01
03408:  MOVWF  x80
0340A:  CLRF   x81
0340C:  MOVLB  0
0340E:  CALL   1738
....................                   glcd_update(); 
03412:  CALL   0D8C
....................           
....................                } 
....................                break; 
03416:  BRA    3706
....................             } 
....................             case 6:           // AM - PM                          
....................             { 
....................                 
....................                glcd_rect(35, 45, 55, 60, YES, OFF);  
03418:  MOVLW  23
0341A:  MOVLB  7
0341C:  MOVWF  x7C
0341E:  MOVLW  2D
03420:  MOVWF  x7D
03422:  MOVLW  37
03424:  MOVWF  x7E
03426:  MOVLW  3C
03428:  MOVWF  x7F
0342A:  MOVLW  01
0342C:  MOVWF  x80
0342E:  CLRF   x81
03430:  MOVLB  0
03432:  CALL   10E8
....................                glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
03436:  MOVLW  23
03438:  MOVLB  7
0343A:  MOVWF  x7C
0343C:  MOVLW  2D
0343E:  MOVWF  x7D
03440:  MOVLW  37
03442:  MOVWF  x7E
03444:  MOVLW  3C
03446:  MOVWF  x7F
03448:  CLRF   x80
0344A:  MOVLW  01
0344C:  MOVWF  x81
0344E:  MOVLB  0
03450:  CALL   10E8
....................                glcd_text57(39, 49, min, 1, ON); 
03454:  MOVLW  27
03456:  MOVLB  7
03458:  MOVWF  x7C
0345A:  MOVLW  31
0345C:  MOVWF  x7D
0345E:  CLRF   x7F
03460:  MOVLW  D8
03462:  MOVWF  x7E
03464:  MOVLW  01
03466:  MOVWF  x80
03468:  MOVWF  x81
0346A:  MOVLB  0
0346C:  CALL   1738
....................                 
....................                glcd_rect(5, 20, 25, 35, YES, OFF);  
03470:  MOVLW  05
03472:  MOVLB  7
03474:  MOVWF  x7C
03476:  MOVLW  14
03478:  MOVWF  x7D
0347A:  MOVLW  19
0347C:  MOVWF  x7E
0347E:  MOVLW  23
03480:  MOVWF  x7F
03482:  MOVLW  01
03484:  MOVWF  x80
03486:  CLRF   x81
03488:  MOVLB  0
0348A:  CALL   10E8
....................                glcd_rect(5, 20, 25, 35, NO, ON);         //Dia 
0348E:  MOVLW  05
03490:  MOVLB  7
03492:  MOVWF  x7C
03494:  MOVLW  14
03496:  MOVWF  x7D
03498:  MOVLW  19
0349A:  MOVWF  x7E
0349C:  MOVLW  23
0349E:  MOVWF  x7F
034A0:  CLRF   x80
034A2:  MOVLW  01
034A4:  MOVWF  x81
034A6:  MOVLB  0
034A8:  CALL   10E8
....................                glcd_text57(9, 24, dia, 1, ON); 
034AC:  MOVLW  09
034AE:  MOVLB  7
034B0:  MOVWF  x7C
034B2:  MOVLW  18
034B4:  MOVWF  x7D
034B6:  CLRF   x7F
034B8:  MOVLW  CC
034BA:  MOVWF  x7E
034BC:  MOVLW  01
034BE:  MOVWF  x80
034C0:  MOVWF  x81
034C2:  MOVLB  0
034C4:  CALL   1738
....................                 
....................                 
....................                 
....................                 
....................                 
....................                if ((up==1)||(down==1)) 
034C8:  DECFSZ 44,W
034CA:  BRA    34CE
034CC:  BRA    34D2
034CE:  DECFSZ 46,W
034D0:  BRA    3562
....................                { 
....................                   if (aop=="AM") 
034D2:  MOVLW  00
034D4:  MOVWF  02
034D6:  MOVLW  08
034D8:  MOVWF  01
034DA:  MOVLW  50
034DC:  MOVWF  00
034DE:  CLRF   03
034E0:  MOVF   00,W
034E2:  SUBLW  DB
034E4:  BNZ   350C
034E6:  MOVF   01,F
034E8:  BNZ   350C
034EA:  MOVF   02,F
034EC:  BNZ   350C
034EE:  MOVF   03,F
034F0:  BNZ   350C
....................                   { 
....................                      aop = "PM"; 
034F2:  CLRF   FEA
034F4:  MOVLW  DB
034F6:  MOVWF  FE9
034F8:  MOVLW  00
034FA:  CALL   0854
034FE:  TBLRD*-
03500:  TBLRD*+
03502:  MOVF   FF5,W
03504:  MOVWF  FEE
03506:  IORLW  00
03508:  BNZ   3500
....................                   } 
....................                   else 
0350A:  BRA    3524
....................                   { 
....................                      aop="AM"; 
0350C:  CLRF   FEA
0350E:  MOVLW  DB
03510:  MOVWF  FE9
03512:  MOVLW  00
03514:  CALL   0840
03518:  TBLRD*-
0351A:  TBLRD*+
0351C:  MOVF   FF5,W
0351E:  MOVWF  FEE
03520:  IORLW  00
03522:  BNZ   351A
....................                   } 
....................                   glcd_rect(65, 45, 85, 60, YES, ON);        //Minuto 
03524:  MOVLW  41
03526:  MOVLB  7
03528:  MOVWF  x7C
0352A:  MOVLW  2D
0352C:  MOVWF  x7D
0352E:  MOVLW  55
03530:  MOVWF  x7E
03532:  MOVLW  3C
03534:  MOVWF  x7F
03536:  MOVLW  01
03538:  MOVWF  x80
0353A:  MOVWF  x81
0353C:  MOVLB  0
0353E:  CALL   10E8
....................                   glcd_text57(69, 49, aop, 1, OFF); 
03542:  MOVLW  45
03544:  MOVLB  7
03546:  MOVWF  x7C
03548:  MOVLW  31
0354A:  MOVWF  x7D
0354C:  CLRF   x7F
0354E:  MOVLW  DB
03550:  MOVWF  x7E
03552:  MOVLW  01
03554:  MOVWF  x80
03556:  CLRF   x81
03558:  MOVLB  0
0355A:  CALL   1738
....................                   glcd_update(); 
0355E:  CALL   0D8C
....................           
....................                } 
....................                 
....................                break;                                                     
03562:  BRA    3706
....................             } 
....................             case 10:          // SET                         
....................             { 
....................                glcd_fillscreen(OFF); 
03564:  MOVLB  7
03566:  CLRF   x48
03568:  MOVLB  0
0356A:  CALL   0D32
....................                glcd_text57(0, 0, MENU1, 1, ON); 
0356E:  MOVLB  7
03570:  CLRF   x7C
03572:  CLRF   x7D
03574:  CLRF   x7F
03576:  MOVLW  5C
03578:  MOVWF  x7E
0357A:  MOVLW  01
0357C:  MOVWF  x80
0357E:  MOVWF  x81
03580:  MOVLB  0
03582:  CALL   1738
....................                glcd_bar(0, 9, 127, 9, 2, ON); //div 
03586:  MOVLB  7
03588:  CLRF   x7C
0358A:  MOVLW  09
0358C:  MOVWF  x7D
0358E:  MOVLW  7F
03590:  MOVWF  x7E
03592:  MOVLW  09
03594:  MOVWF  x7F
03596:  MOVLW  02
03598:  MOVWF  x80
0359A:  MOVLW  01
0359C:  MOVWF  x81
0359E:  MOVLB  0
035A0:  CALL   1388
....................                 
....................                glcd_rect(5, 20, 25, 35, NO, ON);         //Dia     
035A4:  MOVLW  05
035A6:  MOVLB  7
035A8:  MOVWF  x7C
035AA:  MOVLW  14
035AC:  MOVWF  x7D
035AE:  MOVLW  19
035B0:  MOVWF  x7E
035B2:  MOVLW  23
035B4:  MOVWF  x7F
035B6:  CLRF   x80
035B8:  MOVLW  01
035BA:  MOVWF  x81
035BC:  MOVLB  0
035BE:  CALL   10E8
....................                glcd_text57(9, 24, dia, 1, ON); 
035C2:  MOVLW  09
035C4:  MOVLB  7
035C6:  MOVWF  x7C
035C8:  MOVLW  18
035CA:  MOVWF  x7D
035CC:  CLRF   x7F
035CE:  MOVLW  CC
035D0:  MOVWF  x7E
035D2:  MOVLW  01
035D4:  MOVWF  x80
035D6:  MOVWF  x81
035D8:  MOVLB  0
035DA:  CALL   1738
....................                 
....................                glcd_rect(35, 20, 55, 35, NO, ON);        //Mes 
035DE:  MOVLW  23
035E0:  MOVLB  7
035E2:  MOVWF  x7C
035E4:  MOVLW  14
035E6:  MOVWF  x7D
035E8:  MOVLW  37
035EA:  MOVWF  x7E
035EC:  MOVLW  23
035EE:  MOVWF  x7F
035F0:  CLRF   x80
035F2:  MOVLW  01
035F4:  MOVWF  x81
035F6:  MOVLB  0
035F8:  CALL   10E8
....................                glcd_text57(39, 24, mes, 1, ON); 
035FC:  MOVLW  27
035FE:  MOVLB  7
03600:  MOVWF  x7C
03602:  MOVLW  18
03604:  MOVWF  x7D
03606:  CLRF   x7F
03608:  MOVLW  CF
0360A:  MOVWF  x7E
0360C:  MOVLW  01
0360E:  MOVWF  x80
03610:  MOVWF  x81
03612:  MOVLB  0
03614:  CALL   1738
....................                 
....................                glcd_rect(65, 20, 85, 35, NO, ON);        //Ao 
03618:  MOVLW  41
0361A:  MOVLB  7
0361C:  MOVWF  x7C
0361E:  MOVLW  14
03620:  MOVWF  x7D
03622:  MOVLW  55
03624:  MOVWF  x7E
03626:  MOVLW  23
03628:  MOVWF  x7F
0362A:  CLRF   x80
0362C:  MOVLW  01
0362E:  MOVWF  x81
03630:  MOVLB  0
03632:  CALL   10E8
....................                glcd_text57(69, 24, ao, 1, ON); 
03636:  MOVLW  45
03638:  MOVLB  7
0363A:  MOVWF  x7C
0363C:  MOVLW  18
0363E:  MOVWF  x7D
03640:  CLRF   x7F
03642:  MOVLW  D2
03644:  MOVWF  x7E
03646:  MOVLW  01
03648:  MOVWF  x80
0364A:  MOVWF  x81
0364C:  MOVLB  0
0364E:  CALL   1738
....................                 
....................                 
....................                glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
03652:  MOVLW  05
03654:  MOVLB  7
03656:  MOVWF  x7C
03658:  MOVLW  2D
0365A:  MOVWF  x7D
0365C:  MOVLW  19
0365E:  MOVWF  x7E
03660:  MOVLW  3C
03662:  MOVWF  x7F
03664:  CLRF   x80
03666:  MOVLW  01
03668:  MOVWF  x81
0366A:  MOVLB  0
0366C:  CALL   10E8
....................                glcd_text57(9, 49, hora, 1, ON); 
03670:  MOVLW  09
03672:  MOVLB  7
03674:  MOVWF  x7C
03676:  MOVLW  31
03678:  MOVWF  x7D
0367A:  CLRF   x7F
0367C:  MOVLW  D5
0367E:  MOVWF  x7E
03680:  MOVLW  01
03682:  MOVWF  x80
03684:  MOVWF  x81
03686:  MOVLB  0
03688:  CALL   1738
....................                 
....................                glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
0368C:  MOVLW  23
0368E:  MOVLB  7
03690:  MOVWF  x7C
03692:  MOVLW  2D
03694:  MOVWF  x7D
03696:  MOVLW  37
03698:  MOVWF  x7E
0369A:  MOVLW  3C
0369C:  MOVWF  x7F
0369E:  CLRF   x80
036A0:  MOVLW  01
036A2:  MOVWF  x81
036A4:  MOVLB  0
036A6:  CALL   10E8
....................                glcd_text57(39, 49, min, 1, ON); 
036AA:  MOVLW  27
036AC:  MOVLB  7
036AE:  MOVWF  x7C
036B0:  MOVLW  31
036B2:  MOVWF  x7D
036B4:  CLRF   x7F
036B6:  MOVLW  D8
036B8:  MOVWF  x7E
036BA:  MOVLW  01
036BC:  MOVWF  x80
036BE:  MOVWF  x81
036C0:  MOVLB  0
036C2:  CALL   1738
....................                 
....................                glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
036C6:  MOVLW  41
036C8:  MOVLB  7
036CA:  MOVWF  x7C
036CC:  MOVLW  2D
036CE:  MOVWF  x7D
036D0:  MOVLW  55
036D2:  MOVWF  x7E
036D4:  MOVLW  3C
036D6:  MOVWF  x7F
036D8:  CLRF   x80
036DA:  MOVLW  01
036DC:  MOVWF  x81
036DE:  MOVLB  0
036E0:  CALL   10E8
....................                glcd_text57(69, 49, aop, 1, ON); 
036E4:  MOVLW  45
036E6:  MOVLB  7
036E8:  MOVWF  x7C
036EA:  MOVLW  31
036EC:  MOVWF  x7D
036EE:  CLRF   x7F
036F0:  MOVLW  DB
036F2:  MOVWF  x7E
036F4:  MOVLW  01
036F6:  MOVWF  x80
036F8:  MOVWF  x81
036FA:  MOVLB  0
036FC:  CALL   1738
....................                 
....................                glcd_update(); 
03700:  CALL   0D8C
....................                 
....................                break;                                                     
03704:  BRA    3706
....................             } 
....................                                                                          
....................          } 
....................        
....................        
....................                                                                           
....................       pressed = 0; 
03706:  CLRF   3E
....................       if (control==10) 
03708:  MOVF   3D,W
0370A:  SUBLW  0A
0370C:  BNZ   3710
....................       { 
....................          return; 
0370E:  BRA    3714
....................       } 
....................  
....................    } 
03710:  GOTO   2B3A
.................... } 
03714:  GOTO   375E (RETURN)
....................  
....................  
.................... void menu_drawmain(void) 
.................... { 
....................    glcd_fillScreen(OFF); 
*
01C3A:  MOVLB  7
01C3C:  CLRF   x48
01C3E:  MOVLB  0
01C40:  CALL   0D32
....................    glcd_text57(0, 0, MENUTITLE, 1, ON); 
01C44:  MOVLB  7
01C46:  CLRF   x7C
01C48:  CLRF   x7D
01C4A:  CLRF   x7F
01C4C:  MOVLW  4E
01C4E:  MOVWF  x7E
01C50:  MOVLW  01
01C52:  MOVWF  x80
01C54:  MOVWF  x81
01C56:  MOVLB  0
01C58:  RCALL  1738
....................    glcd_bar(0, 9, 127, 9, 2, ON); //div 
01C5A:  MOVLB  7
01C5C:  CLRF   x7C
01C5E:  MOVLW  09
01C60:  MOVWF  x7D
01C62:  MOVLW  7F
01C64:  MOVWF  x7E
01C66:  MOVLW  09
01C68:  MOVWF  x7F
01C6A:  MOVLW  02
01C6C:  MOVWF  x80
01C6E:  MOVLW  01
01C70:  MOVWF  x81
01C72:  MOVLB  0
01C74:  CALL   1388
....................    glcd_text57(0, 14, MENU1, 1, ON); 
01C78:  MOVLB  7
01C7A:  CLRF   x7C
01C7C:  MOVLW  0E
01C7E:  MOVWF  x7D
01C80:  CLRF   x7F
01C82:  MOVLW  5C
01C84:  MOVWF  x7E
01C86:  MOVLW  01
01C88:  MOVWF  x80
01C8A:  MOVWF  x81
01C8C:  MOVLB  0
01C8E:  RCALL  1738
....................    menu_entrar(14,ON); 
01C90:  MOVLW  0E
01C92:  MOVLB  7
01C94:  MOVWF  x40
01C96:  MOVLW  01
01C98:  MOVWF  x41
01C9A:  MOVLB  0
01C9C:  RCALL  1BA6
....................    glcd_text57(0, 23, MENU2, 1, ON); 
01C9E:  MOVLB  7
01CA0:  CLRF   x7C
01CA2:  MOVLW  17
01CA4:  MOVWF  x7D
01CA6:  CLRF   x7F
01CA8:  MOVLW  6A
01CAA:  MOVWF  x7E
01CAC:  MOVLW  01
01CAE:  MOVWF  x80
01CB0:  MOVWF  x81
01CB2:  MOVLB  0
01CB4:  RCALL  1738
....................    glcd_text57(100, 23, UniTemp, 1, ON); 
01CB6:  MOVLW  64
01CB8:  MOVLB  7
01CBA:  MOVWF  x7C
01CBC:  MOVLW  17
01CBE:  MOVWF  x7D
01CC0:  CLRF   x7F
01CC2:  MOVLW  DE
01CC4:  MOVWF  x7E
01CC6:  MOVLW  01
01CC8:  MOVWF  x80
01CCA:  MOVWF  x81
01CCC:  MOVLB  0
01CCE:  RCALL  1738
....................    menu_entrar(23,ON); 
01CD0:  MOVLW  17
01CD2:  MOVLB  7
01CD4:  MOVWF  x40
01CD6:  MOVLW  01
01CD8:  MOVWF  x41
01CDA:  MOVLB  0
01CDC:  RCALL  1BA6
....................    glcd_text57(0, 32, MENU3, 1, ON); 
01CDE:  MOVLB  7
01CE0:  CLRF   x7C
01CE2:  MOVLW  20
01CE4:  MOVWF  x7D
01CE6:  CLRF   x7F
01CE8:  MOVLW  90
01CEA:  MOVWF  x7E
01CEC:  MOVLW  01
01CEE:  MOVWF  x80
01CF0:  MOVWF  x81
01CF2:  MOVLB  0
01CF4:  RCALL  1738
....................    glcd_text57(100, 32, UniPres, 1, ON); 
01CF6:  MOVLW  64
01CF8:  MOVLB  7
01CFA:  MOVWF  x7C
01CFC:  MOVLW  20
01CFE:  MOVWF  x7D
01D00:  CLRF   x7F
01D02:  MOVLW  E1
01D04:  MOVWF  x7E
01D06:  MOVLW  01
01D08:  MOVWF  x80
01D0A:  MOVWF  x81
01D0C:  MOVLB  0
01D0E:  RCALL  1738
....................    menu_entrar(32,ON); 
01D10:  MOVLW  20
01D12:  MOVLB  7
01D14:  MOVWF  x40
01D16:  MOVLW  01
01D18:  MOVWF  x41
01D1A:  MOVLB  0
01D1C:  RCALL  1BA6
....................    glcd_text57(0, 41, MENU4, 1, ON); 
01D1E:  MOVLB  7
01D20:  CLRF   x7C
01D22:  MOVLW  29
01D24:  MOVWF  x7D
01D26:  CLRF   x7F
01D28:  MOVLW  AC
01D2A:  MOVWF  x7E
01D2C:  MOVLW  01
01D2E:  MOVWF  x80
01D30:  MOVWF  x81
01D32:  MOVLB  0
01D34:  RCALL  1738
....................    glcd_text57(100, 41, UniVel, 1, ON); 
01D36:  MOVLW  64
01D38:  MOVLB  7
01D3A:  MOVWF  x7C
01D3C:  MOVLW  29
01D3E:  MOVWF  x7D
01D40:  CLRF   x7F
01D42:  MOVLW  E5
01D44:  MOVWF  x7E
01D46:  MOVLW  01
01D48:  MOVWF  x80
01D4A:  MOVWF  x81
01D4C:  MOVLB  0
01D4E:  RCALL  1738
....................    menu_entrar(41,ON); 
01D50:  MOVLW  29
01D52:  MOVLB  7
01D54:  MOVWF  x40
01D56:  MOVLW  01
01D58:  MOVWF  x41
01D5A:  MOVLB  0
01D5C:  RCALL  1BA6
....................    glcd_update(); 
01D5E:  CALL   0D8C
.................... } 
01D62:  RETLW  00
....................  
.................... #include "show.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           Show.c                                //// 
.................... ////                                                                 //// 
.................... //// Ester archivo contiene las funciones para implementar la        //// 
.................... //// impresion de imagenes en una pantalla lcd grafica de            //// 
.................... //// 128x64 con controlador KS0108                            //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "../imagenes.c" 
.................... unsigned char const logo[1024] = { 
....................    0,  0,  0,  0,  0,  0,  0,128,192,192,224,240,248,248,252,254,  
....................  255,127, 63, 31,  7,131,129, 64, 64, 96, 32, 16, 16,  8,  8,  4,  
....................    6,  2,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,129,193,113, 25, 15,  0,  0,  0,  0,  0,  
....................  224,240,248,252,254,255,255,255,255,127, 63, 31, 15,  7,  3,129,  
....................  225, 56,140,131,129,192,192, 64, 96, 96, 32, 32, 48, 48, 16, 16,  
....................   16, 24, 24, 24,  8,  8,136,200,200,236,252,252,248,248,248,248,  
....................  248,252,252,252,232,200,136,  8,  8,  8,  8,  8,  8,  8,  8,  8,  
....................    8,  8, 24, 24, 24, 24, 24, 16, 16, 16,144,144,208,240,240,240,  
....................  240,240,248,248,248,248,248,248,248,248,240,112, 32,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,128,128,192,192, 96, 96,  
....................   48, 48, 16, 24, 12, 14,  3,  1,  0,  0,  0,  0,  0,  0,  0,  0,  
....................  255,255,255, 63, 31, 15,  3,  1,  0,  0,  0,  0,  0,  0,  3,  3,  
....................    3,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,240,252,254,255,127, 63, 31, 15, 15, 15, 15, 63,255,255,  
....................  255,255,255,255,255,255,255,255,252,240,192,  0,  0,  0,  0,  0,  
....................    0,128,192,224,240,248,248,252,254,255,255,255,255,255,255,191,  
....................  191, 31, 31, 31, 63, 63, 63, 31, 15,135,129,192,192, 96, 96, 32,  
....................   48, 16, 24,  8, 12, 12,  6,  6,  3,  3,  1,  1,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    7,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  1,  1,  1, 80,240,240,240,240,224,224,224,224,224,195,  
....................  207,255,255,255,255,255,255,255,255,255,255,255,252,248,252,254,  
....................  255,255,255,127, 63, 31, 15,  7,131,129,192,192,224, 97,113, 51,  
....................   55, 31, 31, 14, 14, 14, 30,  3,  3,  1,  1,  0,  0,128,192,192,  
....................   96, 32, 32,160,224,224,224,224,  0,  0,  0,  0,  0,  0,128,192,  
....................   64, 96, 96, 96, 96,224,224,224, 96, 96, 96, 32, 32, 48, 24,  8,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,128,128,128,192,192,224, 96,112, 48,  
....................  176,152,233,247,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,222, 14, 14, 30, 31, 31, 31, 29, 61, 60, 60, 60, 60, 60,  
....................   56,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  3,131,224,  
....................  112,124, 46, 35, 33,127,255,255,224,  0,  0,  0,  2,  7,  7,  0,  
....................    0,  0,  0,224,254,255, 63,  1,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,128,128,192,192,224,224,240,240,248,248,  
....................  248,252,255,255,127, 63,159,223,207,231,243,251,249,252,254,255,  
....................  127,127, 31, 31, 15,  7,  3,  3, 15, 63,255,255,255,255,255,255,  
....................  255,255,255,255,252,240,192,  0,  0,  0,  0,  0,  0,  0,  0,128,  
....................  192,224,224,224,  0,  0,  2,  3,  6,  6,  6,  6,  2,  3,  1,  0,  
....................    0,  0,  0,  0,  0,  0,  7,  7,  7,  6,  2,  0,  0,  0,  0,  2,  
....................    6,  6,  7,  7,  7,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,128,128,192,192,224,224,224,240,240,248,248,252,  
....................  252,254,254,255,255,255,255,255,135, 48,125,249,247,247,247,243,  
....................  249,253,252,126,126, 63,191,191,223,223,143,143,135,131,129,128,  
....................  128,128,128,128,128,128,128,  0,  0,  0,  0,  3, 15, 31,127,255,  
....................  255,255,255,255,255,255,255,255,254,252,252,252,254,254,127, 63,  
....................   31, 15,  7,  3,  0,128,128,128,128,128,128,128,192,192,192,192,  
....................  192,192,224,224,224,224,240,240,240,240,248,248,248,252,252,254,  
....................  254,254,127, 63,  7,  0,  0,  0,  0,128,192,192,224,240,248,254,  
....................  254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,254,254,254,254,254,  
....................  254,254,254,254,254,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  127,127, 63, 63, 63, 31, 31, 31, 15, 15,  7,  7,  3,  3,  1,  1,  
....................    0,  0,128,224,240,248,252,254,255,127, 63, 63, 31, 15,  7,  7  
.................... }; 
....................  
.................... unsigned char sun[] = { 
....................    31,31,   0,  0,  0,128,  0,  0,  0,  0,  0,  0,  0,  0, 12, 30, 56,240,  
....................  240,224,  0,  0,  0,  0,  0,  0,192,224, 96, 32,  0,  0,  0,   
....................    0,  0,  6, 15, 46, 28, 28, 60, 60, 56,224,120,220,252,252,255,  
....................  223,221,252,188,250,242,238, 14,  7,  7,  0,  0,  0,  0,  0,  
....................    0,  8, 24, 48, 56, 60, 28, 28,120, 24,159,191,255,121,255,239,  
....................  239,239,247,251,191, 63, 31,  2,  7,  7, 15,  7,  1,  3,  6,  
....................    0,  0,  0,  0,  0,  0,  0,  0, 48,124, 15, 15, 15,  7,  0,  
....................    0,  0,  3,  7, 15, 14,  6, 30, 28,  0,  0,  0,  0,  0,  0,  
.................... }; 
....................  
.................... unsigned char cloud[] = { 
....................  
.................... 31,31, 0,192,224, 32, 48, 16, 16, 48, 24, 24,120,112, 80,216,  8,  8,  
....................    8, 24, 24, 16, 48, 96,224,128,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  1,  1, 15,  8, 56,248, 24, 24,  8, 15,  3,193,224, 96,  
....................   32,112, 16, 16, 16, 56, 24, 11, 15, 56,112, 64,192,128,  0,  0,  
....................    0,124,198,134,130,130,135,  1,  7, 12,  8, 24, 16, 49, 39, 38,  
....................   36, 60, 32,224,224,224,192,192, 64, 96, 60,  4,  4,  7,  0,  0,  
....................    0,  0,  0,  0,  0,  3, 15,  8, 24, 16, 16, 16, 48, 32, 32, 32,  
....................   32, 48, 16, 29,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
.................... }; 
....................  
.................... unsigned char rain[] = { 
....................  
.................... 31,31, 0,  0,192, 96, 48, 16,  8, 12,  4,  4, 12,  8, 12,  4,  6,  2,  
....................    2,  2,  2,  2,  6, 12, 24, 16, 48, 96,192,128,128,  0,  0,  
....................    0, 31,241,128,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  3,254,  0,  
....................    0,  0,  0,  1, 67, 34, 50,  2, 50, 26,  3,199, 76,  8,  8,  8,  
....................   68,100,  6,  3,198,  4, 22,  2, 34,162,130,  3,  1,  1,  0,  
....................    0,  0, 12,  2, 16, 24,  0,  3,  0,  8, 12,  4,  0,  0,  3,  9,  
....................    0, 12,  0,  0, 12,  0,  3, 24,  8,  1,  0,  0,  0,  0,  0 
.................... }; 
....................  
.................... unsigned char snow[] = { 
.................... 31,31, 0,192,224, 96, 32, 32, 32,120, 12, 12, 12,  8, 12, 12, 24, 28,  
....................    4,  6,  2,  2,  2, 30, 28,240,224,192,128,128,128,  0,  0,  
....................    0, 15, 24, 48, 32, 32, 32,224,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,224,160, 96, 96, 51, 31,  0,  
....................    0, 56,108, 68,104,240,  0,199,108, 40, 40, 72,152, 24, 56, 48,  
....................   32, 32, 32, 32, 48, 16, 24,140,199,  1,  0,  0,128,  0,  0,  
....................    0,  0, 14, 10, 14,  0,  3,  7,  4,  4,  4,  6,  3,  0, 14,  6,  
....................    0, 31, 17, 17, 27, 14,  0,  3,  1,  0,  0, 59, 51,  0,  0,  
.................... }; 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_text_sec(char sec, char line, char* textptr, int1 color); 
.................... void draw_sect(char sector = 0); 
.................... void glcd_shownub(); 
.................... void glcd_showsun(); 
.................... void glcd_showlogo(); 
.................... void glcd_loadscreen(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... void glcd_showlogo()  
.................... {  
*
01ACA:  MOVLB  7
01ACC:  CLRF   x3E
01ACE:  CLRF   x3D
01AD0:  BCF    x41.0
....................   int16 n=0;  
....................   int i,j;  
....................   int1 cs=0;  
....................    // Loop through the vertical pages  
....................    for(i = 0; i <8; ++i)  
01AD2:  CLRF   x3F
01AD4:  MOVF   x3F,W
01AD6:  SUBLW  07
01AD8:  BNC   1B74
....................    {  
....................       output_low(GLCD_DI);                      // Set for instruction  
01ADA:  BCF    F93.2
01ADC:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0  
01ADE:  CLRF   x83
01AE0:  MOVLW  40
01AE2:  MOVWF  x84
01AE4:  MOVLB  0
01AE6:  CALL   0CF2
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000);  
01AEA:  MOVLW  01
01AEC:  MOVLB  7
01AEE:  MOVWF  x83
01AF0:  MOVLW  40
01AF2:  MOVWF  x84
01AF4:  MOVLB  0
01AF6:  CALL   0CF2
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address  
01AFA:  MOVLB  7
01AFC:  MOVF   x3F,W
01AFE:  IORLW  B8
01B00:  MOVWF  x42
01B02:  CLRF   x83
01B04:  MOVWF  x84
01B06:  MOVLB  0
01B08:  CALL   0CF2
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000);  
01B0C:  MOVLB  7
01B0E:  MOVF   x3F,W
01B10:  IORLW  B8
01B12:  MOVWF  x42
01B14:  MOVLW  01
01B16:  MOVWF  x83
01B18:  MOVFF  742,784
01B1C:  MOVLB  0
01B1E:  CALL   0CF2
....................       output_high(GLCD_DI);                     // Set for data  
01B22:  BCF    F93.2
01B24:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections  
....................       for(j = 0; j < 128;++j)  
01B26:  MOVLB  7
01B28:  CLRF   x40
01B2A:  MOVF   x40,W
01B2C:  SUBLW  7F
01B2E:  BNC   1B70
....................       {  
....................          if(j<64) cs=GLCD_LEFT;else cs=GLCD_RIGHT;  
01B30:  MOVF   x40,W
01B32:  SUBLW  3F
01B34:  BNC   1B3A
01B36:  BCF    x41.0
01B38:  BRA    1B3C
01B3A:  BSF    x41.0
....................          glcd_writeByte(cs,logo[n]);  // Turn pixels on or off  
01B3C:  MOVLW  00
01B3E:  BTFSC  x41.0
01B40:  MOVLW  01
01B42:  MOVWF  x42
01B44:  MOVFF  73E,03
01B48:  MOVF   x3D,W
01B4A:  MOVFF  73E,FF7
01B4E:  MOVLB  0
01B50:  CALL   0868
01B54:  MOVLB  7
01B56:  MOVWF  x43
01B58:  MOVFF  742,783
01B5C:  MOVWF  x84
01B5E:  MOVLB  0
01B60:  CALL   0CF2
....................          //delay_us(5);  
....................         n++;  
01B64:  MOVLB  7
01B66:  INCF   x3D,F
01B68:  BTFSC  FD8.2
01B6A:  INCF   x3E,F
....................       }  
01B6C:  INCF   x40,F
01B6E:  BRA    1B2A
....................    }  
01B70:  INCF   x3F,F
01B72:  BRA    1AD4
....................    i = 0; 
01B74:  CLRF   x3F
.................... }     
01B76:  MOVLB  0
01B78:  GOTO   4CA8 (RETURN)
....................  
.................... void glcd_showweather_xy(char *weather,int x, int y, int1 inverse) 
.................... { 
....................  
....................    unsigned int i, j, k; 
....................    unsigned int16 count=2; 
....................    int width  = weather[0]; 
....................          int height = weather[1]; 
....................          if(inverse) 
....................          { 
....................             for(i=0;i<height;i+=8) 
....................             {    
....................                for(j=0;j<width;j++) 
....................                { 
....................                   for(k=0;k<8;k++) 
....................                   {  
....................                      if(~bit_test(weather[count],k)) 
....................                      { 
....................                         glcd_pixel(x+j,y+i+k,ON); 
....................                      } 
....................                   } 
....................                   count++; 
....................                } 
....................             } 
....................          } 
....................          else 
....................          { 
....................             for(i=0;i<height;i+=8) 
....................             {    
....................                for(j=0;j<width;j++) 
....................                { 
....................                   for(k=0;k<8;k++) 
....................                   {  
....................                      if(bit_test(weather[count],k)) 
....................                      { 
....................                         glcd_pixel(x+j,y+i+k,ON); 
....................                      } 
....................                   } 
....................                   count++; 
....................                } 
....................             } 
....................          } 
....................    //glcd_fillScreen(OFF);                        //Clears the screen (opt.) 
....................     
.................... }  
....................  
....................  
....................  
.................... void glcd_loadscreen() 
.................... { 
....................    int g; 
....................    for (g=0;g<63;g++) 
*
018E2:  MOVLB  7
018E4:  CLRF   x3D
018E6:  MOVF   x3D,W
018E8:  SUBLW  3E
018EA:  BTFSS  FD8.0
018EC:  BRA    19EE
....................    {   
....................     
....................       char h,k; 
....................       h = (2*g); 
018EE:  BCF    FD8.0
018F0:  RLCF   x3D,W
018F2:  MOVWF  x3E
....................       k = (2*g)+1; 
018F4:  BCF    FD8.0
018F6:  RLCF   x3D,W
018F8:  ADDLW  01
018FA:  MOVWF  x3F
....................        
....................       char l[] = "Iniciando X-Weather"; 
018FC:  MOVLW  49
018FE:  MOVWF  x40
01900:  MOVLW  6E
01902:  MOVWF  x41
01904:  MOVLW  69
01906:  MOVWF  x42
01908:  MOVLW  63
0190A:  MOVWF  x43
0190C:  MOVLW  69
0190E:  MOVWF  x44
01910:  MOVLW  61
01912:  MOVWF  x45
01914:  MOVLW  6E
01916:  MOVWF  x46
01918:  MOVLW  64
0191A:  MOVWF  x47
0191C:  MOVLW  6F
0191E:  MOVWF  x48
01920:  MOVLW  20
01922:  MOVWF  x49
01924:  MOVLW  58
01926:  MOVWF  x4A
01928:  MOVLW  2D
0192A:  MOVWF  x4B
0192C:  MOVLW  57
0192E:  MOVWF  x4C
01930:  MOVLW  65
01932:  MOVWF  x4D
01934:  MOVLW  61
01936:  MOVWF  x4E
01938:  MOVLW  74
0193A:  MOVWF  x4F
0193C:  MOVLW  68
0193E:  MOVWF  x50
01940:  MOVLW  65
01942:  MOVWF  x51
01944:  MOVLW  72
01946:  MOVWF  x52
01948:  CLRF   x53
....................        
....................        char n[] = "Iniciando Sensores"; 
0194A:  MOVLW  49
0194C:  MOVWF  x54
0194E:  MOVLW  6E
01950:  MOVWF  x55
01952:  MOVLW  69
01954:  MOVWF  x56
01956:  MOVLW  63
01958:  MOVWF  x57
0195A:  MOVLW  69
0195C:  MOVWF  x58
0195E:  MOVLW  61
01960:  MOVWF  x59
01962:  MOVLW  6E
01964:  MOVWF  x5A
01966:  MOVLW  64
01968:  MOVWF  x5B
0196A:  MOVLW  6F
0196C:  MOVWF  x5C
0196E:  MOVLW  20
01970:  MOVWF  x5D
01972:  MOVLW  53
01974:  MOVWF  x5E
01976:  MOVLW  65
01978:  MOVWF  x5F
0197A:  MOVLW  6E
0197C:  MOVWF  x60
0197E:  MOVLW  73
01980:  MOVWF  x61
01982:  MOVLW  6F
01984:  MOVWF  x62
01986:  MOVLW  72
01988:  MOVWF  x63
0198A:  MOVLW  65
0198C:  MOVWF  x64
0198E:  MOVLW  73
01990:  MOVWF  x65
01992:  CLRF   x66
....................       glcd_bar(h, 5, h, 15, 1, ON); 
01994:  MOVFF  73E,77C
01998:  MOVLW  05
0199A:  MOVWF  x7D
0199C:  MOVFF  73E,77E
019A0:  MOVLW  0F
019A2:  MOVWF  x7F
019A4:  MOVLW  01
019A6:  MOVWF  x80
019A8:  MOVWF  x81
019AA:  MOVLB  0
019AC:  RCALL  1388
....................       glcd_bar(k, 5, k, 15, 1, ON); 
019AE:  MOVFF  73F,77C
019B2:  MOVLW  05
019B4:  MOVLB  7
019B6:  MOVWF  x7D
019B8:  MOVFF  73F,77E
019BC:  MOVLW  0F
019BE:  MOVWF  x7F
019C0:  MOVLW  01
019C2:  MOVWF  x80
019C4:  MOVWF  x81
019C6:  MOVLB  0
019C8:  RCALL  1388
....................       glcd_text57(5, 7, l, 1, OFF) ; 
019CA:  MOVLW  05
019CC:  MOVLB  7
019CE:  MOVWF  x7C
019D0:  MOVLW  07
019D2:  MOVWF  x7D
019D4:  MOVWF  x7F
019D6:  MOVLW  40
019D8:  MOVWF  x7E
019DA:  MOVLW  01
019DC:  MOVWF  x80
019DE:  CLRF   x81
019E0:  MOVLB  0
019E2:  RCALL  1738
....................        
....................        
....................        
....................       glcd_update(); 
019E4:  CALL   0D8C
....................        
....................        
....................    } 
019E8:  MOVLB  7
019EA:  INCF   x3D,F
019EC:  BRA    18E6
....................    glcd_rect(0,6,127,15,YES,ON); 
019EE:  CLRF   x7C
019F0:  MOVLW  06
019F2:  MOVWF  x7D
019F4:  MOVLW  7F
019F6:  MOVWF  x7E
019F8:  MOVLW  0F
019FA:  MOVWF  x7F
019FC:  MOVLW  01
019FE:  MOVWF  x80
01A00:  MOVWF  x81
01A02:  MOVLB  0
01A04:  CALL   10E8
....................    for (g=0;g<63;g++) 
01A08:  MOVLB  7
01A0A:  CLRF   x3D
01A0C:  MOVF   x3D,W
01A0E:  SUBLW  3E
01A10:  BNC   1AC4
....................    {   
....................     
....................       char h,k; 
....................       h = (2*g); 
01A12:  BCF    FD8.0
01A14:  RLCF   x3D,W
01A16:  MOVWF  x67
....................       k = (2*g)+1; 
01A18:  BCF    FD8.0
01A1A:  RLCF   x3D,W
01A1C:  ADDLW  01
01A1E:  MOVWF  x68
....................        
....................        
....................        
....................        char n[] = "Iniciando Sensores"; 
01A20:  MOVLW  49
01A22:  MOVWF  x69
01A24:  MOVLW  6E
01A26:  MOVWF  x6A
01A28:  MOVLW  69
01A2A:  MOVWF  x6B
01A2C:  MOVLW  63
01A2E:  MOVWF  x6C
01A30:  MOVLW  69
01A32:  MOVWF  x6D
01A34:  MOVLW  61
01A36:  MOVWF  x6E
01A38:  MOVLW  6E
01A3A:  MOVWF  x6F
01A3C:  MOVLW  64
01A3E:  MOVWF  x70
01A40:  MOVLW  6F
01A42:  MOVWF  x71
01A44:  MOVLW  20
01A46:  MOVWF  x72
01A48:  MOVLW  53
01A4A:  MOVWF  x73
01A4C:  MOVLW  65
01A4E:  MOVWF  x74
01A50:  MOVLW  6E
01A52:  MOVWF  x75
01A54:  MOVLW  73
01A56:  MOVWF  x76
01A58:  MOVLW  6F
01A5A:  MOVWF  x77
01A5C:  MOVLW  72
01A5E:  MOVWF  x78
01A60:  MOVLW  65
01A62:  MOVWF  x79
01A64:  MOVLW  73
01A66:  MOVWF  x7A
01A68:  CLRF   x7B
....................         
....................       glcd_bar(h, 5, h, 15, 1, OFF); 
01A6A:  MOVFF  767,77C
01A6E:  MOVLW  05
01A70:  MOVWF  x7D
01A72:  MOVFF  767,77E
01A76:  MOVLW  0F
01A78:  MOVWF  x7F
01A7A:  MOVLW  01
01A7C:  MOVWF  x80
01A7E:  CLRF   x81
01A80:  MOVLB  0
01A82:  RCALL  1388
....................       glcd_bar(k, 5, k, 15, 1, OFF); 
01A84:  MOVFF  768,77C
01A88:  MOVLW  05
01A8A:  MOVLB  7
01A8C:  MOVWF  x7D
01A8E:  MOVFF  768,77E
01A92:  MOVLW  0F
01A94:  MOVWF  x7F
01A96:  MOVLW  01
01A98:  MOVWF  x80
01A9A:  CLRF   x81
01A9C:  MOVLB  0
01A9E:  RCALL  1388
....................       glcd_text57(5, 7, n, 1, ON) ; 
01AA0:  MOVLW  05
01AA2:  MOVLB  7
01AA4:  MOVWF  x7C
01AA6:  MOVLW  07
01AA8:  MOVWF  x7D
01AAA:  MOVWF  x7F
01AAC:  MOVLW  69
01AAE:  MOVWF  x7E
01AB0:  MOVLW  01
01AB2:  MOVWF  x80
01AB4:  MOVWF  x81
01AB6:  MOVLB  0
01AB8:  RCALL  1738
....................        
....................        
....................        
....................       glcd_update(); 
01ABA:  CALL   0D8C
....................        
....................        
....................    } 
01ABE:  MOVLB  7
01AC0:  INCF   x3D,F
01AC2:  BRA    1A0C
....................  
.................... } 
01AC4:  MOVLB  0
01AC6:  GOTO   4CA4 (RETURN)
....................     
....................  
....................  
....................  
.................... void draw_sect(char sector) 
.................... { 
....................    switch (sector) 
....................    { 
*
011AA:  MOVLB  7
011AC:  MOVF   x3D,W
011AE:  ADDLW  FB
011B0:  BTFSC  FD8.0
011B2:  BRA    130C
011B4:  ADDLW  05
011B6:  MOVLB  0
011B8:  GOTO   1310
....................       case 1:        //Sec1 
....................       { 
....................          glcd_rect(0, 0, 62, 30, YES, ON);    
011BC:  MOVLB  7
011BE:  CLRF   x7C
011C0:  CLRF   x7D
011C2:  MOVLW  3E
011C4:  MOVWF  x7E
011C6:  MOVLW  1E
011C8:  MOVWF  x7F
011CA:  MOVLW  01
011CC:  MOVWF  x80
011CE:  MOVWF  x81
011D0:  MOVLB  0
011D2:  RCALL  10E8
....................          glcd_rect(0, 0, 62, 30, NO, OFF); 
011D4:  MOVLB  7
011D6:  CLRF   x7C
011D8:  CLRF   x7D
011DA:  MOVLW  3E
011DC:  MOVWF  x7E
011DE:  MOVLW  1E
011E0:  MOVWF  x7F
011E2:  CLRF   x80
011E4:  CLRF   x81
011E6:  MOVLB  0
011E8:  RCALL  10E8
....................          break; 
011EA:  MOVLB  7
011EC:  BRA    130C
011EE:  MOVLB  0
....................       } 
....................       case 2:        //Sec2 
....................       { 
....................          glcd_rect(63, 0, 127, 30, NO, ON); 
011F0:  MOVLW  3F
011F2:  MOVLB  7
011F4:  MOVWF  x7C
011F6:  CLRF   x7D
011F8:  MOVLW  7F
011FA:  MOVWF  x7E
011FC:  MOVLW  1E
011FE:  MOVWF  x7F
01200:  CLRF   x80
01202:  MOVLW  01
01204:  MOVWF  x81
01206:  MOVLB  0
01208:  RCALL  10E8
....................          break; 
0120A:  MOVLB  7
0120C:  BRA    130C
0120E:  MOVLB  0
....................       } 
....................       case 3:        //Sec3 
....................       { 
....................          glcd_rect(0, 31, 62, 63, NO, ON); 
01210:  MOVLB  7
01212:  CLRF   x7C
01214:  MOVLW  1F
01216:  MOVWF  x7D
01218:  MOVLW  3E
0121A:  MOVWF  x7E
0121C:  MOVLW  3F
0121E:  MOVWF  x7F
01220:  CLRF   x80
01222:  MOVLW  01
01224:  MOVWF  x81
01226:  MOVLB  0
01228:  RCALL  10E8
....................          break; 
0122A:  MOVLB  7
0122C:  BRA    130C
0122E:  MOVLB  0
....................       } 
....................       case 4:        //Sec4 
....................       { 
....................          glcd_rect(63, 31, 127, 63, YES, ON); 
01230:  MOVLW  3F
01232:  MOVLB  7
01234:  MOVWF  x7C
01236:  MOVLW  1F
01238:  MOVWF  x7D
0123A:  MOVLW  7F
0123C:  MOVWF  x7E
0123E:  MOVLW  3F
01240:  MOVWF  x7F
01242:  MOVLW  01
01244:  MOVWF  x80
01246:  MOVWF  x81
01248:  MOVLB  0
0124A:  RCALL  10E8
....................          glcd_rect(63, 31, 127, 63, NO, OFF); 
0124C:  MOVLW  3F
0124E:  MOVLB  7
01250:  MOVWF  x7C
01252:  MOVLW  1F
01254:  MOVWF  x7D
01256:  MOVLW  7F
01258:  MOVWF  x7E
0125A:  MOVLW  3F
0125C:  MOVWF  x7F
0125E:  CLRF   x80
01260:  CLRF   x81
01262:  MOVLB  0
01264:  RCALL  10E8
....................          break; 
01266:  MOVLB  7
01268:  BRA    130C
0126A:  MOVLB  0
....................       } 
....................       case 0: 
....................       { 
....................          glcd_rect(0, 0, 62, 30, YES, ON);    
0126C:  MOVLB  7
0126E:  CLRF   x7C
01270:  CLRF   x7D
01272:  MOVLW  3E
01274:  MOVWF  x7E
01276:  MOVLW  1E
01278:  MOVWF  x7F
0127A:  MOVLW  01
0127C:  MOVWF  x80
0127E:  MOVWF  x81
01280:  MOVLB  0
01282:  RCALL  10E8
....................          glcd_rect(0, 0, 62, 30, NO, OFF); 
01284:  MOVLB  7
01286:  CLRF   x7C
01288:  CLRF   x7D
0128A:  MOVLW  3E
0128C:  MOVWF  x7E
0128E:  MOVLW  1E
01290:  MOVWF  x7F
01292:  CLRF   x80
01294:  CLRF   x81
01296:  MOVLB  0
01298:  RCALL  10E8
....................          glcd_rect(63, 0, 127, 30, NO, ON); 
0129A:  MOVLW  3F
0129C:  MOVLB  7
0129E:  MOVWF  x7C
012A0:  CLRF   x7D
012A2:  MOVLW  7F
012A4:  MOVWF  x7E
012A6:  MOVLW  1E
012A8:  MOVWF  x7F
012AA:  CLRF   x80
012AC:  MOVLW  01
012AE:  MOVWF  x81
012B0:  MOVLB  0
012B2:  RCALL  10E8
....................          glcd_rect(0, 31, 62, 63, NO, ON); 
012B4:  MOVLB  7
012B6:  CLRF   x7C
012B8:  MOVLW  1F
012BA:  MOVWF  x7D
012BC:  MOVLW  3E
012BE:  MOVWF  x7E
012C0:  MOVLW  3F
012C2:  MOVWF  x7F
012C4:  CLRF   x80
012C6:  MOVLW  01
012C8:  MOVWF  x81
012CA:  MOVLB  0
012CC:  RCALL  10E8
....................          glcd_rect(63, 31, 127, 63, YES, ON); 
012CE:  MOVLW  3F
012D0:  MOVLB  7
012D2:  MOVWF  x7C
012D4:  MOVLW  1F
012D6:  MOVWF  x7D
012D8:  MOVLW  7F
012DA:  MOVWF  x7E
012DC:  MOVLW  3F
012DE:  MOVWF  x7F
012E0:  MOVLW  01
012E2:  MOVWF  x80
012E4:  MOVWF  x81
012E6:  MOVLB  0
012E8:  RCALL  10E8
....................          glcd_rect(63, 31, 127, 63, NO, OFF); 
012EA:  MOVLW  3F
012EC:  MOVLB  7
012EE:  MOVWF  x7C
012F0:  MOVLW  1F
012F2:  MOVWF  x7D
012F4:  MOVLW  7F
012F6:  MOVWF  x7E
012F8:  MOVLW  3F
012FA:  MOVWF  x7F
012FC:  CLRF   x80
012FE:  CLRF   x81
01300:  MOVLB  0
01302:  RCALL  10E8
....................          break; 
01304:  MOVLB  7
01306:  BRA    130C
01308:  MOVLB  0
0130A:  MOVLB  7
....................       } 
....................    }    
.................... } 
0130C:  MOVLB  0
0130E:  RETLW  00
....................  
.................... void glcd_text_sec(char sec, char line, char *textptr, int1 color) 
.................... { 
*
03F1C:  MOVLB  7
03F1E:  CLRF   x42
....................    int8 ly=0; 
....................    ly = (line-1)*9; 
03F20:  MOVLW  01
03F22:  SUBWF  x3E,W
03F24:  MULLW  09
03F26:  MOVFF  FF3,742
....................    switch (sec) 
....................    { 
03F2A:  MOVLW  01
03F2C:  SUBWF  x3D,W
03F2E:  ADDLW  FC
03F30:  BC    3FEC
03F32:  ADDLW  04
03F34:  MOVLB  0
03F36:  GOTO   3FF0
....................       case 1: 
....................       { 
....................          glcd_text57(3, 3+ly, textptr, 1, color); 
03F3A:  MOVLW  03
03F3C:  MOVLB  7
03F3E:  ADDWF  x42,W
03F40:  MOVWF  x43
03F42:  MOVLW  03
03F44:  MOVWF  x7C
03F46:  MOVFF  743,77D
03F4A:  MOVFF  740,77F
03F4E:  MOVFF  73F,77E
03F52:  MOVLW  01
03F54:  MOVWF  x80
03F56:  MOVFF  741,781
03F5A:  MOVLB  0
03F5C:  CALL   1738
....................          break; 
03F60:  MOVLB  7
03F62:  BRA    3FEC
03F64:  MOVLB  0
....................       } 
....................       case 2: 
....................       { 
....................          glcd_text57(66, 3+ly, textptr, 1, color); 
03F66:  MOVLW  03
03F68:  MOVLB  7
03F6A:  ADDWF  x42,W
03F6C:  MOVWF  x43
03F6E:  MOVLW  42
03F70:  MOVWF  x7C
03F72:  MOVFF  743,77D
03F76:  MOVFF  740,77F
03F7A:  MOVFF  73F,77E
03F7E:  MOVLW  01
03F80:  MOVWF  x80
03F82:  MOVFF  741,781
03F86:  MOVLB  0
03F88:  CALL   1738
....................          break; 
03F8C:  MOVLB  7
03F8E:  BRA    3FEC
03F90:  MOVLB  0
....................       } 
....................       case 3: 
....................       { 
....................          glcd_text57(3, 34+ly, textptr, 1, color); 
03F92:  MOVLW  22
03F94:  MOVLB  7
03F96:  ADDWF  x42,W
03F98:  MOVWF  x43
03F9A:  MOVLW  03
03F9C:  MOVWF  x7C
03F9E:  MOVFF  743,77D
03FA2:  MOVFF  740,77F
03FA6:  MOVFF  73F,77E
03FAA:  MOVLW  01
03FAC:  MOVWF  x80
03FAE:  MOVFF  741,781
03FB2:  MOVLB  0
03FB4:  CALL   1738
....................          break; 
03FB8:  MOVLB  7
03FBA:  BRA    3FEC
03FBC:  MOVLB  0
....................       } 
....................       case 4: 
....................       { 
....................          glcd_text57(66, 34+ly, textptr, 1, color); 
03FBE:  MOVLW  22
03FC0:  MOVLB  7
03FC2:  ADDWF  x42,W
03FC4:  MOVWF  x43
03FC6:  MOVLW  42
03FC8:  MOVWF  x7C
03FCA:  MOVFF  743,77D
03FCE:  MOVFF  740,77F
03FD2:  MOVFF  73F,77E
03FD6:  MOVLW  01
03FD8:  MOVWF  x80
03FDA:  MOVFF  741,781
03FDE:  MOVLB  0
03FE0:  CALL   1738
....................          break; 
03FE4:  MOVLB  7
03FE6:  BRA    3FEC
03FE8:  MOVLB  0
03FEA:  MOVLB  7
....................       } 
....................    } 
....................     
.................... } 
03FEC:  MOVLB  0
03FEE:  RETLW  00
....................  
.................... void glcd_image(long mempointer  /*This is the image location in program memory*/)  
.................... {  int j, i;  
....................    int page = 0xB8;  
....................    char chipsel;  
....................    char buffer[1];  
....................    output_low(GLCD_DI);                // Set for instruction  
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0  
....................    glcd_writeByte(GLCD_CS2, 0x40);  
....................    glcd_writeByte(GLCD_CS1, page);     // Set the page address to 0  
....................    glcd_writeByte(GLCD_CS2, page);  
....................    for (j = 0; j < 8; j++, page+=1)  
....................    {  output_low(GLCD_DI);  
....................       glcd_writeByte(GLCD_CS1, page);  
....................       glcd_writeByte(GLCD_CS2, page);  
....................       for (i = 0; i < 128; i++)  
....................       {  
....................          if ( i < 64)  
....................          {  
....................             chipsel = GLCD_CS1;  
....................          }  
....................          else  
....................          {  
....................             chipsel = GLCD_CS2;  
....................          }  
....................          read_program_memory(mempointer, buffer, 1);  
....................          mempointer++;  
....................          output_high(GLCD_DI);  
....................          glcd_writeByte(chipsel, *buffer);  
....................       }  
....................    }  
.................... } 
....................  
....................  
....................  
....................  
.................... /*FIN**INCLUDES*/ 
....................  
.................... int try=0; 
.................... /*INTERRUPCIONES*/ 
....................  
.................... #INT_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................          int t;  
....................     
....................    try = 1; 
*
00C90:  MOVLW  01
00C92:  MOVLB  6
00C94:  MOVWF  xEB
....................  
....................    buffer[next_in]=getc();  
00C96:  CLRF   03
00C98:  MOVF   3A,W
00C9A:  ADDLW  1A
00C9C:  MOVWF  FE9
00C9E:  MOVLW  00
00CA0:  ADDWFC 03,W
00CA2:  MOVWF  FEA
00CA4:  MOVFF  FEA,7A7
00CA8:  MOVFF  FE9,7A6
00CAC:  MOVLB  0
00CAE:  BRA    0C78
00CB0:  MOVFF  7A7,FEA
00CB4:  MOVFF  7A6,FE9
00CB8:  MOVFF  01,FEF
....................    t=next_in;  
00CBC:  MOVFF  3A,7A3
....................    if(++next_in==BUFFER_SIZE)  
00CC0:  INCF   3A,F
00CC2:  MOVF   3A,W
00CC4:  SUBLW  20
00CC6:  BNZ   0CCA
....................       next_in=0;  
00CC8:  CLRF   3A
....................    if(next_in==next_out)  
00CCA:  MOVF   3B,W
00CCC:  SUBWF  3A,W
00CCE:  BNZ   0CD4
....................       next_in=t;    // Buffer full !!  
00CD0:  MOVFF  7A3,3A
....................  
....................    
.................... } 
....................  
00CD4:  BCF    F9E.5
00CD6:  GOTO   056C
.................... #INT_EXT1 
.................... void EXT1_isr(void) 
.................... { 
....................    config = 1; 
00CDA:  MOVLW  01
00CDC:  MOVWF  3F
....................     
.................... } 
....................  
.................... /*FIN**INTERRUPCIONES*/ 
....................  
....................  
.................... /*FUNCIONES*/ 
....................  
00CDE:  BCF    FF0.0
00CE0:  GOTO   056C
.................... int8 bgetc() {  
....................    int8 c;  
....................  
....................    while(!bkbhit) ;  
*
03AD0:  MOVF   3B,W
03AD2:  SUBWF  3A,W
03AD4:  BZ    3AD0
....................    c=buffer[next_out];  
03AD6:  CLRF   03
03AD8:  MOVF   3B,W
03ADA:  ADDLW  1A
03ADC:  MOVWF  FE9
03ADE:  MOVLW  00
03AE0:  ADDWFC 03,W
03AE2:  MOVWF  FEA
03AE4:  MOVFF  FEF,73D
03AE8:  MOVLB  7
....................    next_out=(next_out+1) % BUFFER_SIZE;  
03AEA:  MOVLW  01
03AEC:  ADDWF  3B,W
03AEE:  ANDLW  1F
03AF0:  MOVWF  3B
....................     
....................    return(c);  
03AF2:  MOVFF  73D,01
.................... }  
03AF6:  MOVLB  0
03AF8:  GOTO   4F3C (RETURN)
....................  
.................... /*FIN**FUNCIONES*/ 
....................  
.................... void str_init(char *name) 
.................... { 
....................    int8 z; 
....................    for (z=0;z<15;z++) 
03AFC:  MOVLB  7
03AFE:  CLRF   x3F
03B00:  MOVF   x3F,W
03B02:  SUBLW  0E
03B04:  BNC   3B1A
....................       { 
....................          name[z]=0; 
03B06:  CLRF   03
03B08:  MOVF   x3F,W
03B0A:  ADDWF  x3D,W
03B0C:  MOVWF  FE9
03B0E:  MOVF   x3E,W
03B10:  ADDWFC 03,W
03B12:  MOVWF  FEA
03B14:  CLRF   FEF
....................           
....................       } 
03B16:  INCF   x3F,F
03B18:  BRA    3B00
.................... } 
03B1A:  MOVLB  0
03B1C:  RETLW  00
....................  
.................... void main() 
.................... { 
*
042B4:  CLRF   FF8
042B6:  BCF    FD0.7
042B8:  BSF    07.7
042BA:  CLRF   FEA
042BC:  CLRF   FE9
042BE:  CLRF   19
042C0:  BCF    FB8.3
042C2:  MOVLW  0C
042C4:  MOVWF  FAF
042C6:  MOVLW  A2
042C8:  MOVWF  FAC
042CA:  MOVLW  90
042CC:  MOVWF  FAB
042CE:  CLRF   3A
042D0:  CLRF   3B
042D2:  CLRF   3D
042D4:  CLRF   3E
042D6:  CLRF   3F
042D8:  MOVLW  01
042DA:  MOVWF  40
042DC:  MOVLB  6
042DE:  CLRF   xEB
042E0:  CLRF   xED
042E2:  CLRF   xEC
042E4:  MOVF   FC1,W
042E6:  ANDLW  C0
042E8:  IORLW  0F
042EA:  MOVWF  FC1
042EC:  MOVLW  07
042EE:  MOVWF  FB4
042F0:  MOVLW  43
042F2:  MOVWF  4E
042F4:  MOVLW  6F
042F6:  MOVWF  4F
042F8:  MOVLW  6E
042FA:  MOVWF  50
042FC:  MOVLW  66
042FE:  MOVWF  51
04300:  MOVLW  69
04302:  MOVWF  52
04304:  MOVLW  67
04306:  MOVWF  53
04308:  MOVLW  75
0430A:  MOVWF  54
0430C:  MOVLW  72
0430E:  MOVWF  55
04310:  MOVLW  61
04312:  MOVWF  56
04314:  MOVLW  63
04316:  MOVWF  57
04318:  MOVLW  69
0431A:  MOVWF  58
0431C:  MOVLW  6F
0431E:  MOVWF  59
04320:  MOVLW  6E
04322:  MOVWF  5A
04324:  CLRF   5B
04326:  MOVLW  2D
04328:  MOVWF  5C
0432A:  MOVLW  46
0432C:  MOVWF  5D
0432E:  MOVLW  65
04330:  MOVWF  5E
04332:  MOVLW  63
04334:  MOVWF  5F
04336:  MOVLW  68
04338:  MOVLB  0
0433A:  MOVWF  x60
0433C:  MOVLW  61
0433E:  MOVWF  x61
04340:  MOVLW  20
04342:  MOVWF  x62
04344:  MOVLW  79
04346:  MOVWF  x63
04348:  MOVLW  20
0434A:  MOVWF  x64
0434C:  MOVLW  48
0434E:  MOVWF  x65
04350:  MOVLW  6F
04352:  MOVWF  x66
04354:  MOVLW  72
04356:  MOVWF  x67
04358:  MOVLW  61
0435A:  MOVWF  x68
0435C:  CLRF   x69
0435E:  MOVLW  2D
04360:  MOVWF  x6A
04362:  MOVLW  54
04364:  MOVWF  x6B
04366:  MOVLW  65
04368:  MOVWF  x6C
0436A:  MOVLW  6D
0436C:  MOVWF  x6D
0436E:  MOVLW  70
04370:  MOVWF  x6E
04372:  MOVLW  65
04374:  MOVWF  x6F
04376:  MOVLW  72
04378:  MOVWF  x70
0437A:  MOVLW  61
0437C:  MOVWF  x71
0437E:  MOVLW  74
04380:  MOVWF  x72
04382:  MOVLW  75
04384:  MOVWF  x73
04386:  MOVLW  72
04388:  MOVWF  x74
0438A:  MOVLW  61
0438C:  MOVWF  x75
0438E:  MOVLW  20
04390:  MOVWF  x76
04392:  MOVWF  x77
04394:  MOVWF  x78
04396:  CLRF   x79
04398:  MOVLW  2D
0439A:  MOVWF  x7A
0439C:  MOVWF  x7B
0439E:  MOVLW  43
043A0:  MOVWF  x7C
043A2:  MOVLW  65
043A4:  MOVWF  x7D
043A6:  MOVLW  6C
043A8:  MOVWF  x7E
043AA:  MOVLW  73
043AC:  MOVWF  x7F
043AE:  MOVLW  69
043B0:  MOVWF  x80
043B2:  MOVLW  75
043B4:  MOVWF  x81
043B6:  MOVLW  73
043B8:  MOVWF  x82
043BA:  CLRF   x83
043BC:  MOVLW  2D
043BE:  MOVWF  x84
043C0:  MOVWF  x85
043C2:  MOVLW  46
043C4:  MOVWF  x86
043C6:  MOVLW  61
043C8:  MOVWF  x87
043CA:  MOVLW  72
043CC:  MOVWF  x88
043CE:  MOVLW  65
043D0:  MOVWF  x89
043D2:  MOVLW  6E
043D4:  MOVWF  x8A
043D6:  MOVLW  68
043D8:  MOVWF  x8B
043DA:  MOVLW  65
043DC:  MOVWF  x8C
043DE:  MOVLW  69
043E0:  MOVWF  x8D
043E2:  MOVLW  74
043E4:  MOVWF  x8E
043E6:  CLRF   x8F
043E8:  MOVLW  2D
043EA:  MOVWF  x90
043EC:  MOVLW  50
043EE:  MOVWF  x91
043F0:  MOVLW  72
043F2:  MOVWF  x92
043F4:  MOVLW  65
043F6:  MOVWF  x93
043F8:  MOVLW  73
043FA:  MOVWF  x94
043FC:  MOVLW  69
043FE:  MOVWF  x95
04400:  MOVLW  6F
04402:  MOVWF  x96
04404:  MOVLW  6E
04406:  MOVWF  x97
04408:  CLRF   x98
0440A:  MOVLW  2D
0440C:  MOVWF  x99
0440E:  MOVWF  x9A
04410:  MOVLW  50
04412:  MOVWF  x9B
04414:  MOVLW  61
04416:  MOVWF  x9C
04418:  MOVLW  73
0441A:  MOVWF  x9D
0441C:  MOVLW  63
0441E:  MOVWF  x9E
04420:  MOVLW  61
04422:  MOVWF  x9F
04424:  MOVLW  6C
04426:  MOVWF  xA0
04428:  CLRF   xA1
0442A:  MOVLW  2D
0442C:  MOVWF  xA2
0442E:  MOVWF  xA3
04430:  MOVLW  4D
04432:  MOVWF  xA4
04434:  MOVLW  69
04436:  MOVWF  xA5
04438:  MOVLW  6C
0443A:  MOVWF  xA6
0443C:  MOVLW  69
0443E:  MOVWF  xA7
04440:  MOVLW  62
04442:  MOVWF  xA8
04444:  MOVLW  61
04446:  MOVWF  xA9
04448:  MOVLW  72
0444A:  MOVWF  xAA
0444C:  CLRF   xAB
0444E:  MOVLW  2D
04450:  MOVWF  xAC
04452:  MOVLW  56
04454:  MOVWF  xAD
04456:  MOVLW  65
04458:  MOVWF  xAE
0445A:  MOVLW  6C
0445C:  MOVWF  xAF
0445E:  MOVLW  6F
04460:  MOVWF  xB0
04462:  MOVLW  63
04464:  MOVWF  xB1
04466:  MOVLW  69
04468:  MOVWF  xB2
0446A:  MOVLW  64
0446C:  MOVWF  xB3
0446E:  MOVLW  61
04470:  MOVWF  xB4
04472:  MOVLW  64
04474:  MOVWF  xB5
04476:  CLRF   xB6
04478:  MOVLW  2D
0447A:  MOVWF  xB7
0447C:  MOVWF  xB8
0447E:  MOVLW  6D
04480:  MOVWF  xB9
04482:  MOVLW  2F
04484:  MOVWF  xBA
04486:  MOVLW  73
04488:  MOVWF  xBB
0448A:  CLRF   xBC
0448C:  MOVLW  2D
0448E:  MOVWF  xBD
04490:  MOVWF  xBE
04492:  MOVLW  6B
04494:  MOVWF  xBF
04496:  MOVLW  6D
04498:  MOVWF  xC0
0449A:  MOVLW  2F
0449C:  MOVWF  xC1
0449E:  MOVLW  68
044A0:  MOVWF  xC2
044A2:  CLRF   xC3
044A4:  MOVLW  2D
044A6:  MOVWF  xC4
044A8:  MOVWF  xC5
044AA:  MOVLW  4E
044AC:  MOVWF  xC6
044AE:  MOVLW  75
044B0:  MOVWF  xC7
044B2:  MOVLW  64
044B4:  MOVWF  xC8
044B6:  MOVLW  6F
044B8:  MOVWF  xC9
044BA:  MOVLW  73
044BC:  MOVWF  xCA
044BE:  CLRF   xCB
044C0:  MOVLW  30
044C2:  MOVWF  xCC
044C4:  MOVLW  31
044C6:  MOVWF  xCD
044C8:  CLRF   xCE
044CA:  MOVLW  30
044CC:  MOVWF  xCF
044CE:  MOVLW  31
044D0:  MOVWF  xD0
044D2:  CLRF   xD1
044D4:  MOVLW  30
044D6:  MOVWF  xD2
044D8:  MOVLW  31
044DA:  MOVWF  xD3
044DC:  CLRF   xD4
044DE:  MOVWF  xD5
044E0:  MOVLW  30
044E2:  MOVWF  xD6
044E4:  CLRF   xD7
044E6:  MOVLW  31
044E8:  MOVWF  xD8
044EA:  MOVLW  30
044EC:  MOVWF  xD9
044EE:  CLRF   xDA
044F0:  MOVLW  41
044F2:  MOVWF  xDB
044F4:  MOVLW  4D
044F6:  MOVWF  xDC
044F8:  CLRF   xDD
044FA:  MOVLW  43
044FC:  MOVWF  xDE
044FE:  CLRF   xDF
04500:  MOVLW  50
04502:  MOVWF  xE1
04504:  MOVLW  61
04506:  MOVWF  xE2
04508:  MOVLW  20
0450A:  MOVWF  xE3
0450C:  CLRF   xE4
0450E:  MOVLW  6D
04510:  MOVWF  xE5
04512:  MOVLW  2F
04514:  MOVWF  xE6
04516:  MOVLW  73
04518:  MOVWF  xE7
0451A:  MOVLW  20
0451C:  MOVWF  xE8
0451E:  CLRF   xE9
04520:  MOVLB  4
04522:  CLRF   xEA
04524:  CLRF   xEB
04526:  MOVLW  1F
04528:  MOVWF  xF0
0452A:  MOVWF  xF1
0452C:  CLRF   xF2
0452E:  CLRF   xF3
04530:  CLRF   xF4
04532:  MOVLW  80
04534:  MOVWF  xF5
04536:  CLRF   xF6
04538:  CLRF   xF7
0453A:  CLRF   xF8
0453C:  CLRF   xF9
0453E:  CLRF   xFA
04540:  CLRF   xFB
04542:  CLRF   xFC
04544:  CLRF   xFD
04546:  MOVLW  0C
04548:  MOVWF  xFE
0454A:  MOVLW  1E
0454C:  MOVWF  xFF
0454E:  MOVLW  38
04550:  MOVLB  5
04552:  MOVWF  x00
04554:  MOVLW  F0
04556:  MOVWF  x01
04558:  MOVWF  x02
0455A:  MOVLW  E0
0455C:  MOVWF  x03
0455E:  CLRF   x04
04560:  CLRF   x05
04562:  CLRF   x06
04564:  CLRF   x07
04566:  CLRF   x08
04568:  CLRF   x09
0456A:  MOVLW  C0
0456C:  MOVWF  x0A
0456E:  MOVLW  E0
04570:  MOVWF  x0B
04572:  MOVLW  60
04574:  MOVWF  x0C
04576:  MOVLW  20
04578:  MOVWF  x0D
0457A:  CLRF   x0E
0457C:  CLRF   x0F
0457E:  CLRF   x10
04580:  CLRF   x11
04582:  CLRF   x12
04584:  MOVLW  06
04586:  MOVWF  x13
04588:  MOVLW  0F
0458A:  MOVWF  x14
0458C:  MOVLW  2E
0458E:  MOVWF  x15
04590:  MOVLW  1C
04592:  MOVWF  x16
04594:  MOVWF  x17
04596:  MOVLW  3C
04598:  MOVWF  x18
0459A:  MOVWF  x19
0459C:  MOVLW  38
0459E:  MOVWF  x1A
045A0:  MOVLW  E0
045A2:  MOVWF  x1B
045A4:  MOVLW  78
045A6:  MOVWF  x1C
045A8:  MOVLW  DC
045AA:  MOVWF  x1D
045AC:  MOVLW  FC
045AE:  MOVWF  x1E
045B0:  MOVWF  x1F
045B2:  MOVLW  FF
045B4:  MOVWF  x20
045B6:  MOVLW  DF
045B8:  MOVWF  x21
045BA:  MOVLW  DD
045BC:  MOVWF  x22
045BE:  MOVLW  FC
045C0:  MOVWF  x23
045C2:  MOVLW  BC
045C4:  MOVWF  x24
045C6:  MOVLW  FA
045C8:  MOVWF  x25
045CA:  MOVLW  F2
045CC:  MOVWF  x26
045CE:  MOVLW  EE
045D0:  MOVWF  x27
045D2:  MOVLW  0E
045D4:  MOVWF  x28
045D6:  MOVLW  07
045D8:  MOVWF  x29
045DA:  MOVWF  x2A
045DC:  CLRF   x2B
045DE:  CLRF   x2C
045E0:  CLRF   x2D
045E2:  CLRF   x2E
045E4:  CLRF   x2F
045E6:  CLRF   x30
045E8:  MOVLW  08
045EA:  MOVWF  x31
045EC:  MOVLW  18
045EE:  MOVWF  x32
045F0:  MOVLW  30
045F2:  MOVWF  x33
045F4:  MOVLW  38
045F6:  MOVWF  x34
045F8:  MOVLW  3C
045FA:  MOVWF  x35
045FC:  MOVLW  1C
045FE:  MOVWF  x36
04600:  MOVWF  x37
04602:  MOVLW  78
04604:  MOVWF  x38
04606:  MOVLW  18
04608:  MOVWF  x39
0460A:  MOVLW  9F
0460C:  MOVWF  x3A
0460E:  MOVLW  BF
04610:  MOVWF  x3B
04612:  MOVLW  FF
04614:  MOVWF  x3C
04616:  MOVLW  79
04618:  MOVWF  x3D
0461A:  MOVLW  FF
0461C:  MOVWF  x3E
0461E:  MOVLW  EF
04620:  MOVWF  x3F
04622:  MOVWF  x40
04624:  MOVWF  x41
04626:  MOVLW  F7
04628:  MOVWF  x42
0462A:  MOVLW  FB
0462C:  MOVWF  x43
0462E:  MOVLW  BF
04630:  MOVWF  x44
04632:  MOVLW  3F
04634:  MOVWF  x45
04636:  MOVLW  1F
04638:  MOVWF  x46
0463A:  MOVLW  02
0463C:  MOVWF  x47
0463E:  MOVLW  07
04640:  MOVWF  x48
04642:  MOVWF  x49
04644:  MOVLW  0F
04646:  MOVWF  x4A
04648:  MOVLW  07
0464A:  MOVWF  x4B
0464C:  MOVLW  01
0464E:  MOVWF  x4C
04650:  MOVLW  03
04652:  MOVWF  x4D
04654:  MOVLW  06
04656:  MOVWF  x4E
04658:  CLRF   x4F
0465A:  CLRF   x50
0465C:  CLRF   x51
0465E:  CLRF   x52
04660:  CLRF   x53
04662:  CLRF   x54
04664:  CLRF   x55
04666:  CLRF   x56
04668:  MOVLW  30
0466A:  MOVWF  x57
0466C:  MOVLW  7C
0466E:  MOVWF  x58
04670:  MOVLW  0F
04672:  MOVWF  x59
04674:  MOVWF  x5A
04676:  MOVWF  x5B
04678:  MOVLW  07
0467A:  MOVWF  x5C
0467C:  CLRF   x5D
0467E:  CLRF   x5E
04680:  CLRF   x5F
04682:  MOVLW  03
04684:  MOVWF  x60
04686:  MOVLW  07
04688:  MOVWF  x61
0468A:  MOVLW  0F
0468C:  MOVWF  x62
0468E:  MOVLW  0E
04690:  MOVWF  x63
04692:  MOVLW  06
04694:  MOVWF  x64
04696:  MOVLW  1E
04698:  MOVWF  x65
0469A:  MOVLW  1C
0469C:  MOVWF  x66
0469E:  CLRF   x67
046A0:  CLRF   x68
046A2:  CLRF   x69
046A4:  CLRF   x6A
046A6:  CLRF   x6B
046A8:  CLRF   x6C
046AA:  MOVLW  1F
046AC:  MOVWF  x6D
046AE:  MOVWF  x6E
046B0:  CLRF   x6F
046B2:  MOVLW  C0
046B4:  MOVWF  x70
046B6:  MOVLW  E0
046B8:  MOVWF  x71
046BA:  MOVLW  20
046BC:  MOVWF  x72
046BE:  MOVLW  30
046C0:  MOVWF  x73
046C2:  MOVLW  10
046C4:  MOVWF  x74
046C6:  MOVWF  x75
046C8:  MOVLW  30
046CA:  MOVWF  x76
046CC:  MOVLW  18
046CE:  MOVWF  x77
046D0:  MOVWF  x78
046D2:  MOVLW  78
046D4:  MOVWF  x79
046D6:  MOVLW  70
046D8:  MOVWF  x7A
046DA:  MOVLW  50
046DC:  MOVWF  x7B
046DE:  MOVLW  D8
046E0:  MOVWF  x7C
046E2:  MOVLW  08
046E4:  MOVWF  x7D
046E6:  MOVWF  x7E
046E8:  MOVWF  x7F
046EA:  MOVLW  18
046EC:  MOVWF  x80
046EE:  MOVWF  x81
046F0:  MOVLW  10
046F2:  MOVWF  x82
046F4:  MOVLW  30
046F6:  MOVWF  x83
046F8:  MOVLW  60
046FA:  MOVWF  x84
046FC:  MOVLW  E0
046FE:  MOVWF  x85
04700:  MOVLW  80
04702:  MOVWF  x86
04704:  CLRF   x87
04706:  CLRF   x88
04708:  CLRF   x89
0470A:  CLRF   x8A
0470C:  CLRF   x8B
0470E:  CLRF   x8C
04710:  CLRF   x8D
04712:  CLRF   x8E
04714:  CLRF   x8F
04716:  CLRF   x90
04718:  MOVLW  01
0471A:  MOVWF  x91
0471C:  MOVWF  x92
0471E:  MOVLW  0F
04720:  MOVWF  x93
04722:  MOVLW  08
04724:  MOVWF  x94
04726:  MOVLW  38
04728:  MOVWF  x95
0472A:  MOVLW  F8
0472C:  MOVWF  x96
0472E:  MOVLW  18
04730:  MOVWF  x97
04732:  MOVWF  x98
04734:  MOVLW  08
04736:  MOVWF  x99
04738:  MOVLW  0F
0473A:  MOVWF  x9A
0473C:  MOVLW  03
0473E:  MOVWF  x9B
04740:  MOVLW  C1
04742:  MOVWF  x9C
04744:  MOVLW  E0
04746:  MOVWF  x9D
04748:  MOVLW  60
0474A:  MOVWF  x9E
0474C:  MOVLW  20
0474E:  MOVWF  x9F
04750:  MOVLW  70
04752:  MOVWF  xA0
04754:  MOVLW  10
04756:  MOVWF  xA1
04758:  MOVWF  xA2
0475A:  MOVWF  xA3
0475C:  MOVLW  38
0475E:  MOVWF  xA4
04760:  MOVLW  18
04762:  MOVWF  xA5
04764:  MOVLW  0B
04766:  MOVWF  xA6
04768:  MOVLW  0F
0476A:  MOVWF  xA7
0476C:  MOVLW  38
0476E:  MOVWF  xA8
04770:  MOVLW  70
04772:  MOVWF  xA9
04774:  MOVLW  40
04776:  MOVWF  xAA
04778:  MOVLW  C0
0477A:  MOVWF  xAB
0477C:  MOVLW  80
0477E:  MOVWF  xAC
04780:  CLRF   xAD
04782:  CLRF   xAE
04784:  CLRF   xAF
04786:  MOVLW  7C
04788:  MOVWF  xB0
0478A:  MOVLW  C6
0478C:  MOVWF  xB1
0478E:  MOVLW  86
04790:  MOVWF  xB2
04792:  MOVLW  82
04794:  MOVWF  xB3
04796:  MOVWF  xB4
04798:  MOVLW  87
0479A:  MOVWF  xB5
0479C:  MOVLW  01
0479E:  MOVWF  xB6
047A0:  MOVLW  07
047A2:  MOVWF  xB7
047A4:  MOVLW  0C
047A6:  MOVWF  xB8
047A8:  MOVLW  08
047AA:  MOVWF  xB9
047AC:  MOVLW  18
047AE:  MOVWF  xBA
047B0:  MOVLW  10
047B2:  MOVWF  xBB
047B4:  MOVLW  31
047B6:  MOVWF  xBC
047B8:  MOVLW  27
047BA:  MOVWF  xBD
047BC:  MOVLW  26
047BE:  MOVWF  xBE
047C0:  MOVLW  24
047C2:  MOVWF  xBF
047C4:  MOVLW  3C
047C6:  MOVWF  xC0
047C8:  MOVLW  20
047CA:  MOVWF  xC1
047CC:  MOVLW  E0
047CE:  MOVWF  xC2
047D0:  MOVWF  xC3
047D2:  MOVWF  xC4
047D4:  MOVLW  C0
047D6:  MOVWF  xC5
047D8:  MOVWF  xC6
047DA:  MOVLW  40
047DC:  MOVWF  xC7
047DE:  MOVLW  60
047E0:  MOVWF  xC8
047E2:  MOVLW  3C
047E4:  MOVWF  xC9
047E6:  MOVLW  04
047E8:  MOVWF  xCA
047EA:  MOVWF  xCB
047EC:  MOVLW  07
047EE:  MOVWF  xCC
047F0:  CLRF   xCD
047F2:  CLRF   xCE
047F4:  CLRF   xCF
047F6:  CLRF   xD0
047F8:  CLRF   xD1
047FA:  CLRF   xD2
047FC:  CLRF   xD3
047FE:  MOVLW  03
04800:  MOVWF  xD4
04802:  MOVLW  0F
04804:  MOVWF  xD5
04806:  MOVLW  08
04808:  MOVWF  xD6
0480A:  MOVLW  18
0480C:  MOVWF  xD7
0480E:  MOVLW  10
04810:  MOVWF  xD8
04812:  MOVWF  xD9
04814:  MOVWF  xDA
04816:  MOVLW  30
04818:  MOVWF  xDB
0481A:  MOVLW  20
0481C:  MOVWF  xDC
0481E:  MOVWF  xDD
04820:  MOVWF  xDE
04822:  MOVWF  xDF
04824:  MOVLW  30
04826:  MOVWF  xE0
04828:  MOVLW  10
0482A:  MOVWF  xE1
0482C:  MOVLW  1D
0482E:  MOVWF  xE2
04830:  MOVLW  07
04832:  MOVWF  xE3
04834:  CLRF   xE4
04836:  CLRF   xE5
04838:  CLRF   xE6
0483A:  CLRF   xE7
0483C:  CLRF   xE8
0483E:  CLRF   xE9
04840:  CLRF   xEA
04842:  CLRF   xEB
04844:  CLRF   xEC
04846:  CLRF   xED
04848:  CLRF   xEE
0484A:  MOVLW  1F
0484C:  MOVWF  xEF
0484E:  MOVWF  xF0
04850:  CLRF   xF1
04852:  CLRF   xF2
04854:  MOVLW  C0
04856:  MOVWF  xF3
04858:  MOVLW  60
0485A:  MOVWF  xF4
0485C:  MOVLW  30
0485E:  MOVWF  xF5
04860:  MOVLW  10
04862:  MOVWF  xF6
04864:  MOVLW  08
04866:  MOVWF  xF7
04868:  MOVLW  0C
0486A:  MOVWF  xF8
0486C:  MOVLW  04
0486E:  MOVWF  xF9
04870:  MOVWF  xFA
04872:  MOVLW  0C
04874:  MOVWF  xFB
04876:  MOVLW  08
04878:  MOVWF  xFC
0487A:  MOVLW  0C
0487C:  MOVWF  xFD
0487E:  MOVLW  04
04880:  MOVWF  xFE
04882:  MOVLW  06
04884:  MOVWF  xFF
04886:  MOVLW  02
04888:  MOVLB  6
0488A:  MOVWF  x00
0488C:  MOVWF  x01
0488E:  MOVWF  x02
04890:  MOVWF  x03
04892:  MOVWF  x04
04894:  MOVLW  06
04896:  MOVWF  x05
04898:  MOVLW  0C
0489A:  MOVWF  x06
0489C:  MOVLW  18
0489E:  MOVWF  x07
048A0:  MOVLW  10
048A2:  MOVWF  x08
048A4:  MOVLW  30
048A6:  MOVWF  x09
048A8:  MOVLW  60
048AA:  MOVWF  x0A
048AC:  MOVLW  C0
048AE:  MOVWF  x0B
048B0:  MOVLW  80
048B2:  MOVWF  x0C
048B4:  MOVWF  x0D
048B6:  CLRF   x0E
048B8:  CLRF   x0F
048BA:  CLRF   x10
048BC:  MOVLW  1F
048BE:  MOVWF  x11
048C0:  MOVLW  F1
048C2:  MOVWF  x12
048C4:  MOVLW  80
048C6:  MOVWF  x13
048C8:  CLRF   x14
048CA:  CLRF   x15
048CC:  CLRF   x16
048CE:  CLRF   x17
048D0:  CLRF   x18
048D2:  CLRF   x19
048D4:  CLRF   x1A
048D6:  CLRF   x1B
048D8:  CLRF   x1C
048DA:  CLRF   x1D
048DC:  CLRF   x1E
048DE:  CLRF   x1F
048E0:  CLRF   x20
048E2:  CLRF   x21
048E4:  CLRF   x22
048E6:  CLRF   x23
048E8:  CLRF   x24
048EA:  CLRF   x25
048EC:  CLRF   x26
048EE:  CLRF   x27
048F0:  CLRF   x28
048F2:  CLRF   x29
048F4:  CLRF   x2A
048F6:  CLRF   x2B
048F8:  MOVLW  03
048FA:  MOVWF  x2C
048FC:  MOVLW  FE
048FE:  MOVWF  x2D
04900:  CLRF   x2E
04902:  CLRF   x2F
04904:  CLRF   x30
04906:  CLRF   x31
04908:  MOVLW  01
0490A:  MOVWF  x32
0490C:  MOVLW  43
0490E:  MOVWF  x33
04910:  MOVLW  22
04912:  MOVWF  x34
04914:  MOVLW  32
04916:  MOVWF  x35
04918:  MOVLW  02
0491A:  MOVWF  x36
0491C:  MOVLW  32
0491E:  MOVWF  x37
04920:  MOVLW  1A
04922:  MOVWF  x38
04924:  MOVLW  03
04926:  MOVWF  x39
04928:  MOVLW  C7
0492A:  MOVWF  x3A
0492C:  MOVLW  4C
0492E:  MOVWF  x3B
04930:  MOVLW  08
04932:  MOVWF  x3C
04934:  MOVWF  x3D
04936:  MOVWF  x3E
04938:  MOVLW  44
0493A:  MOVWF  x3F
0493C:  MOVLW  64
0493E:  MOVWF  x40
04940:  MOVLW  06
04942:  MOVWF  x41
04944:  MOVLW  03
04946:  MOVWF  x42
04948:  MOVLW  C6
0494A:  MOVWF  x43
0494C:  MOVLW  04
0494E:  MOVWF  x44
04950:  MOVLW  16
04952:  MOVWF  x45
04954:  MOVLW  02
04956:  MOVWF  x46
04958:  MOVLW  22
0495A:  MOVWF  x47
0495C:  MOVLW  A2
0495E:  MOVWF  x48
04960:  MOVLW  82
04962:  MOVWF  x49
04964:  MOVLW  03
04966:  MOVWF  x4A
04968:  MOVLW  01
0496A:  MOVWF  x4B
0496C:  MOVWF  x4C
0496E:  CLRF   x4D
04970:  CLRF   x4E
04972:  CLRF   x4F
04974:  MOVLW  0C
04976:  MOVWF  x50
04978:  MOVLW  02
0497A:  MOVWF  x51
0497C:  MOVLW  10
0497E:  MOVWF  x52
04980:  MOVLW  18
04982:  MOVWF  x53
04984:  CLRF   x54
04986:  MOVLW  03
04988:  MOVWF  x55
0498A:  CLRF   x56
0498C:  MOVLW  08
0498E:  MOVWF  x57
04990:  MOVLW  0C
04992:  MOVWF  x58
04994:  MOVLW  04
04996:  MOVWF  x59
04998:  CLRF   x5A
0499A:  CLRF   x5B
0499C:  MOVLW  03
0499E:  MOVWF  x5C
049A0:  MOVLW  09
049A2:  MOVWF  x5D
049A4:  CLRF   x5E
049A6:  MOVLW  0C
049A8:  MOVWF  x5F
049AA:  CLRF   x60
049AC:  CLRF   x61
049AE:  MOVWF  x62
049B0:  CLRF   x63
049B2:  MOVLW  03
049B4:  MOVWF  x64
049B6:  MOVLW  18
049B8:  MOVWF  x65
049BA:  MOVLW  08
049BC:  MOVWF  x66
049BE:  MOVLW  01
049C0:  MOVWF  x67
049C2:  CLRF   x68
049C4:  CLRF   x69
049C6:  CLRF   x6A
049C8:  CLRF   x6B
049CA:  CLRF   x6C
049CC:  MOVLW  1F
049CE:  MOVWF  x6D
049D0:  MOVWF  x6E
049D2:  CLRF   x6F
049D4:  MOVLW  C0
049D6:  MOVWF  x70
049D8:  MOVLW  E0
049DA:  MOVWF  x71
049DC:  MOVLW  60
049DE:  MOVWF  x72
049E0:  MOVLW  20
049E2:  MOVWF  x73
049E4:  MOVWF  x74
049E6:  MOVWF  x75
049E8:  MOVLW  78
049EA:  MOVWF  x76
049EC:  MOVLW  0C
049EE:  MOVWF  x77
049F0:  MOVWF  x78
049F2:  MOVWF  x79
049F4:  MOVLW  08
049F6:  MOVWF  x7A
049F8:  MOVLW  0C
049FA:  MOVWF  x7B
049FC:  MOVWF  x7C
049FE:  MOVLW  18
04A00:  MOVWF  x7D
04A02:  MOVLW  1C
04A04:  MOVWF  x7E
04A06:  MOVLW  04
04A08:  MOVWF  x7F
04A0A:  MOVLW  06
04A0C:  MOVWF  x80
04A0E:  MOVLW  02
04A10:  MOVWF  x81
04A12:  MOVWF  x82
04A14:  MOVWF  x83
04A16:  MOVLW  1E
04A18:  MOVWF  x84
04A1A:  MOVLW  1C
04A1C:  MOVWF  x85
04A1E:  MOVLW  F0
04A20:  MOVWF  x86
04A22:  MOVLW  E0
04A24:  MOVWF  x87
04A26:  MOVLW  C0
04A28:  MOVWF  x88
04A2A:  MOVLW  80
04A2C:  MOVWF  x89
04A2E:  MOVWF  x8A
04A30:  MOVWF  x8B
04A32:  CLRF   x8C
04A34:  CLRF   x8D
04A36:  CLRF   x8E
04A38:  MOVLW  0F
04A3A:  MOVWF  x8F
04A3C:  MOVLW  18
04A3E:  MOVWF  x90
04A40:  MOVLW  30
04A42:  MOVWF  x91
04A44:  MOVLW  20
04A46:  MOVWF  x92
04A48:  MOVWF  x93
04A4A:  MOVWF  x94
04A4C:  MOVLW  E0
04A4E:  MOVWF  x95
04A50:  CLRF   x96
04A52:  CLRF   x97
04A54:  CLRF   x98
04A56:  CLRF   x99
04A58:  CLRF   x9A
04A5A:  CLRF   x9B
04A5C:  CLRF   x9C
04A5E:  CLRF   x9D
04A60:  CLRF   x9E
04A62:  CLRF   x9F
04A64:  CLRF   xA0
04A66:  CLRF   xA1
04A68:  CLRF   xA2
04A6A:  CLRF   xA3
04A6C:  CLRF   xA4
04A6E:  CLRF   xA5
04A70:  MOVWF  xA6
04A72:  MOVLW  A0
04A74:  MOVWF  xA7
04A76:  MOVLW  60
04A78:  MOVWF  xA8
04A7A:  MOVWF  xA9
04A7C:  MOVLW  33
04A7E:  MOVWF  xAA
04A80:  MOVLW  1F
04A82:  MOVWF  xAB
04A84:  CLRF   xAC
04A86:  CLRF   xAD
04A88:  MOVLW  38
04A8A:  MOVWF  xAE
04A8C:  MOVLW  6C
04A8E:  MOVWF  xAF
04A90:  MOVLW  44
04A92:  MOVWF  xB0
04A94:  MOVLW  68
04A96:  MOVWF  xB1
04A98:  MOVLW  F0
04A9A:  MOVWF  xB2
04A9C:  CLRF   xB3
04A9E:  MOVLW  C7
04AA0:  MOVWF  xB4
04AA2:  MOVLW  6C
04AA4:  MOVWF  xB5
04AA6:  MOVLW  28
04AA8:  MOVWF  xB6
04AAA:  MOVWF  xB7
04AAC:  MOVLW  48
04AAE:  MOVWF  xB8
04AB0:  MOVLW  98
04AB2:  MOVWF  xB9
04AB4:  MOVLW  18
04AB6:  MOVWF  xBA
04AB8:  MOVLW  38
04ABA:  MOVWF  xBB
04ABC:  MOVLW  30
04ABE:  MOVWF  xBC
04AC0:  MOVLW  20
04AC2:  MOVWF  xBD
04AC4:  MOVWF  xBE
04AC6:  MOVWF  xBF
04AC8:  MOVWF  xC0
04ACA:  MOVLW  30
04ACC:  MOVWF  xC1
04ACE:  MOVLW  10
04AD0:  MOVWF  xC2
04AD2:  MOVLW  18
04AD4:  MOVWF  xC3
04AD6:  MOVLW  8C
04AD8:  MOVWF  xC4
04ADA:  MOVLW  C7
04ADC:  MOVWF  xC5
04ADE:  MOVLW  01
04AE0:  MOVWF  xC6
04AE2:  CLRF   xC7
04AE4:  CLRF   xC8
04AE6:  MOVLW  80
04AE8:  MOVWF  xC9
04AEA:  CLRF   xCA
04AEC:  CLRF   xCB
04AEE:  CLRF   xCC
04AF0:  CLRF   xCD
04AF2:  MOVLW  0E
04AF4:  MOVWF  xCE
04AF6:  MOVLW  0A
04AF8:  MOVWF  xCF
04AFA:  MOVLW  0E
04AFC:  MOVWF  xD0
04AFE:  CLRF   xD1
04B00:  MOVLW  03
04B02:  MOVWF  xD2
04B04:  MOVLW  07
04B06:  MOVWF  xD3
04B08:  MOVLW  04
04B0A:  MOVWF  xD4
04B0C:  MOVWF  xD5
04B0E:  MOVWF  xD6
04B10:  MOVLW  06
04B12:  MOVWF  xD7
04B14:  MOVLW  03
04B16:  MOVWF  xD8
04B18:  CLRF   xD9
04B1A:  MOVLW  0E
04B1C:  MOVWF  xDA
04B1E:  MOVLW  06
04B20:  MOVWF  xDB
04B22:  CLRF   xDC
04B24:  MOVLW  1F
04B26:  MOVWF  xDD
04B28:  MOVLW  11
04B2A:  MOVWF  xDE
04B2C:  MOVWF  xDF
04B2E:  MOVLW  1B
04B30:  MOVWF  xE0
04B32:  MOVLW  0E
04B34:  MOVWF  xE1
04B36:  CLRF   xE2
04B38:  MOVLW  03
04B3A:  MOVWF  xE3
04B3C:  MOVLW  01
04B3E:  MOVWF  xE4
04B40:  CLRF   xE5
04B42:  CLRF   xE6
04B44:  MOVLW  3B
04B46:  MOVWF  xE7
04B48:  MOVLW  33
04B4A:  MOVWF  xE8
04B4C:  CLRF   xE9
04B4E:  CLRF   xEA
....................  
....................     
....................     
....................    enable_interrupts(INT_RDA); 
04B50:  BSF    F9D.5
....................    enable_interrupts(INT_EXT1); 
04B52:  BSF    FF0.3
....................    enable_interrupts(global); 
04B54:  MOVLW  C0
04B56:  IORWF  FF2,F
....................     
....................    setup_psp(PSP_DISABLED); 
04B58:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
04B5A:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
04B5C:  MOVLW  80
04B5E:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
04B60:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
04B62:  MOVLW  00
04B64:  MOVWF  FCA
04B66:  MOVLW  00
04B68:  MOVWF  FCB
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
04B6A:  CLRF   FB1
....................    setup_comparator(NC_NC_NC_NC); 
04B6C:  MOVLW  07
04B6E:  MOVWF  FB4
04B70:  MOVF   F95,W
04B72:  MOVWF  F95
04B74:  MOVF   F96,W
04B76:  MOVWF  F96
04B78:  MOVLW  06
04B7A:  MOVWF  00
04B7C:  DECFSZ 00,F
04B7E:  BRA    4B7C
04B80:  NOP   
04B82:  MOVF   FB4,W
04B84:  BCF    FA1.6
....................    setup_vref(FALSE); 
04B86:  CLRF   FB5
....................     
....................    setup_adc( ADC_OFF ); 
04B88:  BCF    FC2.0
....................  
....................  
....................    //setup_adc_ports(NO_ANALOGS|VREF_VREF); 
....................  
....................  
....................   // setup_oscillator(OSC_8MHZ|OSC_TIMER1|OSC_PLL_OFF);    
....................     
....................     
....................    glcd_init(ON);     
04B8A:  MOVLW  01
04B8C:  MOVLB  7
04B8E:  MOVWF  x3D
04B90:  MOVLB  0
04B92:  GOTO   0E44
....................     
....................     
....................     
....................          int8 axt,axp,axv; 
....................          axt = read_eeprom(0x01); 
04B96:  MOVFF  FF2,73D
04B9A:  BCF    FF2.7
04B9C:  CLRF   FAA
04B9E:  MOVLW  01
04BA0:  MOVWF  FA9
04BA2:  BCF    FA6.6
04BA4:  BCF    FA6.7
04BA6:  BSF    FA6.0
04BA8:  MOVF   FA8,W
04BAA:  MOVLB  7
04BAC:  BTFSC  x3D.7
04BAE:  BSF    FF2.7
04BB0:  MOVLB  6
04BB2:  MOVWF  xEE
....................          axp = read_eeprom(0x02); 
04BB4:  MOVFF  FF2,73D
04BB8:  BCF    FF2.7
04BBA:  CLRF   FAA
04BBC:  MOVLW  02
04BBE:  MOVWF  FA9
04BC0:  BCF    FA6.6
04BC2:  BCF    FA6.7
04BC4:  BSF    FA6.0
04BC6:  MOVF   FA8,W
04BC8:  MOVLB  7
04BCA:  BTFSC  x3D.7
04BCC:  BSF    FF2.7
04BCE:  MOVLB  6
04BD0:  MOVWF  xEF
....................          axv = read_eeprom(0x03); 
04BD2:  MOVFF  FF2,73D
04BD6:  BCF    FF2.7
04BD8:  CLRF   FAA
04BDA:  MOVLW  03
04BDC:  MOVWF  FA9
04BDE:  BCF    FA6.6
04BE0:  BCF    FA6.7
04BE2:  BSF    FA6.0
04BE4:  MOVF   FA8,W
04BE6:  MOVLB  7
04BE8:  BTFSC  x3D.7
04BEA:  BSF    FF2.7
04BEC:  MOVLB  6
04BEE:  MOVWF  xF0
....................     
....................          if(axt==1) 
04BF0:  DECFSZ xEE,W
04BF2:  BRA    4BFC
....................          { 
....................             UniTemp[0]="C"; 
04BF4:  MOVLW  43
04BF6:  MOVLB  0
04BF8:  MOVWF  xDE
04BFA:  MOVLB  6
....................          } 
....................          if(axt==2) 
04BFC:  MOVF   xEE,W
04BFE:  SUBLW  02
04C00:  BNZ   4C0A
....................          { 
....................             UniTemp[0]="F"; 
04C02:  MOVLW  46
04C04:  MOVLB  0
04C06:  MOVWF  xDE
04C08:  MOVLB  6
....................          } 
....................          if(axp==1) 
04C0A:  DECFSZ xEF,W
04C0C:  BRA    4C16
....................          { 
....................             UniPres[0]="Pa"; 
04C0E:  MOVLW  50
04C10:  MOVLB  0
04C12:  MOVWF  xE1
04C14:  MOVLB  6
....................          } 
....................          if(axp==2) 
04C16:  MOVF   xEF,W
04C18:  SUBLW  02
04C1A:  BNZ   4C24
....................          { 
....................             UniPres[0]="mBa"; 
04C1C:  MOVLW  6D
04C1E:  MOVLB  0
04C20:  MOVWF  xE1
04C22:  MOVLB  6
....................          } 
....................          if(axv==1) 
04C24:  DECFSZ xF0,W
04C26:  BRA    4C30
....................          { 
....................             UniVel[0]="m/s"; 
04C28:  MOVLW  6D
04C2A:  MOVLB  0
04C2C:  MOVWF  xE5
04C2E:  MOVLB  6
....................          } 
....................          if(axv==2) 
04C30:  MOVF   xF0,W
04C32:  SUBLW  02
04C34:  BNZ   4C3E
....................          { 
....................             UniVel[0]="km/h"; 
04C36:  MOVLW  6B
04C38:  MOVLB  0
04C3A:  MOVWF  xE5
04C3C:  MOVLB  6
....................          } 
....................          if(axv==3) 
04C3E:  MOVF   xF0,W
04C40:  SUBLW  03
04C42:  BNZ   4C4C
....................          { 
....................             UniVel[0]="Nud"; 
04C44:  MOVLW  4E
04C46:  MOVLB  0
04C48:  MOVWF  xE5
04C4A:  MOVLB  6
....................          } 
....................           
....................           
....................           
....................     
....................    
....................     
....................    int16 auxi; 
....................    int8 type,z; 
....................    int8 string[10]; 
....................    int16 tt; 
....................    int32 pp; 
....................    char tprint [15]; 
....................    char pprint [15]; 
....................    char ttt[10]; 
....................    char ppp[10]; 
....................       char temp[] = "T:"; 
04C4C:  MOVLW  54
04C4E:  MOVLB  7
04C50:  MOVWF  x37
04C52:  MOVLW  3A
04C54:  MOVWF  x38
04C56:  CLRF   x39
....................       char pres[] = "P:"; 
04C58:  MOVLW  50
04C5A:  MOVWF  x3A
04C5C:  MOVLW  3A
04C5E:  MOVWF  x3B
04C60:  CLRF   x3C
....................        
....................    for (z=0;z<15;z++) 
04C62:  MOVLB  6
04C64:  CLRF   xF4
04C66:  MOVF   xF4,W
04C68:  SUBLW  0E
04C6A:  BNC   4C90
....................       { 
....................          tprint[z]=0; 
04C6C:  CLRF   03
04C6E:  MOVF   xF4,W
04C70:  ADDLW  05
04C72:  MOVWF  FE9
04C74:  MOVLW  07
04C76:  ADDWFC 03,W
04C78:  MOVWF  FEA
04C7A:  CLRF   FEF
....................          pprint[z]=0; 
04C7C:  CLRF   03
04C7E:  MOVF   xF4,W
04C80:  ADDLW  14
04C82:  MOVWF  FE9
04C84:  MOVLW  07
04C86:  ADDWFC 03,W
04C88:  MOVWF  FEA
04C8A:  CLRF   FEF
....................       } 
04C8C:  INCF   xF4,F
04C8E:  BRA    4C66
....................    //firstrun = read_eeprom(0x00);       
....................    
....................  
....................       draw_sect(); 
04C90:  MOVLB  7
04C92:  CLRF   x3D
04C94:  MOVLB  0
04C96:  CALL   11AA
....................    while (1) 
....................    { 
....................       
....................        
....................        
....................        
....................       if (firstrun==71) 
04C9A:  MOVF   40,W
04C9C:  SUBLW  47
04C9E:  BNZ   4CF2
....................       { 
....................          glcd_loadscreen(); 
04CA0:  GOTO   18E2
....................          glcd_showlogo(); 
04CA4:  GOTO   1ACA
....................          delay_ms(1500); 
04CA8:  MOVLW  06
04CAA:  MOVLB  7
04CAC:  MOVWF  x3D
04CAE:  MOVLW  FA
04CB0:  MOVWF  x3E
04CB2:  MOVLB  0
04CB4:  GOTO   1B7C
04CB8:  MOVLB  7
04CBA:  DECFSZ x3D,F
04CBC:  BRA    4CAE
....................          menu_mainmenu(); 
04CBE:  MOVLB  0
04CC0:  CALL   3A72
....................          firstrun = 0; 
04CC4:  CLRF   40
....................          write_eeprom(0x00, firstrun); 
04CC6:  CLRF   FAA
04CC8:  CLRF   FA9
04CCA:  MOVFF  40,FA8
04CCE:  BCF    FA6.6
04CD0:  BCF    FA6.7
04CD2:  BSF    FA6.2
04CD4:  MOVF   FF2,W
04CD6:  MOVWF  00
04CD8:  BCF    FF2.7
04CDA:  MOVLB  F
04CDC:  MOVLW  55
04CDE:  MOVWF  FA7
04CE0:  MOVLW  AA
04CE2:  MOVWF  FA7
04CE4:  BSF    FA6.1
04CE6:  BTFSC  FA6.1
04CE8:  BRA    4CE6
04CEA:  BCF    FA6.2
04CEC:  MOVF   00,W
04CEE:  IORWF  FF2,F
04CF0:  MOVLB  0
....................       } 
....................        
....................       if (config==1) 
04CF2:  DECFSZ 3F,W
04CF4:  BRA    4F22
....................       { 
....................          
....................          
....................          
....................          
....................          
....................          menu_mainmenu(); 
04CF6:  CALL   3A72
....................          if(UniTemp[1]=="C") 
04CFA:  MOVLW  00
04CFC:  MOVWF  02
04CFE:  MOVLW  0C
04D00:  MOVWF  01
04D02:  MOVLW  E4
04D04:  MOVWF  00
04D06:  CLRF   03
04D08:  MOVF   00,W
04D0A:  SUBWF  xDF,W
04D0C:  BNZ   4D48
04D0E:  MOVF   01,F
04D10:  BNZ   4D48
04D12:  MOVF   02,F
04D14:  BNZ   4D48
04D16:  MOVF   03,F
04D18:  BNZ   4D48
....................          { 
....................             write_eeprom(0x01, 1); 
04D1A:  CLRF   FAA
04D1C:  MOVLW  01
04D1E:  MOVWF  FA9
04D20:  MOVWF  FA8
04D22:  BCF    FA6.6
04D24:  BCF    FA6.7
04D26:  BSF    FA6.2
04D28:  MOVF   FF2,W
04D2A:  MOVWF  00
04D2C:  BCF    FF2.7
04D2E:  MOVLB  F
04D30:  MOVLW  55
04D32:  MOVWF  FA7
04D34:  MOVLW  AA
04D36:  MOVWF  FA7
04D38:  BSF    FA6.1
04D3A:  BTFSC  FA6.1
04D3C:  BRA    4D3A
04D3E:  BCF    FA6.2
04D40:  MOVF   00,W
04D42:  IORWF  FF2,F
....................          } 
....................          else if(UniTemp[1]=="F") 
04D44:  BRA    4D94
04D46:  MOVLB  0
04D48:  MOVLW  00
04D4A:  MOVWF  02
04D4C:  MOVLW  0C
04D4E:  MOVWF  01
04D50:  MOVLW  E6
04D52:  MOVWF  00
04D54:  CLRF   03
04D56:  MOVF   00,W
04D58:  SUBWF  xDF,W
04D5A:  BNZ   4D96
04D5C:  MOVF   01,F
04D5E:  BNZ   4D96
04D60:  MOVF   02,F
04D62:  BNZ   4D96
04D64:  MOVF   03,F
04D66:  BNZ   4D96
....................          { 
....................             write_eeprom(0x01, 2); 
04D68:  CLRF   FAA
04D6A:  MOVLW  01
04D6C:  MOVWF  FA9
04D6E:  MOVLW  02
04D70:  MOVWF  FA8
04D72:  BCF    FA6.6
04D74:  BCF    FA6.7
04D76:  BSF    FA6.2
04D78:  MOVF   FF2,W
04D7A:  MOVWF  00
04D7C:  BCF    FF2.7
04D7E:  MOVLB  F
04D80:  MOVLW  55
04D82:  MOVWF  FA7
04D84:  MOVLW  AA
04D86:  MOVWF  FA7
04D88:  BSF    FA6.1
04D8A:  BTFSC  FA6.1
04D8C:  BRA    4D8A
04D8E:  BCF    FA6.2
04D90:  MOVF   00,W
04D92:  IORWF  FF2,F
04D94:  MOVLB  0
....................          } 
....................          if(UniPres[1]=="P") 
04D96:  MOVLW  00
04D98:  MOVWF  02
04D9A:  MOVLW  0C
04D9C:  MOVWF  01
04D9E:  MOVLW  E8
04DA0:  MOVWF  00
04DA2:  CLRF   03
04DA4:  MOVF   00,W
04DA6:  SUBWF  xE2,W
04DA8:  BNZ   4DE6
04DAA:  MOVF   01,F
04DAC:  BNZ   4DE6
04DAE:  MOVF   02,F
04DB0:  BNZ   4DE6
04DB2:  MOVF   03,F
04DB4:  BNZ   4DE6
....................          { 
....................             write_eeprom(0x02, 1); 
04DB6:  CLRF   FAA
04DB8:  MOVLW  02
04DBA:  MOVWF  FA9
04DBC:  MOVLW  01
04DBE:  MOVWF  FA8
04DC0:  BCF    FA6.6
04DC2:  BCF    FA6.7
04DC4:  BSF    FA6.2
04DC6:  MOVF   FF2,W
04DC8:  MOVWF  00
04DCA:  BCF    FF2.7
04DCC:  MOVLB  F
04DCE:  MOVLW  55
04DD0:  MOVWF  FA7
04DD2:  MOVLW  AA
04DD4:  MOVWF  FA7
04DD6:  BSF    FA6.1
04DD8:  BTFSC  FA6.1
04DDA:  BRA    4DD8
04DDC:  BCF    FA6.2
04DDE:  MOVF   00,W
04DE0:  IORWF  FF2,F
....................          } 
....................          else if(UniPres[1]=="m") 
04DE2:  BRA    4E30
04DE4:  MOVLB  0
04DE6:  MOVLW  00
04DE8:  MOVWF  02
04DEA:  MOVLW  0C
04DEC:  MOVWF  01
04DEE:  MOVLW  EA
04DF0:  MOVWF  00
04DF2:  CLRF   03
04DF4:  MOVF   00,W
04DF6:  SUBWF  xE2,W
04DF8:  BNZ   4E32
04DFA:  MOVF   01,F
04DFC:  BNZ   4E32
04DFE:  MOVF   02,F
04E00:  BNZ   4E32
04E02:  MOVF   03,F
04E04:  BNZ   4E32
....................          { 
....................             write_eeprom(0x02, 2); 
04E06:  CLRF   FAA
04E08:  MOVLW  02
04E0A:  MOVWF  FA9
04E0C:  MOVWF  FA8
04E0E:  BCF    FA6.6
04E10:  BCF    FA6.7
04E12:  BSF    FA6.2
04E14:  MOVF   FF2,W
04E16:  MOVWF  00
04E18:  BCF    FF2.7
04E1A:  MOVLB  F
04E1C:  MOVLW  55
04E1E:  MOVWF  FA7
04E20:  MOVLW  AA
04E22:  MOVWF  FA7
04E24:  BSF    FA6.1
04E26:  BTFSC  FA6.1
04E28:  BRA    4E26
04E2A:  BCF    FA6.2
04E2C:  MOVF   00,W
04E2E:  IORWF  FF2,F
04E30:  MOVLB  0
....................          } 
....................          if(UniVel[1]=="m") 
04E32:  MOVLW  00
04E34:  MOVWF  02
04E36:  MOVLW  0C
04E38:  MOVWF  01
04E3A:  MOVLW  EC
04E3C:  MOVWF  00
04E3E:  CLRF   03
04E40:  MOVF   00,W
04E42:  SUBWF  xE6,W
04E44:  BNZ   4E82
04E46:  MOVF   01,F
04E48:  BNZ   4E82
04E4A:  MOVF   02,F
04E4C:  BNZ   4E82
04E4E:  MOVF   03,F
04E50:  BNZ   4E82
....................          { 
....................             write_eeprom(0x03, 1); 
04E52:  CLRF   FAA
04E54:  MOVLW  03
04E56:  MOVWF  FA9
04E58:  MOVLW  01
04E5A:  MOVWF  FA8
04E5C:  BCF    FA6.6
04E5E:  BCF    FA6.7
04E60:  BSF    FA6.2
04E62:  MOVF   FF2,W
04E64:  MOVWF  00
04E66:  BCF    FF2.7
04E68:  MOVLB  F
04E6A:  MOVLW  55
04E6C:  MOVWF  FA7
04E6E:  MOVLW  AA
04E70:  MOVWF  FA7
04E72:  BSF    FA6.1
04E74:  BTFSC  FA6.1
04E76:  BRA    4E74
04E78:  BCF    FA6.2
04E7A:  MOVF   00,W
04E7C:  IORWF  FF2,F
....................          } 
....................          else if(UniVel[1]=="k") 
04E7E:  BRA    4F1C
04E80:  MOVLB  0
04E82:  MOVLW  00
04E84:  MOVWF  02
04E86:  MOVLW  0C
04E88:  MOVWF  01
04E8A:  MOVLW  EE
04E8C:  MOVWF  00
04E8E:  CLRF   03
04E90:  MOVF   00,W
04E92:  SUBWF  xE6,W
04E94:  BNZ   4ED2
04E96:  MOVF   01,F
04E98:  BNZ   4ED2
04E9A:  MOVF   02,F
04E9C:  BNZ   4ED2
04E9E:  MOVF   03,F
04EA0:  BNZ   4ED2
....................          { 
....................             write_eeprom(0x03, 2); 
04EA2:  CLRF   FAA
04EA4:  MOVLW  03
04EA6:  MOVWF  FA9
04EA8:  MOVLW  02
04EAA:  MOVWF  FA8
04EAC:  BCF    FA6.6
04EAE:  BCF    FA6.7
04EB0:  BSF    FA6.2
04EB2:  MOVF   FF2,W
04EB4:  MOVWF  00
04EB6:  BCF    FF2.7
04EB8:  MOVLB  F
04EBA:  MOVLW  55
04EBC:  MOVWF  FA7
04EBE:  MOVLW  AA
04EC0:  MOVWF  FA7
04EC2:  BSF    FA6.1
04EC4:  BTFSC  FA6.1
04EC6:  BRA    4EC4
04EC8:  BCF    FA6.2
04ECA:  MOVF   00,W
04ECC:  IORWF  FF2,F
....................          } 
....................          else if(UniVel[1]=="N") 
04ECE:  BRA    4F1C
04ED0:  MOVLB  0
04ED2:  MOVLW  00
04ED4:  MOVWF  02
04ED6:  MOVLW  0C
04ED8:  MOVWF  01
04EDA:  MOVLW  F0
04EDC:  MOVWF  00
04EDE:  CLRF   03
04EE0:  MOVF   00,W
04EE2:  SUBWF  xE6,W
04EE4:  BNZ   4F1E
04EE6:  MOVF   01,F
04EE8:  BNZ   4F1E
04EEA:  MOVF   02,F
04EEC:  BNZ   4F1E
04EEE:  MOVF   03,F
04EF0:  BNZ   4F1E
....................          { 
....................             write_eeprom(0x03, 3); 
04EF2:  CLRF   FAA
04EF4:  MOVLW  03
04EF6:  MOVWF  FA9
04EF8:  MOVWF  FA8
04EFA:  BCF    FA6.6
04EFC:  BCF    FA6.7
04EFE:  BSF    FA6.2
04F00:  MOVF   FF2,W
04F02:  MOVWF  00
04F04:  BCF    FF2.7
04F06:  MOVLB  F
04F08:  MOVLW  55
04F0A:  MOVWF  FA7
04F0C:  MOVLW  AA
04F0E:  MOVWF  FA7
04F10:  BSF    FA6.1
04F12:  BTFSC  FA6.1
04F14:  BRA    4F12
04F16:  BCF    FA6.2
04F18:  MOVF   00,W
04F1A:  IORWF  FF2,F
04F1C:  MOVLB  0
....................          } 
....................           
....................          
....................           
....................          pressed=0; 
04F1E:  CLRF   3E
....................          config=0; 
04F20:  CLRF   3F
....................       } 
....................        
....................       if (try==1) 
04F22:  MOVLB  6
04F24:  DECFSZ xEB,W
04F26:  BRA    4F2E
....................       { 
....................           
....................                try=0; 
04F28:  CLRF   xEB
....................                output_toggle(PIN_C2); 
04F2A:  BCF    F94.2
04F2C:  BTG    F8B.2
....................       } 
....................        
....................       while(bkbhit)  
....................       { 
04F2E:  MOVF   3B,W
04F30:  SUBWF  3A,W
04F32:  BTFSC  FD8.2
04F34:  BRA    51A6
....................          auxi = bgetc(); 
04F36:  MOVLB  0
04F38:  GOTO   3AD0
04F3C:  MOVLB  6
04F3E:  CLRF   xF2
04F40:  MOVFF  01,6F1
....................          if (auxi==0x54) 
04F44:  MOVF   xF1,W
04F46:  SUBLW  54
04F48:  BNZ   4F70
04F4A:  MOVF   xF2,F
04F4C:  BNZ   4F70
....................          { 
....................             type=1; 
04F4E:  MOVLW  01
04F50:  MOVWF  xF3
....................             for(i=0;i<15;i++) 
04F52:  CLRF   3C
04F54:  MOVF   3C,W
04F56:  SUBLW  0E
04F58:  BNC   4F6E
....................             {                    
....................                string[i]=0x00;                           
04F5A:  CLRF   03
04F5C:  MOVF   3C,W
04F5E:  ADDLW  F5
04F60:  MOVWF  FE9
04F62:  MOVLW  06
04F64:  ADDWFC 03,W
04F66:  MOVWF  FEA
04F68:  CLRF   FEF
....................             } 
04F6A:  INCF   3C,F
04F6C:  BRA    4F54
....................             i = 0; 
04F6E:  CLRF   3C
....................          } 
....................          if (auxi==0x50) 
04F70:  MOVF   xF1,W
04F72:  SUBLW  50
04F74:  BNZ   4F9C
04F76:  MOVF   xF2,F
04F78:  BNZ   4F9C
....................          { 
....................             type=2; 
04F7A:  MOVLW  02
04F7C:  MOVWF  xF3
....................             for(i=0;i<15;i++) 
04F7E:  CLRF   3C
04F80:  MOVF   3C,W
04F82:  SUBLW  0E
04F84:  BNC   4F9A
....................             {                    
....................                string[i]=0x00;                           
04F86:  CLRF   03
04F88:  MOVF   3C,W
04F8A:  ADDLW  F5
04F8C:  MOVWF  FE9
04F8E:  MOVLW  06
04F90:  ADDWFC 03,W
04F92:  MOVWF  FEA
04F94:  CLRF   FEF
....................             } 
04F96:  INCF   3C,F
04F98:  BRA    4F80
....................             i = 0; 
04F9A:  CLRF   3C
....................          } 
....................          if (auxi!=0x0D) 
04F9C:  MOVF   xF1,W
04F9E:  SUBLW  0D
04FA0:  BNZ   4FA6
04FA2:  MOVF   xF2,F
04FA4:  BZ    4FA6
....................          { 
....................              
....................          } 
....................          if (type==1)      //Temperatura 
04FA6:  DECFSZ xF3,W
04FA8:  BRA    5098
....................          { 
....................           
....................             if ((auxi!=0x0D)&&(auxi!=0x54)) 
04FAA:  MOVF   xF1,W
04FAC:  SUBLW  0D
04FAE:  BNZ   4FB4
04FB0:  MOVF   xF2,F
04FB2:  BZ    4FD2
04FB4:  MOVF   xF1,W
04FB6:  SUBLW  54
04FB8:  BNZ   4FBE
04FBA:  MOVF   xF2,F
04FBC:  BZ    4FD2
....................             { 
....................                string[i] = auxi; 
04FBE:  CLRF   03
04FC0:  MOVF   3C,W
04FC2:  ADDLW  F5
04FC4:  MOVWF  FE9
04FC6:  MOVLW  06
04FC8:  ADDWFC 03,W
04FCA:  MOVWF  FEA
04FCC:  MOVFF  6F1,FEF
....................                i++; 
04FD0:  INCF   3C,F
....................             } 
....................             if (auxi==0x0D) 
04FD2:  MOVF   xF1,W
04FD4:  SUBLW  0D
04FD6:  BNZ   5098
04FD8:  MOVF   xF2,F
04FDA:  BNZ   5098
....................             { 
....................                str_init(tprint); 
04FDC:  MOVLW  07
04FDE:  MOVLB  7
04FE0:  MOVWF  x3E
04FE2:  MOVLW  05
04FE4:  MOVWF  x3D
04FE6:  MOVLB  0
04FE8:  CALL   3AFC
....................                tt = atol(string);   
04FEC:  MOVLW  06
04FEE:  MOVLB  7
04FF0:  MOVWF  x3E
04FF2:  MOVLW  F5
04FF4:  MOVWF  x3D
04FF6:  MOVLB  0
04FF8:  GOTO   3B1E
04FFC:  MOVFF  02,700
05000:  MOVFF  01,6FF
....................                sprintf(ttt,"%3.1w",tt); 
05004:  MOVLW  07
05006:  MOVLB  6
05008:  MOVWF  xED
0500A:  MOVLW  23
0500C:  MOVWF  xEC
0500E:  MOVLW  03
05010:  MOVWF  FE9
05012:  MOVLB  7
05014:  CLRF   x40
05016:  CLRF   x3F
05018:  MOVFF  700,73E
0501C:  MOVFF  6FF,73D
05020:  MOVLW  01
05022:  MOVWF  x41
05024:  MOVLB  0
05026:  CALL   3DC8
....................                strcat(tprint,temp); 
0502A:  MOVLW  07
0502C:  MOVLB  7
0502E:  MOVWF  x3E
05030:  MOVLW  05
05032:  MOVWF  x3D
05034:  MOVLW  07
05036:  MOVWF  x40
05038:  MOVLW  37
0503A:  MOVWF  x3F
0503C:  MOVLB  0
0503E:  CALL   3EAA
....................                strcat(tprint,ttt); 
05042:  MOVLW  07
05044:  MOVLB  7
05046:  MOVWF  x3E
05048:  MOVLW  05
0504A:  MOVWF  x3D
0504C:  MOVLW  07
0504E:  MOVWF  x40
05050:  MOVLW  23
05052:  MOVWF  x3F
05054:  MOVLB  0
05056:  CALL   3EAA
....................                strcat(tprint,UniTemp); 
0505A:  MOVLW  07
0505C:  MOVLB  7
0505E:  MOVWF  x3E
05060:  MOVLW  05
05062:  MOVWF  x3D
05064:  CLRF   x40
05066:  MOVLW  DE
05068:  MOVWF  x3F
0506A:  MOVLB  0
0506C:  CALL   3EAA
....................                 draw_sect(); 
05070:  MOVLB  7
05072:  CLRF   x3D
05074:  MOVLB  0
05076:  CALL   11AA
....................                glcd_text_sec(1, 1, tprint, OFF); 
0507A:  MOVLW  01
0507C:  MOVLB  7
0507E:  MOVWF  x3D
05080:  MOVWF  x3E
05082:  MOVLW  07
05084:  MOVWF  x40
05086:  MOVLW  05
05088:  MOVWF  x3F
0508A:  CLRF   x41
0508C:  MOVLB  0
0508E:  CALL   3F1C
....................                glcd_update(); 
05092:  CALL   0D8C
05096:  MOVLB  6
....................                 
....................             } 
....................          } 
....................          if (type==2)      //Presion 
05098:  MOVF   xF3,W
0509A:  SUBLW  02
0509C:  BTFSS  FD8.2
0509E:  BRA    519C
....................          { 
....................             if ((auxi!=0x0D)&&(auxi!=0x50)) 
050A0:  MOVF   xF1,W
050A2:  SUBLW  0D
050A4:  BNZ   50AA
050A6:  MOVF   xF2,F
050A8:  BZ    50C8
050AA:  MOVF   xF1,W
050AC:  SUBLW  50
050AE:  BNZ   50B4
050B0:  MOVF   xF2,F
050B2:  BZ    50C8
....................             { 
....................                string[i] = auxi; 
050B4:  CLRF   03
050B6:  MOVF   3C,W
050B8:  ADDLW  F5
050BA:  MOVWF  FE9
050BC:  MOVLW  06
050BE:  ADDWFC 03,W
050C0:  MOVWF  FEA
050C2:  MOVFF  6F1,FEF
....................                i++; 
050C6:  INCF   3C,F
....................             } 
....................             if (auxi==0x0D) 
050C8:  MOVF   xF1,W
050CA:  SUBLW  0D
050CC:  BNZ   519C
050CE:  MOVF   xF2,F
050D0:  BNZ   519C
....................             { 
....................                str_init(pprint); 
050D2:  MOVLW  07
050D4:  MOVLB  7
050D6:  MOVWF  x3E
050D8:  MOVLW  14
050DA:  MOVWF  x3D
050DC:  MOVLB  0
050DE:  CALL   3AFC
....................                pp = atoi32(string); 
050E2:  MOVLW  06
050E4:  MOVLB  7
050E6:  MOVWF  x3E
050E8:  MOVLW  F5
050EA:  MOVWF  x3D
050EC:  MOVLB  0
050EE:  GOTO   4012
050F2:  MOVFF  03,704
050F6:  MOVFF  02,703
050FA:  MOVFF  01,702
050FE:  MOVFF  00,701
....................                sprintf(ppp,"%3.1w",pp); 
05102:  MOVLW  07
05104:  MOVLB  6
05106:  MOVWF  xED
05108:  MOVLW  2D
0510A:  MOVWF  xEC
0510C:  MOVLW  03
0510E:  MOVWF  FE9
05110:  MOVFF  704,740
05114:  MOVFF  703,73F
05118:  MOVFF  702,73E
0511C:  MOVFF  701,73D
05120:  MOVLW  01
05122:  MOVLB  7
05124:  MOVWF  x41
05126:  MOVLB  0
05128:  CALL   3DC8
....................                strcat(pprint,pres); 
0512C:  MOVLW  07
0512E:  MOVLB  7
05130:  MOVWF  x3E
05132:  MOVLW  14
05134:  MOVWF  x3D
05136:  MOVLW  07
05138:  MOVWF  x40
0513A:  MOVLW  3A
0513C:  MOVWF  x3F
0513E:  MOVLB  0
05140:  CALL   3EAA
....................                strcat(pprint,ppp); 
05144:  MOVLW  07
05146:  MOVLB  7
05148:  MOVWF  x3E
0514A:  MOVLW  14
0514C:  MOVWF  x3D
0514E:  MOVLW  07
05150:  MOVWF  x40
05152:  MOVLW  2D
05154:  MOVWF  x3F
05156:  MOVLB  0
05158:  CALL   3EAA
....................                strcat(pprint,UniPres);   
0515C:  MOVLW  07
0515E:  MOVLB  7
05160:  MOVWF  x3E
05162:  MOVLW  14
05164:  MOVWF  x3D
05166:  CLRF   x40
05168:  MOVLW  E1
0516A:  MOVWF  x3F
0516C:  MOVLB  0
0516E:  CALL   3EAA
....................                 draw_sect(); 
05172:  MOVLB  7
05174:  CLRF   x3D
05176:  MOVLB  0
05178:  CALL   11AA
....................                glcd_text_sec(1, 2, pprint, OFF); 
0517C:  MOVLW  01
0517E:  MOVLB  7
05180:  MOVWF  x3D
05182:  MOVLW  02
05184:  MOVWF  x3E
05186:  MOVLW  07
05188:  MOVWF  x40
0518A:  MOVLW  14
0518C:  MOVWF  x3F
0518E:  CLRF   x41
05190:  MOVLB  0
05192:  CALL   3F1C
....................                glcd_update(); 
05196:  CALL   0D8C
0519A:  MOVLB  6
....................             } 
....................          } 
....................           
....................          glcd_update(); 
0519C:  MOVLB  0
0519E:  CALL   0D8C
....................          //END KBHIT 
....................       } 
051A2:  MOVLB  6
051A4:  BRA    4F2E
....................        
....................        
....................       glcd_update(); 
051A6:  MOVLB  0
051A8:  CALL   0D8C
....................       //ENDWHILE 
....................    } 
051AC:  BRA    4C9A
.................... //ENDMAIN 
.................... } 
051AE:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV21 NOWDT WDT128
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
