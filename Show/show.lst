CCS PCH C Compiler, Version 4.104, 5967               03-mar-12 21:06

               Filename: C:\Users\MrDarkness\X-Weather\Show\show.lst

               ROM used: 3126 bytes (5%)
                         Largest free fragment is 62410
               RAM used: 1038 (31%) at main() level
                         1085 (33%) worst case
               Stack:    4 locations

*
00000:  GOTO   0BAE
.................... #include "show.h" 
.................... #include <18F4680.h> 
.................... //////// Standard Header file for the PIC18F4680 device //////////////// 
.................... #device PIC18F4680 
.................... #list 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
.................... //#FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BBSIZ1K                  //1K words Boot Block size 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(crystal=8000000) 
*
003FC:  MOVLW  04
003FE:  MOVWF  FEA
00400:  MOVLW  19
00402:  MOVWF  FE9
00404:  MOVF   FEF,W
00406:  BZ    0422
00408:  MOVLW  02
0040A:  MOVWF  01
0040C:  CLRF   00
0040E:  DECFSZ 00,F
00410:  BRA    040E
00412:  DECFSZ 01,F
00414:  BRA    040C
00416:  MOVLW  97
00418:  MOVWF  00
0041A:  DECFSZ 00,F
0041C:  BRA    041A
0041E:  DECFSZ FEF,F
00420:  BRA    0408
00422:  GOTO   0BF4 (RETURN)
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,errors) 
....................  
....................  
.................... /*DEFINICIONES*/   
....................  
....................  
.................... #define FAST_GLCD 
....................  
....................  
....................  
....................  
....................  
.................... /*FIN**DEFINICIONES*/   
....................  
....................  
.................... /****/ 
....................  
....................  
.................... /*VARIABLES**GLOBALES*/ 
....................  
....................  
....................  
....................  
.................... /*FIN**VARIBLES**GLOBALES*/ 
....................  
....................  
....................  
.................... /****/ 
....................  
....................  
.................... /**INCLUDES**/ 
....................  
.................... #include "HDM64GS12.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B1   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B0   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B3   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B4   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_B5   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(int8 x, int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    int8 left[512]; 
....................    int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
00354:  BCF    F93.5
00356:  BSF    F8A.5
....................    output_low(GLCD_E); 
00358:  BCF    F93.4
0035A:  BCF    F8A.4
....................    output_low(GLCD_CS1); 
0035C:  BCF    F93.1
0035E:  BCF    F8A.1
....................    output_low(GLCD_CS2); 
00360:  BCF    F93.0
00362:  BCF    F8A.0
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
00364:  BCF    F93.2
00366:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
00368:  MOVLB  4
0036A:  CLRF   x21
0036C:  MOVLW  C0
0036E:  MOVWF  x22
00370:  MOVLB  0
00372:  RCALL  0200
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
00374:  MOVLW  01
00376:  MOVLB  4
00378:  MOVWF  x21
0037A:  MOVLW  C0
0037C:  MOVWF  x22
0037E:  MOVLB  0
00380:  RCALL  0200
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
00382:  MOVLB  4
00384:  CLRF   x21
00386:  MOVLW  40
00388:  MOVWF  x22
0038A:  MOVLB  0
0038C:  RCALL  0200
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
0038E:  MOVLW  01
00390:  MOVLB  4
00392:  MOVWF  x21
00394:  MOVLW  40
00396:  MOVWF  x22
00398:  MOVLB  0
0039A:  RCALL  0200
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
0039C:  MOVLB  4
0039E:  CLRF   x21
003A0:  MOVLW  B8
003A2:  MOVWF  x22
003A4:  MOVLB  0
003A6:  RCALL  0200
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
003A8:  MOVLW  01
003AA:  MOVLB  4
003AC:  MOVWF  x21
003AE:  MOVLW  B8
003B0:  MOVWF  x22
003B2:  MOVLB  0
003B4:  RCALL  0200
....................  
....................    if(mode == ON) 
003B6:  MOVLB  4
003B8:  DECFSZ x19,W
003BA:  BRA    03D8
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
003BC:  CLRF   x21
003BE:  MOVLW  3F
003C0:  MOVWF  x22
003C2:  MOVLB  0
003C4:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
003C6:  MOVLW  01
003C8:  MOVLB  4
003CA:  MOVWF  x21
003CC:  MOVLW  3F
003CE:  MOVWF  x22
003D0:  MOVLB  0
003D2:  RCALL  0200
....................    } 
....................    else 
003D4:  BRA    03F0
003D6:  MOVLB  4
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
003D8:  CLRF   x21
003DA:  MOVLW  3E
003DC:  MOVWF  x22
003DE:  MOVLB  0
003E0:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
003E2:  MOVLW  01
003E4:  MOVLB  4
003E6:  MOVWF  x21
003E8:  MOVLW  3E
003EA:  MOVWF  x22
003EC:  MOVLB  0
003EE:  RCALL  0200
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
003F0:  MOVLB  4
003F2:  CLRF   x1A
003F4:  MOVLB  0
003F6:  BRA    0240
....................  
....................    #ifdef FAST_GLCD 
....................    glcd_update(); 
003F8:  RCALL  029C
....................    #endif 
.................... } 
003FA:  RETLW  00
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    int8 i, j; 
....................    int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
*
0029C:  MOVLB  4
0029E:  CLRF   x1D
002A0:  MOVLW  06
002A2:  MOVWF  x1C
....................    p2 = displayData.right; 
002A4:  MOVLW  02
002A6:  MOVWF  x1F
002A8:  MOVLW  06
002AA:  MOVWF  x1E
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
002AC:  CLRF   x1A
002AE:  MOVF   x1A,W
002B0:  SUBLW  07
002B2:  BNC   0350
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
002B4:  BCF    F93.2
002B6:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
002B8:  CLRF   x21
002BA:  MOVLW  40
002BC:  MOVWF  x22
002BE:  MOVLB  0
002C0:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
002C2:  MOVLW  01
002C4:  MOVLB  4
002C6:  MOVWF  x21
002C8:  MOVLW  40
002CA:  MOVWF  x22
002CC:  MOVLB  0
002CE:  RCALL  0200
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
002D0:  MOVLB  4
002D2:  MOVF   x1A,W
002D4:  IORLW  B8
002D6:  MOVWF  x20
002D8:  CLRF   x21
002DA:  MOVWF  x22
002DC:  MOVLB  0
002DE:  RCALL  0200
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
002E0:  MOVLB  4
002E2:  MOVF   x1A,W
002E4:  IORLW  B8
002E6:  MOVWF  x20
002E8:  MOVLW  01
002EA:  MOVWF  x21
002EC:  MOVFF  420,422
002F0:  MOVLB  0
002F2:  RCALL  0200
....................       output_high(GLCD_DI);                     // Set for data 
002F4:  BCF    F93.2
002F6:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
002F8:  MOVLB  4
002FA:  CLRF   x1B
002FC:  MOVF   x1B,W
002FE:  SUBLW  3F
00300:  BNC   034C
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
00302:  MOVFF  41D,03
00306:  MOVF   x1C,W
00308:  INCF   x1C,F
0030A:  BTFSC  FD8.2
0030C:  INCF   x1D,F
0030E:  MOVWF  FE9
00310:  MOVFF  03,FEA
00314:  MOVFF  FEF,420
00318:  CLRF   x21
0031A:  MOVFF  420,422
0031E:  MOVLB  0
00320:  RCALL  0200
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
00322:  MOVLB  4
00324:  MOVFF  41F,03
00328:  MOVF   x1E,W
0032A:  INCF   x1E,F
0032C:  BTFSC  FD8.2
0032E:  INCF   x1F,F
00330:  MOVWF  FE9
00332:  MOVFF  03,FEA
00336:  MOVFF  FEF,420
0033A:  MOVLW  01
0033C:  MOVWF  x21
0033E:  MOVFF  420,422
00342:  MOVLB  0
00344:  RCALL  0200
....................       } 
00346:  MOVLB  4
00348:  INCF   x1B,F
0034A:  BRA    02FC
....................    } 
0034C:  INCF   x1A,F
0034E:  BRA    02AE
.................... } 
00350:  MOVLB  0
00352:  RETLW  00
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(int8 x, int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8* p; 
....................    int16 temp; 
....................    temp =  y/8; 
*
00426:  MOVLB  4
00428:  CLRF   x3A
0042A:  RRCF   x35,W
0042C:  MOVWF  x39
0042E:  RRCF   x39,F
00430:  RRCF   x39,F
00432:  MOVLW  1F
00434:  ANDWF  x39,F
....................    temp *= 64; 
00436:  RLCF   x39,F
00438:  RLCF   x3A,F
0043A:  RLCF   x39,F
0043C:  RLCF   x3A,F
0043E:  RLCF   x39,F
00440:  RLCF   x3A,F
00442:  RLCF   x39,F
00444:  RLCF   x3A,F
00446:  RLCF   x39,F
00448:  RLCF   x3A,F
0044A:  RLCF   x39,F
0044C:  RLCF   x3A,F
0044E:  MOVLW  C0
00450:  ANDWF  x39,F
....................    temp += x; 
00452:  MOVF   x34,W
00454:  ADDWF  x39,F
00456:  MOVLW  00
00458:  ADDWFC x3A,F
....................  
....................    if(x > 63) 
0045A:  MOVF   x34,W
0045C:  SUBLW  3F
0045E:  BC    047A
....................    { 
....................       p = displayData.right + temp - 64; 
00460:  MOVLW  06
00462:  ADDWF  x39,W
00464:  MOVWF  x3B
00466:  MOVLW  02
00468:  ADDWFC x3A,W
0046A:  MOVWF  x3C
0046C:  MOVLW  40
0046E:  SUBWF  x3B,W
00470:  MOVWF  x37
00472:  MOVLW  00
00474:  SUBWFB x3C,W
00476:  MOVWF  x38
....................    } 
....................    else 
00478:  BRA    0486
....................    { 
....................       p = displayData.left + temp; 
0047A:  MOVLW  06
0047C:  ADDWF  x39,W
0047E:  MOVWF  x37
00480:  MOVLW  00
00482:  ADDWFC x3A,W
00484:  MOVWF  x38
....................    } 
....................  
....................    if(color) 
00486:  MOVF   x36,F
00488:  BZ    04B4
....................    { 
....................       bit_set(*p, y%8); 
0048A:  MOVFF  438,03
0048E:  MOVFF  437,FE9
00492:  MOVFF  438,FEA
00496:  MOVF   x35,W
00498:  ANDLW  07
0049A:  MOVWF  x3B
0049C:  MOVLW  01
0049E:  MOVWF  00
004A0:  MOVF   x3B,W
004A2:  MOVWF  01
004A4:  BZ    04AE
004A6:  BCF    FD8.0
004A8:  RLCF   00,F
004AA:  DECFSZ 01,F
004AC:  BRA    04A6
004AE:  MOVF   00,W
004B0:  IORWF  FEF,F
....................    } 
....................    else 
004B2:  BRA    04DE
....................    { 
....................       bit_clear(*p, y%8); 
004B4:  MOVFF  438,03
004B8:  MOVFF  437,FE9
004BC:  MOVFF  438,FEA
004C0:  MOVF   x35,W
004C2:  ANDLW  07
004C4:  MOVWF  x3B
004C6:  MOVLW  01
004C8:  MOVWF  00
004CA:  MOVF   x3B,W
004CC:  MOVWF  01
004CE:  BZ    04D8
004D0:  BCF    FD8.0
004D2:  RLCF   00,F
004D4:  DECFSZ 01,F
004D6:  BRA    04D0
004D8:  MOVF   00,W
004DA:  XORLW  FF
004DC:  ANDWF  FEF,F
....................    } 
.................... } 
004DE:  MOVLB  0
004E0:  RETLW  00
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
....................    { 
....................       x -= 64; 
....................       side = GLCD_RIGHT; 
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
....................    output_high(GLCD_DI);                        // Set for data 
....................    glcd_readByte(side);                         // Need two reads to get data 
....................    data = glcd_readByte(side);                  //  at new address 
....................  
....................    if(color == ON) 
....................       bit_set(data, y%8);        // Turn the pixel on 
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
....................    glcd_writeByte(side, x);      // Set the horizontal address 
....................    output_high(GLCD_DI);         // Set for data 
....................    glcd_writeByte(side, data);   // Write the pixel data 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8  data; 
....................    int8  *p1, *p2; 
....................    int16 i; 
....................  
....................    p1 = displayData.left; 
*
00240:  MOVLB  4
00242:  CLRF   x1D
00244:  MOVLW  06
00246:  MOVWF  x1C
....................    p2 = displayData.right; 
00248:  MOVLW  02
0024A:  MOVWF  x1F
0024C:  MOVLW  06
0024E:  MOVWF  x1E
....................    data = 0xFF * color; 
00250:  MOVF   x1A,W
00252:  MULLW  FF
00254:  MOVFF  FF3,41B
....................  
....................    for(i=0; i<512; ++i) 
00258:  CLRF   x21
0025A:  CLRF   x20
0025C:  MOVF   x21,W
0025E:  SUBLW  01
00260:  BNC   0296
....................    { 
....................       *p1++ = data; 
00262:  MOVFF  41D,03
00266:  MOVF   x1C,W
00268:  INCF   x1C,F
0026A:  BTFSC  FD8.2
0026C:  INCF   x1D,F
0026E:  MOVWF  FE9
00270:  MOVFF  03,FEA
00274:  MOVFF  41B,FEF
....................       *p2++ = data; 
00278:  MOVFF  41F,03
0027C:  MOVF   x1E,W
0027E:  INCF   x1E,F
00280:  BTFSC  FD8.2
00282:  INCF   x1F,F
00284:  MOVWF  FE9
00286:  MOVFF  03,FEA
0028A:  MOVFF  41B,FEF
....................    } 
0028E:  INCF   x20,F
00290:  BTFSC  FD8.2
00292:  INCF   x21,F
00294:  BRA    025C
.................... } 
00296:  MOVLB  0
00298:  GOTO   03F8 (RETURN)
.................... #else 
.................... { 
....................    int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    if(side)                   // Choose which side to write to 
*
00200:  MOVLB  4
00202:  MOVF   x21,F
00204:  BZ    020C
....................       output_high(GLCD_CS2); 
00206:  BCF    F93.0
00208:  BSF    F8A.0
....................    else 
0020A:  BRA    0210
....................       output_high(GLCD_CS1); 
0020C:  BCF    F93.1
0020E:  BSF    F8A.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
00210:  BCF    F93.3
00212:  BCF    F8A.3
....................    output_d(data);            // Put the data on the port 
00214:  CLRF   F95
00216:  MOVFF  422,F8C
....................    delay_cycles(16); 
0021A:  MOVLW  05
0021C:  MOVWF  00
0021E:  DECFSZ 00,F
00220:  BRA    021E
....................    output_high(GLCD_E);       // Pulse the enable pin 
00222:  BCF    F93.4
00224:  BSF    F8A.4
....................    delay_cycles(80); 
00226:  MOVLW  1A
00228:  MOVWF  00
0022A:  DECFSZ 00,F
0022C:  BRA    022A
0022E:  NOP   
....................    output_low(GLCD_E); 
00230:  BCF    F93.4
00232:  BCF    F8A.4
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
00234:  BCF    F93.1
00236:  BCF    F8A.1
....................    output_low(GLCD_CS2); 
00238:  BCF    F93.0
0023A:  BCF    F8A.0
.................... } 
0023C:  MOVLB  0
0023E:  RETLW  00
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
....................    output_high(GLCD_RW);      // Set for reading 
....................  
....................    if(side)                   // Choose which side to write to 
....................       output_high(GLCD_CS2); 
....................    else 
....................       output_high(GLCD_CS1); 
....................  
....................    delay_cycles(16); 
....................    output_high(GLCD_E);       // Pulse the enable pin 
....................    delay_cycles(64); 
....................    data = input_d();          // Get the data from the display's output register 
....................    output_low(GLCD_E); 
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
....................    output_low(GLCD_CS2); 
....................    return data;               // Return the read data 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "graphics.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(int16 x1, int16 y1, int16 x2, int16 y2, int1 color) 
.................... #else 
.................... void glcd_line(int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... #endif 
.................... { 
*
004E2:  MOVLW  01
004E4:  MOVLB  4
004E6:  MOVWF  x2D
004E8:  MOVWF  x2E
004EA:  CLRF   x33
....................    int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
004EC:  MOVF   x24,W
004EE:  SUBWF  x26,W
004F0:  MOVWF  x34
004F2:  MOVF   x34,W
004F4:  BTFSS  x34.7
004F6:  BRA    04FE
004F8:  MOVLW  00
004FA:  BSF    FD8.0
004FC:  SUBFWB x34,W
004FE:  CLRF   03
00500:  MOVWF  x2B
00502:  MOVFF  03,42C
....................    dy = abs((signed int8)(y2 - y1)); 
00506:  MOVF   x25,W
00508:  SUBWF  x27,W
0050A:  MOVWF  x34
0050C:  MOVF   x34,W
0050E:  BTFSS  x34.7
00510:  BRA    0518
00512:  MOVLW  00
00514:  BSF    FD8.0
00516:  SUBFWB x34,W
00518:  CLRF   03
0051A:  MOVWF  x29
0051C:  MOVFF  03,42A
....................    #endif 
....................  
....................    if(x1 > x2) 
00520:  MOVF   x24,W
00522:  SUBWF  x26,W
00524:  BC    052A
....................       addx = -1; 
00526:  MOVLW  FF
00528:  MOVWF  x2D
....................    if(y1 > y2) 
0052A:  MOVF   x25,W
0052C:  SUBWF  x27,W
0052E:  BC    0534
....................       addy = -1; 
00530:  MOVLW  FF
00532:  MOVWF  x2E
....................  
....................    if(dx >= dy) 
00534:  MOVF   x2A,W
00536:  SUBWF  x2C,W
00538:  BNC   05B0
0053A:  BNZ   0542
0053C:  MOVF   x29,W
0053E:  SUBWF  x2B,W
00540:  BNC   05B0
....................    { 
....................       dy *= 2; 
00542:  BCF    FD8.0
00544:  RLCF   x29,F
00546:  RLCF   x2A,F
....................       P = dy - dx; 
00548:  MOVF   x2B,W
0054A:  SUBWF  x29,W
0054C:  MOVWF  00
0054E:  MOVF   x2C,W
00550:  SUBWFB x2A,W
00552:  MOVFF  00,42F
00556:  MOVWF  x30
....................       diff = P - dx; 
00558:  MOVF   x2B,W
0055A:  SUBWF  x2F,W
0055C:  MOVWF  x31
0055E:  MOVF   x2C,W
00560:  SUBWFB x30,W
00562:  MOVWF  x32
....................  
....................       for(; i<=dx; ++i) 
00564:  MOVF   x2C,F
00566:  BNZ   056E
00568:  MOVF   x33,W
0056A:  SUBWF  x2B,W
0056C:  BNC   05AE
....................       { 
....................          glcd_pixel(x1, y1, color); 
0056E:  MOVFF  424,434
00572:  MOVFF  425,435
00576:  MOVFF  428,436
0057A:  MOVLB  0
0057C:  RCALL  0426
....................  
....................          if(P < 0) 
0057E:  MOVLB  4
00580:  BTFSC  x30.7
00582:  BRA    0586
00584:  BRA    0596
....................          { 
....................             P  += dy; 
00586:  MOVF   x29,W
00588:  ADDWF  x2F,F
0058A:  MOVF   x2A,W
0058C:  ADDWFC x30,F
....................             x1 += addx; 
0058E:  MOVF   x2D,W
00590:  ADDWF  x24,W
00592:  MOVWF  x24
....................          } 
....................          else 
00594:  BRA    05AA
....................          { 
....................             P  += diff; 
00596:  MOVF   x31,W
00598:  ADDWF  x2F,F
0059A:  MOVF   x32,W
0059C:  ADDWFC x30,F
....................             x1 += addx; 
0059E:  MOVF   x2D,W
005A0:  ADDWF  x24,W
005A2:  MOVWF  x24
....................             y1 += addy; 
005A4:  MOVF   x2E,W
005A6:  ADDWF  x25,W
005A8:  MOVWF  x25
....................          } 
....................       } 
005AA:  INCF   x33,F
005AC:  BRA    0564
....................    } 
....................    else 
005AE:  BRA    061C
....................    { 
....................       dx *= 2; 
005B0:  BCF    FD8.0
005B2:  RLCF   x2B,F
005B4:  RLCF   x2C,F
....................       P = dx - dy; 
005B6:  MOVF   x29,W
005B8:  SUBWF  x2B,W
005BA:  MOVWF  00
005BC:  MOVF   x2A,W
005BE:  SUBWFB x2C,W
005C0:  MOVFF  00,42F
005C4:  MOVWF  x30
....................       diff = P - dy; 
005C6:  MOVF   x29,W
005C8:  SUBWF  x2F,W
005CA:  MOVWF  x31
005CC:  MOVF   x2A,W
005CE:  SUBWFB x30,W
005D0:  MOVWF  x32
....................  
....................       for(; i<=dy; ++i) 
005D2:  MOVF   x2A,F
005D4:  BNZ   05DC
005D6:  MOVF   x33,W
005D8:  SUBWF  x29,W
005DA:  BNC   061C
....................       { 
....................          glcd_pixel(x1, y1, color); 
005DC:  MOVFF  424,434
005E0:  MOVFF  425,435
005E4:  MOVFF  428,436
005E8:  MOVLB  0
005EA:  RCALL  0426
....................  
....................          if(P < 0) 
005EC:  MOVLB  4
005EE:  BTFSC  x30.7
005F0:  BRA    05F4
005F2:  BRA    0604
....................          { 
....................             P  += dx; 
005F4:  MOVF   x2B,W
005F6:  ADDWF  x2F,F
005F8:  MOVF   x2C,W
005FA:  ADDWFC x30,F
....................             y1 += addy; 
005FC:  MOVF   x2E,W
005FE:  ADDWF  x25,W
00600:  MOVWF  x25
....................          } 
....................          else 
00602:  BRA    0618
....................          { 
....................             P  += diff; 
00604:  MOVF   x31,W
00606:  ADDWF  x2F,F
00608:  MOVF   x32,W
0060A:  ADDWFC x30,F
....................             x1 += addx; 
0060C:  MOVF   x2D,W
0060E:  ADDWF  x24,W
00610:  MOVWF  x24
....................             y1 += addy; 
00612:  MOVF   x2E,W
00614:  ADDWF  x25,W
00616:  MOVWF  x25
....................          } 
....................       } 
00618:  INCF   x33,F
0061A:  BRA    05D2
....................    } 
.................... } 
0061C:  MOVLB  0
0061E:  RETLW  00
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(int16 x1, int16 y1, int16 x2, int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(int8 x1, int8 y1, int8 x2, int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
00620:  MOVLB  4
00622:  MOVF   x1D,F
00624:  BZ    0682
....................    { 
....................       #ifdef LARGE_LCD 
....................       int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
00626:  MOVF   x1B,W
00628:  SUBWF  x19,W
0062A:  BC    0636
....................       { 
....................          xmin = x1; 
0062C:  MOVFF  419,420
....................          xmax = x2; 
00630:  MOVFF  41B,421
....................       } 
....................       else 
00634:  BRA    063E
....................       { 
....................          xmin = x2; 
00636:  MOVFF  41B,420
....................          xmax = x1; 
0063A:  MOVFF  419,421
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
0063E:  MOVF   x1C,W
00640:  SUBWF  x1A,W
00642:  BC    064E
....................       { 
....................          ymin = y1; 
00644:  MOVFF  41A,422
....................          ymax = y2; 
00648:  MOVFF  41C,423
....................       } 
....................       else 
0064C:  BRA    0656
....................       { 
....................          ymin = y2; 
0064E:  MOVFF  41C,422
....................          ymax = y1; 
00652:  MOVFF  41A,423
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
00656:  MOVF   x20,W
00658:  SUBWF  x21,W
0065A:  BNC   0680
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
0065C:  MOVFF  422,41F
00660:  MOVF   x1F,W
00662:  SUBWF  x23,W
00664:  BNC   067C
....................          { 
....................             glcd_pixel(xmin, i, color); 
00666:  MOVFF  420,434
0066A:  MOVFF  41F,435
0066E:  MOVFF  41E,436
00672:  MOVLB  0
00674:  RCALL  0426
....................          } 
00676:  MOVLB  4
00678:  INCF   x1F,F
0067A:  BRA    0660
....................       } 
0067C:  INCF   x20,F
0067E:  BRA    0656
....................    } 
....................    else 
00680:  BRA    06DE
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
00682:  MOVFF  419,424
00686:  MOVFF  41A,425
0068A:  MOVFF  41B,426
0068E:  MOVFF  41A,427
00692:  MOVFF  41E,428
00696:  MOVLB  0
00698:  RCALL  04E2
....................       glcd_line(x1, y2, x2, y2, color); 
0069A:  MOVFF  419,424
0069E:  MOVFF  41C,425
006A2:  MOVFF  41B,426
006A6:  MOVFF  41C,427
006AA:  MOVFF  41E,428
006AE:  RCALL  04E2
....................       glcd_line(x1, y1, x1, y2, color); 
006B0:  MOVFF  419,424
006B4:  MOVFF  41A,425
006B8:  MOVFF  419,426
006BC:  MOVFF  41C,427
006C0:  MOVFF  41E,428
006C4:  RCALL  04E2
....................       glcd_line(x2, y1, x2, y2, color); 
006C6:  MOVFF  41B,424
006CA:  MOVFF  41A,425
006CE:  MOVFF  41B,426
006D2:  MOVFF  41C,427
006D6:  MOVFF  41E,428
006DA:  RCALL  04E2
006DC:  MOVLB  4
....................    } 
.................... } 
006DE:  MOVLB  0
006E0:  RETLW  00
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(int16 x1, int16 y1, int16 x2, int16 y2, int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(int8 x1, int8 y1, int8 x2, int8 y2, int8 width, int1 color) 
.................... #endif 
.................... { 
....................    int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    half_width = width/2; 
....................    c1 = -(dx*x1 + dy*y1); 
....................    c2 = -(dx*x2 + dy*y2); 
....................  
....................    if(x1 > x2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addx = -1; 
....................    } 
....................    if(y1 > y2) 
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
....................       c1 = c2; 
....................       c2 = temp; 
....................       addy = -1; 
....................    } 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1, y1+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P  += 2*dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
....................                glcd_pixel(x1+j, y1, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(int16 x, int16 y, int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(int8 x, int8 y, int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(int16 x, int16 y, char* textptr, int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(int8 x, int8 y, char* textptr, int8 size, int1 color) 
.................... #endif 
.................... { 
....................    int8 j, k, l, m;                       // Loop counters 
....................    int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
00906:  MOVFF  423,03
0090A:  MOVLB  4
0090C:  MOVFF  422,FE9
00910:  MOVFF  423,FEA
00914:  MOVF   FEF,F
00916:  BTFSC  FD8.2
00918:  BRA    0ABA
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
0091A:  MOVFF  423,03
0091E:  MOVFF  422,FE9
00922:  MOVFF  423,FEA
00926:  MOVF   FEF,W
00928:  SUBLW  52
0092A:  BNC   097A
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
0092C:  MOVFF  423,03
00930:  MOVFF  422,FE9
00934:  MOVFF  423,FEA
00938:  MOVLW  20
0093A:  SUBWF  FEF,W
0093C:  MULLW  05
0093E:  MOVF   FF3,W
00940:  CLRF   03
00942:  MOVWF  x2F
00944:  MOVLW  04
00946:  MOVWF  FEA
00948:  MOVLW  2A
0094A:  MOVWF  FE9
0094C:  CLRF   x33
0094E:  MOVFF  42F,432
00952:  MOVFF  FF2,430
00956:  BCF    FF2.7
00958:  MOVLW  05
0095A:  MOVWF  01
0095C:  CLRF   FF7
0095E:  MOVF   x2F,W
00960:  MOVLB  0
00962:  CALL   0004
00966:  TBLRD*-
00968:  TBLRD*+
0096A:  MOVFF  FF5,FEE
0096E:  DECFSZ 01,F
00970:  BRA    0968
00972:  MOVLB  4
00974:  BTFSC  x30.7
00976:  BSF    FF2.7
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
00978:  BRA    09E4
0097A:  MOVFF  423,03
0097E:  MOVFF  422,FE9
00982:  MOVFF  423,FEA
00986:  MOVF   FEF,W
00988:  SUBLW  7E
0098A:  BNC   09DA
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
0098C:  MOVFF  423,03
00990:  MOVFF  422,FE9
00994:  MOVFF  423,FEA
00998:  MOVLW  53
0099A:  SUBWF  FEF,W
0099C:  MULLW  05
0099E:  MOVF   FF3,W
009A0:  CLRF   03
009A2:  MOVWF  x2F
009A4:  MOVLW  04
009A6:  MOVWF  FEA
009A8:  MOVLW  2A
009AA:  MOVWF  FE9
009AC:  CLRF   x33
009AE:  MOVFF  42F,432
009B2:  MOVFF  FF2,430
009B6:  BCF    FF2.7
009B8:  MOVLW  05
009BA:  MOVWF  01
009BC:  CLRF   FF7
009BE:  MOVF   x2F,W
009C0:  MOVLB  0
009C2:  CALL   0114
009C6:  TBLRD*-
009C8:  TBLRD*+
009CA:  MOVFF  FF5,FEE
009CE:  DECFSZ 01,F
009D0:  BRA    09C8
009D2:  MOVLB  4
009D4:  BTFSC  x30.7
009D6:  BSF    FF2.7
....................       else 
009D8:  BRA    09E4
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
009DA:  CLRF   x2A
009DC:  CLRF   x2B
009DE:  CLRF   x2C
009E0:  CLRF   x2D
009E2:  CLRF   x2E
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
....................       { 
009E4:  MOVFF  423,03
009E8:  MOVF   x22,W
009EA:  MOVWF  FE9
009EC:  MOVFF  03,FEA
009F0:  MOVF   FEF,W
009F2:  XORLW  0A
009F4:  MOVLB  0
009F6:  BZ    09FE
009F8:  XORLW  07
009FA:  BZ    0A0E
009FC:  BRA    0A14
....................          case '\n': 
....................             y += 7*size + 1; 
009FE:  MOVLB  4
00A00:  MOVF   x24,W
00A02:  MULLW  07
00A04:  MOVF   FF3,W
00A06:  ADDLW  01
00A08:  ADDWF  x21,F
....................             continue; 
00A0A:  BRA    0AAC
00A0C:  MOVLB  0
....................          case '\r': 
....................             x = 0; 
00A0E:  MOVLB  4
00A10:  CLRF   x20
....................             continue; 
00A12:  BRA    0AAC
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
00A14:  MOVLB  4
00A16:  MOVF   x24,W
00A18:  MULLW  05
00A1A:  MOVF   FF3,W
00A1C:  ADDWF  x20,W
00A1E:  SUBLW  7F
00A20:  BC    0A2E
....................       { 
....................          x = 0;                           // Set x at far left position 
00A22:  CLRF   x20
....................          y += 7*size + 1;                 // Set y at next position down 
00A24:  MOVF   x24,W
00A26:  MULLW  07
00A28:  MOVF   FF3,W
00A2A:  ADDLW  01
00A2C:  ADDWF  x21,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
00A2E:  CLRF   x26
00A30:  MOVF   x26,W
00A32:  SUBLW  04
00A34:  BNC   0AAC
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
00A36:  CLRF   x27
00A38:  MOVF   x27,W
00A3A:  SUBLW  06
00A3C:  BNC   0AA4
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
00A3E:  CLRF   03
00A40:  MOVF   x26,W
00A42:  ADDLW  2A
00A44:  MOVWF  FE9
00A46:  MOVLW  04
00A48:  ADDWFC 03,W
00A4A:  MOVWF  FEA
00A4C:  MOVFF  FEF,42F
00A50:  MOVFF  42F,00
00A54:  MOVF   x27,W
00A56:  MOVWF  01
00A58:  BZ    0A62
00A5A:  BCF    FD8.0
00A5C:  RRCF   00,F
00A5E:  DECFSZ 01,F
00A60:  BRA    0A5A
00A62:  BTFSS  00.0
00A64:  BRA    0AA0
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
00A66:  CLRF   x28
00A68:  MOVF   x24,W
00A6A:  SUBWF  x28,W
00A6C:  BC    0AA0
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
00A6E:  CLRF   x29
00A70:  MOVF   x24,W
00A72:  SUBWF  x29,W
00A74:  BC    0A9C
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
00A76:  MOVF   x29,W
00A78:  ADDWF  x20,W
00A7A:  MOVWF  x2F
00A7C:  MOVF   x27,W
00A7E:  MULWF  x24
00A80:  MOVF   FF3,W
00A82:  ADDWF  x21,W
00A84:  ADDWF  x28,W
00A86:  MOVWF  x30
00A88:  MOVFF  42F,434
00A8C:  MOVWF  x35
00A8E:  MOVFF  425,436
00A92:  MOVLB  0
00A94:  RCALL  0426
....................                   } 
00A96:  MOVLB  4
00A98:  INCF   x29,F
00A9A:  BRA    0A70
....................                } 
00A9C:  INCF   x28,F
00A9E:  BRA    0A68
....................             } 
....................          } 
00AA0:  INCF   x27,F
00AA2:  BRA    0A38
....................       } 
00AA4:  INCF   x26,F
00AA6:  MOVF   x24,W
00AA8:  ADDWF  x20,F
00AAA:  BRA    0A30
....................    } 
00AAC:  INCF   x22,F
00AAE:  BTFSC  FD8.2
00AB0:  INCF   x23,F
00AB2:  INCF   x20,F
00AB4:  MOVLB  0
00AB6:  BRA    0906
00AB8:  MOVLB  4
.................... } 
00ABA:  MOVLB  0
00ABC:  RETLW  00
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... /*FIN**INCLUDES*/ 
....................  
....................  
.................... /****/ 
....................  
....................  
.................... unsigned char const xzatlcd[1024] = { 
....................    0,  0,  0,  0,  0,  0,  0,128,192,192,224,240,248,248,252,254,  
....................  255,127, 63, 31,  7,131,129, 64, 64, 96, 32, 16, 16,  8,  8,  4,  
....................    6,  2,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  
....................    1,  1,  1,  1,  1,  1,129,193,113, 25, 15,  0,  0,  0,  0,  0,  
....................  224,240,248,252,254,255,255,255,255,127, 63, 31, 15,  7,  3,129,  
....................  225, 56,140,131,129,192,192, 64, 96, 96, 32, 32, 48, 48, 16, 16,  
....................   16, 24, 24, 24,  8,  8,136,200,200,236,252,252,248,248,248,248,  
....................  248,252,252,252,232,200,136,  8,  8,  8,  8,  8,  8,  8,  8,  8,  
....................    8,  8, 24, 24, 24, 24, 24, 16, 16, 16,144,144,208,240,240,240,  
....................  240,240,248,248,248,248,248,248,248,248,240,112, 32,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,128,128,192,192, 96, 96,  
....................   48, 48, 16, 24, 12, 14,  3,  1,  0,  0,  0,  0,  0,  0,  0,  0,  
....................  255,255,255, 63, 31, 15,  3,  1,  0,  0,  0,  0,  0,  0,  3,  3,  
....................    3,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,240,252,254,255,127, 63, 31, 15, 15, 15, 15, 63,255,255,  
....................  255,255,255,255,255,255,255,255,252,240,192,  0,  0,  0,  0,  0,  
....................    0,128,192,224,240,248,248,252,254,255,255,255,255,255,255,191,  
....................  191, 31, 31, 31, 63, 63, 63, 31, 15,135,129,192,192, 96, 96, 32,  
....................   48, 16, 24,  8, 12, 12,  6,  6,  3,  3,  1,  1,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    7,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  1,  1,  1, 80,240,240,240,240,224,224,224,224,224,195,  
....................  207,255,255,255,255,255,255,255,255,255,255,255,252,248,252,254,  
....................  255,255,255,127, 63, 31, 15,  7,131,129,192,192,224, 97,113, 51,  
....................   55, 31, 31, 14, 14, 14, 30,  3,  3,  1,  1,  0,  0,128,192,192,  
....................   96, 32, 32,160,224,224,224,224,  0,  0,  0,  0,  0,  0,128,192,  
....................   64, 96, 96, 96, 96,224,224,224, 96, 96, 96, 32, 32, 48, 24,  8,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,128,128,128,192,192,224, 96,112, 48,  
....................  176,152,233,247,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,222, 14, 14, 30, 31, 31, 31, 29, 61, 60, 60, 60, 60, 60,  
....................   56,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  3,131,224,  
....................  112,124, 46, 35, 33,127,255,255,224,  0,  0,  0,  2,  7,  7,  0,  
....................    0,  0,  0,224,254,255, 63,  1,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,128,128,192,192,224,224,240,240,248,248,  
....................  248,252,255,255,127, 63,159,223,207,231,243,251,249,252,254,255,  
....................  127,127, 31, 31, 15,  7,  3,  3, 15, 63,255,255,255,255,255,255,  
....................  255,255,255,255,252,240,192,  0,  0,  0,  0,  0,  0,  0,  0,128,  
....................  192,224,224,224,  0,  0,  2,  3,  6,  6,  6,  6,  2,  3,  1,  0,  
....................    0,  0,  0,  0,  0,  0,  7,  7,  7,  6,  2,  0,  0,  0,  0,  2,  
....................    6,  6,  7,  7,  7,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,128,128,192,192,224,224,224,240,240,248,248,252,  
....................  252,254,254,255,255,255,255,255,135, 48,125,249,247,247,247,243,  
....................  249,253,252,126,126, 63,191,191,223,223,143,143,135,131,129,128,  
....................  128,128,128,128,128,128,128,  0,  0,  0,  0,  3, 15, 31,127,255,  
....................  255,255,255,255,255,255,255,255,254,252,252,252,254,254,127, 63,  
....................   31, 15,  7,  3,  0,128,128,128,128,128,128,128,192,192,192,192,  
....................  192,192,224,224,224,224,240,240,240,240,248,248,248,252,252,254,  
....................  254,254,127, 63,  7,  0,  0,  0,  0,128,192,192,224,240,248,254,  
....................  254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,254,254,254,254,254,  
....................  254,254,254,254,254,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  
....................  127,127, 63, 63, 63, 31, 31, 31, 15, 15,  7,  7,  3,  3,  1,  1,  
....................    0,  0,128,224,240,248,252,254,255,127, 63, 63, 31, 15,  7,  7  
.................... }; 
....................  
.................... unsigned char const nub[1024] = { 
....................    0,192,224, 32, 48, 16, 16, 48, 24, 24,120,112, 80,216,  8,  8,  
....................    8, 24, 24, 16, 48, 96,224,128,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  1,  1, 15,  8, 56,248, 24, 24,  8, 15,  3,193,224, 96,  
....................   32,112, 16, 16, 16, 56, 24, 11, 15, 56,112, 64,192,128,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,124,198,134,130,130,135,  1,  7, 12,  8, 24, 16, 49, 39, 38,  
....................   36, 60, 32,224,224,224,192,192, 64, 96, 60,  4,  4,  7,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  3, 15,  8, 24, 16, 16, 16, 48, 32, 32, 32,  
....................   32, 48, 16, 29,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  
.................... }; 
....................  
.................... unsigned char const sun[1024] = { 
....................    0,  0,192,  0,  0,  0,  0,  0,  0,  0,  0,  6, 15, 28,248,248,  
....................  240,  0,  0,  0,  0,  0,  0,224,240, 48, 16,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  3,  7, 23, 14, 14, 30, 30, 28,240,188,238,254,254,255,239,  
....................  238,254,222,253,249,247,  7,131,131,128,128,128,128,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    4, 12, 24, 28, 30, 14, 14, 60, 12,207,223,255,188,127,119,119,  
....................  119,251,253,223, 31, 15,  1,  3,  3,  7,  3,  0,  1,  3,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0, 24, 62,  7,  7,  7,  3,  0,  0,  0,  
....................    0,  1,  3,  7,  7,  3, 15, 14,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  
....................    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  
.................... }; 
....................  
.................... /*FUNCIONES*/ 
....................  
....................  
.................... /*FIN**FUNCIONES*/ 
....................  
.................... void glcd_text_sec(char sec, char line, char* textptr, int1 color); 
.................... void draw_sect(); 
....................  
....................  
....................  
.................... void glcd_showimage1()  
.................... {  
....................   int16 n=0;  
....................   int i,j;  
....................   int1 cs=0;  
....................    // Loop through the vertical pages  
....................    for(i = 0; i <8; ++i)  
....................    {  
....................       output_low(GLCD_DI);                      // Set for instruction  
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0  
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000);  
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address  
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000);  
....................       output_high(GLCD_DI);                     // Set for data  
....................  
....................       // Loop through the horizontal sections  
....................       for(j = 0; j < 128;++j)  
....................       {  
....................          if(j<64) cs=GLCD_LEFT;else cs=GLCD_RIGHT;  
....................          glcd_writeByte(cs,nub[n]);  // Turn pixels on or off  
....................          //delay_us(5);  
....................         n++;  
....................       }  
....................    }  
.................... }     
....................  
.................... void glcd_showimage2()  
.................... {  
....................   int16 n=0;  
....................   int i,j;  
....................   int1 cs=0;  
....................    // Loop through the vertical pages  
....................    for(i = 0; i <8; ++i)  
....................    {  
....................       output_low(GLCD_DI);                      // Set for instruction  
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0  
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000);  
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address  
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000);  
....................       output_high(GLCD_DI);                     // Set for data  
....................  
....................       // Loop through the horizontal sections  
....................       for(j = 0; j < 128;++j)  
....................       {  
....................          if(j<64) cs=GLCD_LEFT;else cs=GLCD_RIGHT;  
....................          glcd_writeByte(cs,sun[n]);  // Turn pixels on or off  
....................          //delay_us(5);  
....................         n++;  
....................       }  
....................    }  
.................... }     
....................  
.................... void main() 
.................... { 
*
00BAE:  CLRF   FF8
00BB0:  BCF    FD0.7
00BB2:  CLRF   FEA
00BB4:  CLRF   FE9
00BB6:  BSF    FB8.3
00BB8:  MOVLW  10
00BBA:  MOVWF  FAF
00BBC:  MOVLW  00
00BBE:  MOVWF  FB0
00BC0:  MOVLW  A6
00BC2:  MOVWF  FAC
00BC4:  MOVLW  90
00BC6:  MOVWF  FAB
00BC8:  MOVF   FC1,W
00BCA:  ANDLW  C0
00BCC:  IORLW  0F
00BCE:  MOVWF  FC1
00BD0:  MOVLW  07
00BD2:  MOVWF  FB4
00BD4:  CLRF   05
00BD6:  MOVLB  4
00BD8:  CLRF   x06
00BDA:  CLRF   x07
00BDC:  CLRF   x0C
00BDE:  CLRF   x0D
....................  
....................     
....................    glcd_init(ON);   
00BE0:  MOVLW  01
00BE2:  MOVWF  x19
00BE4:  MOVLB  0
00BE6:  CALL   0354
....................  
....................    delay_ms(100); 
00BEA:  MOVLW  64
00BEC:  MOVLB  4
00BEE:  MOVWF  x19
00BF0:  MOVLB  0
00BF2:  BRA    03FC
....................     
....................    draw_sect(); 
00BF4:  BRA    06E2
....................    int t = 234; 
....................    char temp[10]; 
00BF6:  MOVLW  EA
00BF8:  MOVLB  4
00BFA:  MOVWF  x0E
....................    sprintf(temp,"%3.1w",t); 
00BFC:  MOVLW  04
00BFE:  MOVWF  x0D
00C00:  MOVLW  0F
00C02:  MOVWF  x0C
00C04:  MOVLW  03
00C06:  MOVWF  FE9
00C08:  CLRF   x1C
00C0A:  CLRF   x1B
00C0C:  CLRF   x1A
00C0E:  MOVFF  40E,419
00C12:  MOVLW  01
00C14:  MOVWF  x1D
00C16:  MOVLB  0
00C18:  BRA    081E
....................    glcd_text_sec(1,1,temp,OFF); 
00C1A:  MOVLW  01
00C1C:  MOVLB  4
00C1E:  MOVWF  x19
00C20:  MOVWF  x1A
00C22:  MOVLW  04
00C24:  MOVWF  x1C
00C26:  MOVLW  0F
00C28:  MOVWF  x1B
00C2A:  CLRF   x1D
00C2C:  MOVLB  0
00C2E:  BRA    0ABE
....................    glcd_update(); 
00C30:  CALL   029C
....................     
....................    
....................   /* 
....................    
....................    while (1) 
....................    { 
....................    int8 i=0; 
....................    for (i=0;i<63;i++) 
....................    {   
....................     
....................       char h,k; 
....................       h = (2*i); 
....................       k = (2*i)+1; 
....................        
....................       char l[] = "Iniciando X-Weather"; 
....................        
....................        char n[] = "Iniciando Sensores"; 
....................       glcd_bar(h, 5, h, 15, 1, ON); 
....................       glcd_bar(k, 5, k, 15, 1, ON); 
....................       glcd_text57(5, 7, l, 1, OFF) ; 
....................        
....................        
....................        
....................       glcd_update(); 
....................        
....................        
....................    } 
....................    glcd_rect(0,6,127,15,YES,ON); 
....................    for (i=0;i<63;i++) 
....................    {   
....................     
....................       char h,k; 
....................       h = (2*i); 
....................       k = (2*i)+1; 
....................        
....................        
....................        
....................        char n[] = "Iniciando Sensores"; 
....................         
....................       glcd_bar(h, 5, h, 15, 1, OFF); 
....................       glcd_bar(k, 5, k, 15, 1, OFF); 
....................       glcd_text57(5, 7, n, 1, ON) ; 
....................        
....................        
....................        
....................       glcd_update(); 
....................        
....................        
....................    } 
....................    break; 
....................    } 
....................    //glcd_showimage2()  ; 
....................    //glcd_update(); 
....................    delay_ms(1000); 
....................    glcd_showimage1()  ; 
....................     
....................    draw_sect(); 
....................     
....................     
....................    char a[] = "Hola 1234"; 
....................    glcd_text_sec(1,1,a,OFF); 
....................    glcd_text_sec(1,2,a,OFF); 
....................    glcd_text_sec(1,3,a,OFF); 
....................     
....................    glcd_text_sec(2,1,a,ON); 
....................    glcd_text_sec(2,2,a,ON); 
....................    glcd_text_sec(2,3,a,ON); 
....................     
....................    glcd_text_sec(3,1,a,ON); 
....................    glcd_text_sec(3,2,a,ON); 
....................    glcd_text_sec(3,3,a,ON); 
....................     
....................    glcd_text_sec(4,1,a,OFF); 
....................    glcd_text_sec(4,2,a,OFF); 
....................    glcd_text_sec(4,3,a,OFF); 
....................     
....................    glcd_update(); 
....................    */ 
.................... } 
....................  
.................... void draw_sect(void) 
.................... { 
00C34:  SLEEP 
....................    //Sec1 
....................    glcd_rect(0, 0, 62, 30, YES, ON);    
*
006E2:  MOVLB  4
006E4:  CLRF   x19
006E6:  CLRF   x1A
006E8:  MOVLW  3E
006EA:  MOVWF  x1B
006EC:  MOVLW  1E
006EE:  MOVWF  x1C
006F0:  MOVLW  01
006F2:  MOVWF  x1D
006F4:  MOVWF  x1E
006F6:  MOVLB  0
006F8:  RCALL  0620
....................    glcd_rect(0, 0, 62, 30, NO, OFF); 
006FA:  MOVLB  4
006FC:  CLRF   x19
006FE:  CLRF   x1A
00700:  MOVLW  3E
00702:  MOVWF  x1B
00704:  MOVLW  1E
00706:  MOVWF  x1C
00708:  CLRF   x1D
0070A:  CLRF   x1E
0070C:  MOVLB  0
0070E:  RCALL  0620
....................     
....................    //Sec2 
....................    glcd_rect(63, 0, 127, 30, NO, ON); 
00710:  MOVLW  3F
00712:  MOVLB  4
00714:  MOVWF  x19
00716:  CLRF   x1A
00718:  MOVLW  7F
0071A:  MOVWF  x1B
0071C:  MOVLW  1E
0071E:  MOVWF  x1C
00720:  CLRF   x1D
00722:  MOVLW  01
00724:  MOVWF  x1E
00726:  MOVLB  0
00728:  RCALL  0620
....................     
....................    //Sec3 
....................    glcd_rect(0, 31, 62, 63, NO, ON); 
0072A:  MOVLB  4
0072C:  CLRF   x19
0072E:  MOVLW  1F
00730:  MOVWF  x1A
00732:  MOVLW  3E
00734:  MOVWF  x1B
00736:  MOVLW  3F
00738:  MOVWF  x1C
0073A:  CLRF   x1D
0073C:  MOVLW  01
0073E:  MOVWF  x1E
00740:  MOVLB  0
00742:  RCALL  0620
....................     
....................    //Sec4 
....................    glcd_rect(63, 31, 127, 63, YES, ON); 
00744:  MOVLW  3F
00746:  MOVLB  4
00748:  MOVWF  x19
0074A:  MOVLW  1F
0074C:  MOVWF  x1A
0074E:  MOVLW  7F
00750:  MOVWF  x1B
00752:  MOVLW  3F
00754:  MOVWF  x1C
00756:  MOVLW  01
00758:  MOVWF  x1D
0075A:  MOVWF  x1E
0075C:  MOVLB  0
0075E:  RCALL  0620
....................    glcd_rect(63, 31, 127, 63, NO, OFF); 
00760:  MOVLW  3F
00762:  MOVLB  4
00764:  MOVWF  x19
00766:  MOVLW  1F
00768:  MOVWF  x1A
0076A:  MOVLW  7F
0076C:  MOVWF  x1B
0076E:  MOVLW  3F
00770:  MOVWF  x1C
00772:  CLRF   x1D
00774:  CLRF   x1E
00776:  MOVLB  0
00778:  RCALL  0620
....................     
.................... } 
0077A:  GOTO   0BF6 (RETURN)
....................  
.................... void glcd_text_sec(char sec, char line, char* textptr, int1 color) 
.................... { 
*
00ABE:  MOVLB  4
00AC0:  CLRF   x1E
....................    int8 ly=0; 
....................    ly = (line-1)*9; 
00AC2:  MOVLW  01
00AC4:  SUBWF  x1A,W
00AC6:  MULLW  09
00AC8:  MOVFF  FF3,41E
....................    switch (sec) 
....................    { 
00ACC:  MOVLW  01
00ACE:  SUBWF  x19,W
00AD0:  ADDLW  FC
00AD2:  BC    0B86
00AD4:  ADDLW  04
00AD6:  MOVLB  0
00AD8:  GOTO   0B8C
....................       case 1: 
....................       { 
....................          glcd_text57(3, 3+ly, textptr, 1, color); 
00ADC:  MOVLW  03
00ADE:  MOVLB  4
00AE0:  ADDWF  x1E,W
00AE2:  MOVWF  x1F
00AE4:  MOVLW  03
00AE6:  MOVWF  x20
00AE8:  MOVFF  41F,421
00AEC:  MOVFF  41C,423
00AF0:  MOVFF  41B,422
00AF4:  MOVLW  01
00AF6:  MOVWF  x24
00AF8:  MOVFF  41D,425
00AFC:  MOVLB  0
00AFE:  RCALL  0906
....................          break; 
00B00:  MOVLB  4
00B02:  BRA    0B86
00B04:  MOVLB  0
....................       } 
....................       case 2: 
....................       { 
....................          glcd_text57(66, 3+ly, textptr, 1, color); 
00B06:  MOVLW  03
00B08:  MOVLB  4
00B0A:  ADDWF  x1E,W
00B0C:  MOVWF  x1F
00B0E:  MOVLW  42
00B10:  MOVWF  x20
00B12:  MOVFF  41F,421
00B16:  MOVFF  41C,423
00B1A:  MOVFF  41B,422
00B1E:  MOVLW  01
00B20:  MOVWF  x24
00B22:  MOVFF  41D,425
00B26:  MOVLB  0
00B28:  RCALL  0906
....................          break; 
00B2A:  MOVLB  4
00B2C:  BRA    0B86
00B2E:  MOVLB  0
....................       } 
....................       case 3: 
....................       { 
....................          glcd_text57(3, 34+ly, textptr, 1, color); 
00B30:  MOVLW  22
00B32:  MOVLB  4
00B34:  ADDWF  x1E,W
00B36:  MOVWF  x1F
00B38:  MOVLW  03
00B3A:  MOVWF  x20
00B3C:  MOVFF  41F,421
00B40:  MOVFF  41C,423
00B44:  MOVFF  41B,422
00B48:  MOVLW  01
00B4A:  MOVWF  x24
00B4C:  MOVFF  41D,425
00B50:  MOVLB  0
00B52:  RCALL  0906
....................          break; 
00B54:  MOVLB  4
00B56:  BRA    0B86
00B58:  MOVLB  0
....................       } 
....................       case 4: 
....................       { 
....................          glcd_text57(66, 34+ly, textptr, 1, color); 
00B5A:  MOVLW  22
00B5C:  MOVLB  4
00B5E:  ADDWF  x1E,W
00B60:  MOVWF  x1F
00B62:  MOVLW  42
00B64:  MOVWF  x20
00B66:  MOVFF  41F,421
00B6A:  MOVFF  41C,423
00B6E:  MOVFF  41B,422
00B72:  MOVLW  01
00B74:  MOVWF  x24
00B76:  MOVFF  41D,425
00B7A:  MOVLB  0
00B7C:  RCALL  0906
....................          break; 
00B7E:  MOVLB  4
00B80:  BRA    0B86
00B82:  MOVLB  0
00B84:  MOVLB  4
....................       } 
....................    } 
....................     
.................... } 
00B86:  MOVLB  0
00B88:  GOTO   0C30 (RETURN)
....................  
.................... void glcd_image(long mempointer  /*This is the image location in program memory*/)  
.................... {  int j, i;  
....................    int page = 0xB8;  
....................    char chipsel;  
....................    char buffer[1];  
....................    output_low(GLCD_DI);                // Set for instruction  
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0  
....................    glcd_writeByte(GLCD_CS2, 0x40);  
....................    glcd_writeByte(GLCD_CS1, page);     // Set the page address to 0  
....................    glcd_writeByte(GLCD_CS2, page);  
....................    for (j = 0; j < 8; j++, page+=1)  
....................    {  output_low(GLCD_DI);  
....................       glcd_writeByte(GLCD_CS1, page);  
....................       glcd_writeByte(GLCD_CS2, page);  
....................       for (i = 0; i < 128; i++)  
....................       {  
....................          if ( i < 64)  
....................          {  
....................             chipsel = GLCD_CS1;  
....................          }  
....................          else  
....................          {  
....................             chipsel = GLCD_CS2;  
....................          }  
....................          read_program_memory(mempointer, buffer, 1);  
....................          mempointer++;  
....................          output_high(GLCD_DI);  
....................          glcd_writeByte(chipsel, *buffer);  
....................       }  
....................    }  
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV21 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP BBSIZ1K NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
