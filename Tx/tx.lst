CCS PCH C Compiler, Version 4.114, 93460303               02-abr-12 23:32

               Filename: C:\Users\MrDarkness\X-Weather\Tx\tx.lst

               ROM used: 4254 bytes (6%)
                         Largest free fragment is 61278
               RAM used: 119 (4%) at main() level
                         162 (5%) worst case
               Stack:    4 worst case (3 in main + 1 for interrupts)

*
00000:  GOTO   0E34
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.0
00056:  GOTO   0060
0005A:  BTFSC  F9E.0
0005C:  GOTO   00D2
00060:  BTFSS  FA0.1
00062:  GOTO   006C
00066:  BTFSC  FA1.1
00068:  GOTO   00DE
0006C:  BTFSS  FF2.4
0006E:  GOTO   0078
00072:  BTFSC  FF2.1
00074:  GOTO   0108
00078:  BTFSS  F9D.5
0007A:  GOTO   0084
0007E:  BTFSC  F9E.5
00080:  GOTO   0112
00084:  MOVFF  0E,00
00088:  MOVFF  0F,01
0008C:  MOVFF  10,02
00090:  MOVFF  11,03
00094:  MOVFF  0C,FE9
00098:  MOVFF  07,FEA
0009C:  BSF    07.7
0009E:  MOVFF  08,FE1
000A2:  MOVFF  09,FE2
000A6:  MOVFF  0A,FD9
000AA:  MOVFF  0B,FDA
000AE:  MOVFF  12,FF3
000B2:  MOVFF  13,FF4
000B6:  MOVFF  14,FFA
000BA:  MOVFF  15,FF5
000BE:  MOVFF  16,FF6
000C2:  MOVFF  17,FF7
000C6:  MOVF   04,W
000C8:  MOVFF  06,FE0
000CC:  MOVFF  05,FD8
000D0:  RETFIE 0
.................... /************************************************************************ 
.................... *                                                                       * 
.................... * Module:            tx.c                                               * 
.................... * Description:       Code for the X-Weather Transmitter.                * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... * Date:            Authors:               Comments:                     * 
.................... * 30 Mar 2012      Jose Morales            Created                      * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... ************************************************************************/ 
....................  
.................... #if defined(__PCH__) 
.................... #include <tx.h>         // Headers 
.................... #include <18F4680.h> 
.................... //////// Standard Header file for the PIC18F4680 device //////////////// 
.................... #device PIC18F4680 
.................... #list 
....................  
....................  
.................... #DEVICE ADC=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
.................... //#FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... //#FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BBSIZ1K                  //1K words Boot Block size 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(crystal=8000000) 
*
00B82:  CLRF   FEA
00B84:  MOVLW  85
00B86:  MOVWF  FE9
00B88:  MOVF   FEF,W
00B8A:  BZ    0BA6
00B8C:  MOVLW  02
00B8E:  MOVWF  01
00B90:  CLRF   00
00B92:  DECFSZ 00,F
00B94:  BRA    0B92
00B96:  DECFSZ 01,F
00B98:  BRA    0B90
00B9A:  MOVLW  97
00B9C:  MOVWF  00
00B9E:  DECFSZ 00,F
00BA0:  BRA    0B9E
00BA2:  DECFSZ FEF,F
00BA4:  BRA    0B8C
00BA6:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,errors) 
.................... #use i2c(Master,Fast,sda=PIN_C4,scl=PIN_C3,force_hw) 
....................  
....................  
.................... #endif 
.................... //#include <bootloader.h> // Bootloader 
....................  
....................    
.................... /************************************************************************ 
.................... *  Globar Vars and Constants ***** Variables y Constates globales       * 
.................... ************************************************************************/ 
.................... short dir0,dir1,dir2=0; 
.................... int dir=0; 
....................  
.................... int16 dhth,dhtt=0; 
.................... float32 tbmp,pbmp,abmp; 
....................  
.................... float timer,vel,aux; 
.................... int tim1,ext=0; 
.................... int32 aux_multp,start_send=0; 
.................... int16 pr_light,ls0,ls1,ls2=0; 
.................... int ls=0; 
.................... short go=1; 
.................... int weather; 
.................... short polled_vel,polled_bmp,polled_dht,polled_light,polled_dir=0; 
....................  
.................... int at; 
.................... int8 type[]="TPAHV"; 
....................  
....................                                   
....................    
.................... /************************************************************************ 
.................... *  Defines  *****  Definiciones                                         * 
.................... ************************************************************************/ 
....................  
.................... #define PIN_DIR0   PIN_D0 
.................... #define PIN_DIR1   PIN_D1 
.................... #define PIN_DIR2   PIN_D2 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************ 
.................... *  Includes  *****  Inclusiones                                         * 
.................... ************************************************************************/ 
.................... //#include <LCD.C>        // LCD Driver 
.................... #include <math.h>        
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include "../Libs/bmp085.c"      //BMP085 Driver   
.................... /************************************************************************ 
.................... *                                                                       * 
.................... * Module:            BMP085.c                                           * 
.................... * Description:       BMP085-specific code.                              * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... * Date:            Authors:               Comments:                     * 
.................... * 18 Feb 2012      Jose Morales            Created                      * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... ************************************************************************/ 
....................  
....................  
.................... /************************************************************************ 
.................... *  Defines  *****  Definiciones                                         * 
.................... ************************************************************************/ 
.................... #define      BMP085_R   0xEF     // Write address 
.................... #define      BMP085_W   0xEE     // Read address 
.................... #define      OSS        0        // Oversampling Setting 
....................  
.................... /************************************************************************ 
.................... *  Globar Vars and Constants ***** Variables y Constates globales       * 
.................... ************************************************************************/ 
.................... const unsigned char OSS_conversion_time[] = {5, 8, 14, 26}; 
....................  
.................... signed int16 ac1; 
.................... signed int16 ac2; 
.................... signed int16 ac3; 
.................... signed int16 b1; 
.................... signed int16 b2; 
.................... signed int16 mb; 
.................... signed int16 mc; 
.................... signed int16 md; 
.................... unsigned int16 ac4; 
.................... unsigned int16 ac5; 
.................... unsigned int16 ac6; 
.................... int16 but,bup; 
.................... int8 shift;  
....................  
....................  
.................... /************************************************************************ 
.................... *  Function Prototypes                                                  * 
.................... ************************************************************************/ 
....................  
.................... void BMP085_Calibration(void); 
.................... long bmp085Read2Bytes(unsigned char address); 
.................... int32 bmp085Read3Bytes(unsigned char address); 
.................... long bmp085ReadTemp(void); 
.................... int32 bmp085ReadPressure(void); 
.................... void bmp085Convert(long *temperature, long *pressure,unsigned char readings); 
....................  
....................  
....................  
....................  
.................... /************************************************************************ 
.................... *                                                                       * 
.................... *  Purpose:    Will read two (or 3) sequential 8-bit registers,         * 
.................... *              and Return a 16-bit value.                               * 
.................... *  Proposito:  Leer 2 registros de 8 bits secuenciales y regresar       * 
.................... *              un valor de 16bits.                                      * 
.................... *  Passed:     Address - Unsigned char                                  * 
.................... *  Argumento:  Direccion                                                * 
.................... *  Returned:   Reading - Long                                           * 
.................... *  Retorno:    Lectura                                                  * 
.................... *  Note:       Return value must be typecast to an signed short         * 
.................... *              if reading a signed value!                               * 
.................... *                                                                       * 
.................... ************************************************************************/ 
....................  
.................... long bmp085Read2Bytes(unsigned char address) 
.................... {               
....................    unsigned int16 msb, lsb; 
....................    long data=0; 
....................     
....................    delay_ms(10); 
....................     
....................    i2c_start();  
....................    i2c_write(BMP085_W);       //   Escribir la direccion del sensor  
....................    i2c_write(address);        //   Direccion de memoria 
....................    i2c_start();               //   Reinicio 
....................    i2c_write(BMP085_R);       //   Direccion para leer del sensor 
....................    msb=i2c_read(0);           //   Leer la direccion 
....................    delay_ms(10); 
....................    i2c_stop();                //   Parar 
....................     
....................    delay_ms(10); 
....................     
....................    i2c_start();  
....................    i2c_write(BMP085_W);       //   Write required to clock in address  
....................    i2c_write(address+1);      //   Mem address  
....................    i2c_start();               //   Restart 
....................    i2c_write(BMP085_R);       //   Device address for reading 
....................    lsb=i2c_read(0);           //   Read address 
....................    delay_ms(10); 
....................    i2c_stop();                //   Stop 
....................  
....................    data = msb << 8;            
....................    data = data | lsb; 
....................  
....................    return data; 
.................... } 
....................  
.................... int32 bmp085Read3Bytes(unsigned char address) 
.................... {               
....................    unsigned int16 msb,lsb,xlsb; 
....................    int32 data=0; 
....................     
....................    delay_ms(10); 
....................     
....................    i2c_start();  
....................    i2c_write(BMP085_W);       //   Escribir la direccion del sensor  
....................    i2c_write(address);        //   Direccion de memoria 
....................    i2c_start();               //   Reinicio 
....................    i2c_write(BMP085_R);       //   Direccion para leer del sensor 
....................    msb=i2c_read(0);           //   Leer la direccion 
....................    delay_ms(10); 
....................    i2c_stop();                //   Parar 
....................     
....................     
....................  
....................    delay_ms(10); 
....................     
....................    i2c_start();  
....................    i2c_write(BMP085_W);       //   Write required to clock in address  
....................    i2c_write(address+1);      //   Mem address  
....................    i2c_start();               //   Restart 
....................    i2c_write(BMP085_R);       //   Device address for reading 
....................    lsb=i2c_read(0);           //   Read address 
....................    delay_ms(10); 
....................    i2c_stop();                //   Stop 
....................  
....................    delay_ms(10); 
....................     
....................    i2c_start();  
....................    i2c_write(BMP085_W);       //   Write required to clock in address  
....................    i2c_write(address+2);      //   Mem address  
....................    i2c_start();               //   Restart 
....................    i2c_write(BMP085_R);       //   Device address for reading 
....................    xlsb=i2c_read(0);           //   Read address 
....................    delay_ms(10); 
....................    i2c_stop();                //   Stop 
....................  
....................     
....................  
....................     
....................  
....................    data = (msb << 8); 
....................    data = (data | lsb); 
....................    data = (data << 8); 
....................    data = (data | xlsb); 
....................    data = (data >> (8-OSS)); 
....................  
....................  
....................    return data; 
.................... } 
.................... /************************************************************************ 
.................... * 
.................... * Purpose:        Calibrates the BMP085 pressure sensor. 
.................... * Passed:         Void 
.................... * Returned:       Void 
.................... * Note: 
.................... * 
.................... ************************************************************************/ 
.................... void BMP085_Calibration(void) 
.................... { 
....................   /* ac1 = 6690; 
....................    ac2 = -1227; 
....................    ac3 = -14421; 
....................    ac4 = 33898; 
....................    ac5 = 24422; 
....................    ac6 = 22886; 
....................    b1 = 5498; 
....................    b2 = 66; 
....................    mb = -32768; 
....................    mc = -11075; 
....................    md = 2432; 
.................... */ 
....................    ac1 = bmp085Read2Bytes(0xAA); 
....................    ac2 = bmp085Read2Bytes(0xAC); 
....................    ac3 = bmp085Read2Bytes(0xAE); 
....................    ac4 = bmp085Read2Bytes(0xB0); 
....................    ac5 = bmp085Read2Bytes(0xB2); 
....................    ac6 = bmp085Read2Bytes(0xB4); 
....................    b1 = bmp085Read2Bytes(0xB6); 
....................    b2 = bmp085Read2Bytes(0xB8); 
....................    mb = bmp085Read2Bytes(0xBA); 
....................    mc = bmp085Read2Bytes(0xBC); 
....................    md = bmp085Read2Bytes(0xBE); 
.................... /* 
....................    printf("%Ld \n",ac1); 
....................    printf("%Ld \n",ac2); 
....................    printf("%Ld \n",ac3); 
....................    printf("%Lu \n",ac4); 
....................    printf("%Lu \n",ac5); 
....................    printf("%Lu \n",ac6); 
....................    printf("%Ld \n",b1); 
....................    printf("%Ld \n",b2); 
....................    printf("%Ld \n",mb); 
....................    printf("%Ld \n",mc); 
....................    printf("%Ld \n",md); 
....................    */ 
.................... } 
....................  
....................  
.................... /************************************************************************ 
.................... * 
.................... * Purpose:      Will read the 16-bit temperature value of BMP085 sensor. 
.................... * Passed:      Void 
.................... * Returned:      Long 
.................... * Note: 
.................... *  
.................... ************************************************************************/ 
.................... long bmp085ReadTemp(void) 
.................... { 
....................    i2c_start(); 
....................  
....................    i2c_write(BMP085_W);       // Write 0xEE 
....................    i2c_write(0xF4);           // Write register address 
....................    i2c_write(0x2E);           // Write register data for temp 
....................  
....................    i2c_stop(); 
....................  
....................    delay_ms(10);              // Max time is 4.5ms 
....................  
....................    return bmp085Read2Bytes(0xF6); 
.................... } 
....................  
.................... /************************************************************************ 
.................... * 
.................... * Purpose:      Will read the 16-bit pressure value from BMP085 sensor. 
.................... * Passed:      Void 
.................... * Returned:      Long 
.................... * Note: 
.................... * 
.................... ************************************************************************/ 
.................... int32 bmp085ReadPressure(void) 
.................... { 
....................    i2c_start(); 
....................  
....................    i2c_write(BMP085_W);      // Write 0xEE 
....................    i2c_write(0xF4);      // Write register address 
....................    i2c_write(0x34 | (OSS << 6));      // Write register data for temp 
....................  
....................    i2c_stop(); 
....................  
....................    delay_ms(OSS_conversion_time[OSS]);      // Max time is 4.5ms 
....................     
....................    return bmp085Read3Bytes(0xF6); 
....................      
.................... } 
....................  
.................... /************************************************************************ 
.................... * 
.................... * Purpose:      Will find callibrated pressure + temperature 
.................... * Passed:      Long *temperature, long *pressure, unsigned char readings 
.................... * Returned:      Void 
.................... * Note: 
.................... * 
.................... ************************************************************************/ 
....................  
.................... // The bit-shift for possibly negative numbers. 
.................... // Note that divide has a higher precedence than 
.................... // bit shift, so this is not precisely the same. 
....................  
.................... void bmp085Convert(float *temperature, float *pressure) 
.................... { 
....................    int32 ut,up; 
....................    //float32 b5, b6, x3, b3, p, b4, b7; 
....................    float32 aux1,aux2,aux3,aux4; 
....................    
....................    float32 c3,c4,c5,c6,bb1,mmc,mmd,x,x0,x1,x2,y,y0,y1,y2,p0,p1,p2,z,s,alpha,temp,pres; 
....................     
....................    ut = bmp085ReadTemp(); 
....................    ut = bmp085ReadTemp();      
....................    up = bmp085ReadPressure(); 
....................    up = bmp085ReadPressure(); 
....................     
....................    //ut = 0x7B50; 
....................    //up = 0x883F; 
....................    //printf("%LX \n",ut); 
....................    //printf("%LX \n",up); 
....................  
....................    //but = ut;   //Debug var 
....................       
.................... /*NEW CALCS*/ 
....................  
....................    c3 = 160*pow(2,-15)*ac3; 
....................    c4 = pow(10,-3)*pow(2,-15)*ac4; 
....................    bb1 =  25600*pow(2,-30)*b1; 
....................  
....................    //printf("%e \n",c3); 
....................    //printf("%e \n",c4); 
....................    //printf("%e \n",bb1); 
....................  
....................    c5 = ac5*pow(2,-15)/160; 
....................    c6 = ac6; 
....................    mmc = (0.08)*mc; 
....................    mmd = md/160; 
....................  
....................    //printf("%e \n",c5); 
....................    //printf("%e \n",c6); 
....................    //printf("mmc\n"); 
....................    //printf("%e \n",mmc); 
....................    //printf("%e \n",mmd); 
....................  
....................    x0 = ac1; 
....................    x1 = 160*pow(2,-13)*ac2; 
....................    x2 = 25600*pow(2,-25)*b2; 
....................  
....................    //printf("%e \n",x0); 
....................    //printf("%e \n",x1); 
....................    //printf("%e \n",x2); 
....................  
....................    y0 = c4*32768; 
....................    y1 = c4*c3; 
....................    y2 = c4*bb1; 
....................  
....................    //printf("%e \n",y0); 
....................    //printf("%e \n",y1); 
....................    //printf("%e \n",y2); 
....................  
....................    p0 = 3783/1600; 
....................    p1 = 1-7357*pow(2,-20); 
....................    p2 = 3038*100*pow(2,-36); 
....................  
....................    //printf("%e \n",p0); 
....................    //printf("%e \n",p1); 
....................    //printf("%e \n",p2); 
....................  
....................    /*Calculamos temperatura*/ 
....................    alpha = c5*(ut-c6);  
....................    temp = alpha + (mmc/(alpha+mmd)); 
....................  
....................  
....................    /*Calculamos presion*/ 
....................    s = temp - 25; 
....................    x = x2*s*s+x1*s+x0; 
....................    y = y2*s*s+y1*s+y0; 
....................    z = (up-x)/y; 
....................    pres = p2*z*z+p1*z+p0; 
....................  
....................  
....................  
....................    *temperature = temp; 
....................    *pressure = pres; 
....................  
....................  
.................... /**/ 
....................     
....................     
.................... /****************BEGIN*****CALC*****TEMP*********************/    
....................  
.................... /* 
....................    aux1 = ut-ac6; 
....................    aux2 = aux1*ac5; 
....................    x1 = aux2/32768; 
....................    //x1 = ((ut - ac6) * ac5 / pow(2,15)); 
....................     
....................     
....................    aux3 = x1+md; 
....................    aux4 = mc/aux3; 
....................    x2 = aux4*2048; 
....................    //x2 = (mc * (pow(2,11))) / (x1 + md); 
....................     
....................    b5 = x1 + x2; 
....................     
....................    
....................     
....................    *temperature = ((b5 + 8) / 16); 
....................  
.................... /****************END*****CALC*****TEMP***********************/    
....................  
....................  
.................... /****************BEGIN*****CALC*****PRES*********************/    
.................... /* 
....................  
....................    up = up >> (8-OSS); 
....................     
....................    //bup = up; //Debug var 
....................     
....................    b6 = b5 - 4000; 
....................     
....................     
....................    aux1 = b6*b6; 
....................    aux2 = aux1/4096;    
....................    aux3 = aux2*b2; 
....................    x1 = aux3/2048;    
....................    //x1 = (b2 * (b6 * b6 / pow(2,12))) / pow(2,11); 
....................     
....................    aux1 = ac2*b6; 
....................    x2 = aux1/2048; 
....................    //x2 = ac2 * b6 / pow(2,11); 
....................     
....................    x3 = x1 + x2; 
....................  
....................    aux1 = ac1*4; 
....................    aux2 = aux1+x3; 
....................    shift = aux2; 
....................    aux3 = shift << OSS; 
....................    aux4 = aux3+2; 
....................    b3 = aux4/4; 
....................    //b3 = ((((ac1 * 4) + x3) << OSS) + 2) / 4; 
....................     
....................    aux1 = ac3*b6; 
....................    x1 = aux1/8192; 
....................    //x1 = ac3 * b6 / pow(2,13); 
....................     
....................    aux1 = b6*b6; 
....................    aux2 = aux1/4096;    
....................    aux3 = aux2*b1; 
....................    x2 = aux3/65536;    
....................    //x2 = (b1 * (b6 * b6 / pow(2,12))) / pow(2,16); 
....................     
....................    aux1 = x1+x2+2; 
....................    x3 = aux1/4; 
....................    //x3 = ((x1 + x2) + 2) / pow(2,2); 
....................     
....................    aux1 = x3+32768; 
....................    aux2 = ac4*aux1; 
....................    b4 = aux2/32768; 
....................    //b4 = (ac4 * (unsigned long) (x3 + 32768)) / pow(2,15); 
....................     
....................    aux1 = up-b3; 
....................    aux2 = 50000>>OSS; 
....................    b7 = aux1*aux2; 
....................    //b7 = ((unsigned long) up - b3) * (50000 >> OSS); 
....................     
....................    if (b7 < 0x80000000) 
....................    { 
....................       aux1 = b7*2; 
....................       p = aux1/b4; 
....................    } 
....................    else 
....................    { 
....................       aux1 = b7/b4; 
....................       p = aux1*2; 
....................    } 
....................  
....................     
....................    aux1 = p/256; 
....................    x1 = aux1*aux1; 
....................    //x1 = p / pow(2,8); 
....................    //x1 *= x1; 
....................    aux2 = x1*3038; 
....................    x1 = aux2/65536; 
....................    //x1 = (x1 * 3038) / pow(2,16); 
....................     
....................    aux1 = -7357*p; 
....................    x2 = aux1/65536; 
....................    //x2 = (-7357 * p) / pow(2,16); 
....................     
....................    aux1 = x1+x2+3791; 
....................    aux2 = aux1/16; 
....................    p = p+aux2; 
....................    *pressure = p; 
....................     
.................... /****************END*****CALC*****PRES***********************/   
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "../Libs/dht22.c"       //DHT22 Driver   
.................... /************************************************************************ 
.................... *                                                                       * 
.................... * Module:            dht22.c                                           * 
.................... * Description:       dht22/11-specific code.                              * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... * Date:            Authors:               Comments:                     * 
.................... * 18 Mar 2012      Jose Morales            Created                      * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... ************************************************************************/ 
....................  
....................  
.................... /************************************************************************ 
.................... *  Defines  *****  Definiciones                                         * 
.................... ************************************************************************/ 
.................... #define dht22 PIN_A3 
....................  
....................  
....................  
.................... /************************************************************************ 
.................... *  Globar Vars and Constants ***** Variables y Constates globales       * 
.................... ************************************************************************/ 
.................... char dht_dat[5];  
....................  
....................  
.................... /************************************************************************ 
.................... *  Function Prototypes                                                  * 
.................... ************************************************************************/ 
.................... void iniciar_dht(); 
.................... void leer_dht(int16 *hum, int16 *temp); 
.................... char leer_dht_dat(); 
....................  
....................  
....................  
.................... /************************************************************************ 
.................... *                                                                       * 
.................... *  Purpose:    Init DHT22/11                                         * 
.................... *                                                                       * 
.................... *  Proposito:  Iniciar DHT22/11                                         * 
.................... *                                                                       * 
.................... *  Passed:     None                                                     * 
.................... *  Argumento:  None                                                     * 
.................... *  Returned:   None                                                     * 
.................... *  Retorno:    None                                                     * 
.................... *  Note:       None                                                     * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... ************************************************************************/ 
.................... void iniciar_dht() 
.................... {     
....................   OUTPUT_HIGH(dht22); 
.................... } 
....................  
.................... /************************************************************************ 
.................... *                                                                       * 
.................... *  Purpose:    Read DHT22/11                                            * 
.................... *                                                                       * 
.................... *  Proposito:  Leer DHT22/11                                            * 
.................... *                                                                       * 
.................... *  Passed:     &hum - int16 ** &temp - int16                            * 
.................... *  Argumento:  &hum - int16 ** &temp - int16                            * 
.................... *  Returned:   None                                                     * 
.................... *  Retorno:    None                                                     * 
.................... *  Note:       hum and temp are pointers                                * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... ************************************************************************/ 
.................... void leer_dht(int16 *hum, int16 *temp) 
.................... { 
....................   int dht_in; 
....................   int li=0; 
....................  
....................   int16 dht_check_sum; 
....................   int16 tempe, humi; 
....................  
....................   OUTPUT_LOW(dht22); 
....................   delay_ms(10); 
....................   OUTPUT_HIGH(dht22); 
....................   //delay_ms(18);// retardo indicado por el fabricante 
....................   //OUTPUT_HIGH(dht22); 
....................   delay_us(30);// entre 22 y 28 us  
....................   dht_in=input(dht22); 
....................   if(dht_in) 
....................   {    
....................     /*Start condition 1*/  
....................     //printf("\r\nStart condition 1 not met"); 
....................     return; 
....................   } 
....................   delay_us(80); 
....................   dht_in=input(dht22); 
....................   if(!dht_in)  
....................   {     
....................     /*Start condition 2*/  
....................     //printf("\r\nStart condition 2 not met"); 
....................     return; 
....................   } 
....................   delay_us(80); 
....................   for (li=0; li<5; li++) 
....................   { 
....................     dht_dat[li] = leer_dht_dat();  
....................   } 
....................  
....................   delay_us(10); 
....................   OUTPUT_HIGH(dht22); 
....................  
....................   dht_check_sum = dht_dat[0]+dht_dat[1]+dht_dat[2]+dht_dat[3];  
....................   if(dht_dat[4]!=dht_check_sum) 
....................   {    
....................     /*Checksum failed*/  
....................     //printf("dht22 checksum error"); 
....................     return; 
....................   } 
....................  
....................   humi = make16(dht_dat[0],dht_dat[1]); 
....................   tempe = make16(dht_dat[2],dht_dat[3]); 
....................   *hum = humi; 
....................   *temp = tempe; 
....................   /* 
....................   printf("Current humdity = "); 
....................   printf("%lu",humedad); 
....................   printf(" RH  "); 
....................  
....................   printf("Temperature = "); 
....................   printf("%lu",temperatura); // por ajustar segun caracteristicas +- 2C 
....................    
....................   printf("C \n "); 
....................   delay_ms(2000); 
....................   */ 
....................  
....................  
.................... } 
....................  
.................... /************************************************************************ 
.................... *                                                                       * 
.................... *  Purpose:    Read data from DHT22/11                                  * 
.................... *                                                                       * 
.................... *  Proposito:  Leer data desde DHT22/11                                 * 
.................... *                                                                       * 
.................... *  Passed:     None                                                     * 
.................... *  Argumento:  None                                                     * 
.................... *  Returned:   result - int                                             * 
.................... *  Retorno:    result - int                                             * 
.................... *  Note:                                                                * 
.................... *                                                                       * 
.................... *                                                                       * 
.................... ************************************************************************/ 
.................... int leer_dht_dat() 
.................... { 
....................   int h = 0; 
....................   char result=0; 
....................   for (h=0; h< 8; h++)  
....................   { 
....................     while(input(dht22)==0); 
....................     delay_us(40); 
....................     if (input(dht22)==1) 
....................     { 
....................       result |=(1<<(7-h)); 
....................     } 
....................     while (input(dht22)==1); 
....................      
....................   } 
....................    
....................   return result; 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************ 
.................... *  Interrupts  *****  Interrupciones                                    * 
.................... ************************************************************************/ 
....................  
.................... #int_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
....................    tim1++; 
*
000D2:  INCF   38,F
....................     
....................    set_timer1(0); 
000D4:  CLRF   FCF
000D6:  CLRF   FCE
.................... } 
....................  
000D8:  BCF    F9E.0
000DA:  GOTO   0084
.................... #int_TIMER3 
.................... void  TIMER3_isr(void)  
.................... { 
....................    start_send++; 
000DE:  MOVLW  01
000E0:  ADDWF  3E,F
000E2:  BTFSC  FD8.0
000E4:  INCF   3F,F
000E6:  BTFSC  FD8.2
000E8:  INCF   40,F
000EA:  BTFSC  FD8.2
000EC:  INCF   41,F
....................    aux_multp++; 
000EE:  MOVLW  01
000F0:  ADDWF  3A,F
000F2:  BTFSC  FD8.0
000F4:  INCF   3B,F
000F6:  BTFSC  FD8.2
000F8:  INCF   3C,F
000FA:  BTFSC  FD8.2
000FC:  INCF   3D,F
....................    set_timer3(0); 
000FE:  CLRF   FB3
00100:  CLRF   FB2
.................... } 
....................  
00102:  BCF    FA1.1
00104:  GOTO   0084
.................... #int_EXT 
.................... void  EXT_isr(void)  
.................... { 
....................   ext = 1; 
00108:  MOVLW  01
0010A:  MOVWF  39
.................... } 
....................  
0010C:  BCF    FF2.1
0010E:  GOTO   0084
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................  
.................... } 
....................  
....................  
....................  
00112:  BCF    F9E.5
00114:  GOTO   0084
.................... void poll_vel(); 
.................... void poll_bmp(); 
.................... void poll_dht(); 
.................... void poll_light(); 
.................... void poll_dir(); 
....................  
.................... /************************************************************************ 
.................... *  Main Program  *****  Programa Principal                              * 
.................... ************************************************************************/ 
.................... void main() 
.................... {   
*
00E34:  CLRF   FF8
00E36:  BCF    FD0.7
00E38:  BSF    07.7
00E3A:  CLRF   FEA
00E3C:  CLRF   FE9
00E3E:  CLRF   19
00E40:  BCF    FB8.3
00E42:  MOVLW  0C
00E44:  MOVWF  FAF
00E46:  MOVLW  A2
00E48:  MOVWF  FAC
00E4A:  MOVLW  90
00E4C:  MOVWF  FAB
00E4E:  BSF    F94.3
00E50:  BSF    F94.4
00E52:  MOVLW  04
00E54:  MOVWF  FC8
00E56:  MOVLW  28
00E58:  MOVWF  FC6
00E5A:  BCF    FC7.7
00E5C:  BCF    FC7.6
00E5E:  BCF    1A.2
00E60:  CLRF   1B
00E62:  CLRF   1F
00E64:  CLRF   1E
00E66:  CLRF   39
00E68:  CLRF   41
00E6A:  CLRF   40
00E6C:  CLRF   3F
00E6E:  CLRF   3E
00E70:  CLRF   49
00E72:  CLRF   48
00E74:  CLRF   4A
00E76:  BSF    1A.3
00E78:  BCF    4C.0
00E7A:  MOVF   FC1,W
00E7C:  ANDLW  C0
00E7E:  IORLW  0F
00E80:  MOVWF  FC1
00E82:  MOVLW  07
00E84:  MOVWF  FB4
00E86:  MOVLW  54
00E88:  MOVWF  4E
00E8A:  MOVLW  50
00E8C:  MOVWF  4F
00E8E:  MOVLW  41
00E90:  MOVWF  50
00E92:  MOVLW  48
00E94:  MOVWF  51
00E96:  MOVLW  56
00E98:  MOVWF  52
00E9A:  CLRF   53
00E9C:  CLRF   54
00E9E:  CLRF   55
....................     
....................    /*SETUP*/ 
....................    setup_adc_ports( AN0_TO_AN2 ); 
00EA0:  MOVF   FC1,W
00EA2:  ANDLW  C0
00EA4:  IORLW  0C
00EA6:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_64); 
00EA8:  MOVF   FC0,W
00EAA:  ANDLW  C0
00EAC:  IORLW  06
00EAE:  MOVWF  FC0
00EB0:  BSF    FC0.7
00EB2:  BSF    FC2.0
....................  
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
00EB4:  MOVLW  B5
00EB6:  MOVWF  FCD
....................    setup_timer_3(T3_INTERNAL|T3_DIV_BY_8); 
00EB8:  MOVWF  FB1
....................  
....................    //enable_interrupts(INT_RDA); 
....................    //enable_interrupts(INT_TIMER1);  
....................  
....................    enable_interrupts(INT_TIMER3);  
00EBA:  BSF    FA0.1
....................    enable_interrupts(GLOBAL);    
00EBC:  MOVLW  C0
00EBE:  IORWF  FF2,F
....................     
....................    /*END**SETUP*/ 
....................     
....................    
....................     
....................    /*Iniciamos el DHT22*/ 
....................    //iniciar_dht(); 
....................     
....................    /*Calibramos el BMP085*/ 
....................    //BMP085_Calibration();    
....................     
....................  
....................  
....................    /* Entramos en el Bucle Principal*/ 
....................    While(1) 
....................    { 
....................        
....................  
....................       while(start_send>20) 
....................       { 
00EC0:  MOVF   41,F
00EC2:  BNZ   0ED4
00EC4:  MOVF   40,F
00EC6:  BNZ   0ED4
00EC8:  MOVF   3F,F
00ECA:  BNZ   0ED4
00ECC:  MOVF   3E,W
00ECE:  SUBLW  14
00ED0:  BTFSC  FD8.0
00ED2:  BRA    109E
....................          if(go) 
00ED4:  BTFSS  1A.3
00ED6:  BRA    0EE2
....................          { 
....................             aux_multp=0; 
00ED8:  CLRF   3D
00EDA:  CLRF   3C
00EDC:  CLRF   3B
00EDE:  CLRF   3A
....................             go=0; 
00EE0:  BCF    1A.3
....................          } 
....................  
....................          if((aux_multp>0)&&(polled_vel==0))           //Velocidad 
00EE2:  MOVF   3A,F
00EE4:  BNZ   0EF2
00EE6:  MOVF   3B,F
00EE8:  BNZ   0EF2
00EEA:  MOVF   3C,F
00EEC:  BNZ   0EF2
00EEE:  MOVF   3D,F
00EF0:  BZ    0EFC
00EF2:  BTFSC  1A.4
00EF4:  BRA    0EFC
....................          { 
....................             poll_vel(); 
00EF6:  BRA    0970
....................             polled_vel=1; 
00EF8:  BSF    1A.4
....................          } 
....................          else if((aux_multp>25)&&(polled_bmp==0))     //BMP 
00EFA:  BRA    109C
00EFC:  MOVF   3D,F
00EFE:  BNZ   0F0E
00F00:  MOVF   3C,F
00F02:  BNZ   0F0E
00F04:  MOVF   3B,F
00F06:  BNZ   0F0E
00F08:  MOVF   3A,W
00F0A:  SUBLW  19
00F0C:  BC    0F9A
00F0E:  BTFSC  1A.5
00F10:  BRA    0F9A
....................          { 
....................             //poll_bmp(); 
....................             char ttbmp[] = "263"; 
00F12:  MOVLW  32
00F14:  MOVWF  x76
00F16:  MOVLW  36
00F18:  MOVWF  x77
00F1A:  MOVLW  33
00F1C:  MOVWF  x78
00F1E:  CLRF   x79
....................             printf("%c",type[0]); 
00F20:  MOVF   4E,W
00F22:  BTFSS  F9E.4
00F24:  BRA    0F22
00F26:  MOVWF  FAD
....................             printf("%s\r",tbmp); 
00F28:  MOVFF  21,FEA
00F2C:  MOVFF  20,FE9
00F30:  RCALL  0B5C
00F32:  MOVLW  0D
00F34:  BTFSS  F9E.4
00F36:  BRA    0F34
00F38:  MOVWF  FAD
....................  
....................             char tpbmp[] = "8541"; 
00F3A:  MOVLW  38
00F3C:  MOVWF  x7A
00F3E:  MOVLW  35
00F40:  MOVWF  x7B
00F42:  MOVLW  34
00F44:  MOVWF  x7C
00F46:  MOVLW  31
00F48:  MOVWF  x7D
00F4A:  CLRF   x7E
....................             printf("%c",type[1]); 
00F4C:  MOVF   4F,W
00F4E:  BTFSS  F9E.4
00F50:  BRA    0F4E
00F52:  MOVWF  FAD
....................             printf("%s\r",pbmp); 
00F54:  MOVFF  25,FEA
00F58:  MOVFF  24,FE9
00F5C:  RCALL  0B5C
00F5E:  MOVLW  0D
00F60:  BTFSS  F9E.4
00F62:  BRA    0F60
00F64:  MOVWF  FAD
....................  
....................             char tabmp[] = "15241"; 
00F66:  MOVLW  31
00F68:  MOVWF  x7F
00F6A:  MOVLW  35
00F6C:  MOVWF  x80
00F6E:  MOVLW  32
00F70:  MOVWF  x81
00F72:  MOVLW  34
00F74:  MOVWF  x82
00F76:  MOVLW  31
00F78:  MOVWF  x83
00F7A:  CLRF   x84
....................             printf("%c",type[2]); 
00F7C:  MOVF   50,W
00F7E:  BTFSS  F9E.4
00F80:  BRA    0F7E
00F82:  MOVWF  FAD
....................             printf("%s\r",abmp); 
00F84:  MOVFF  29,FEA
00F88:  MOVFF  28,FE9
00F8C:  RCALL  0B5C
00F8E:  MOVLW  0D
00F90:  BTFSS  F9E.4
00F92:  BRA    0F90
00F94:  MOVWF  FAD
....................  
....................             polled_bmp=1; 
00F96:  BSF    1A.5
....................          } 
....................          else if((aux_multp>50)&&(polled_dht==0))     //DHT 
00F98:  BRA    109C
00F9A:  MOVF   3D,F
00F9C:  BNZ   0FAC
00F9E:  MOVF   3C,F
00FA0:  BNZ   0FAC
00FA2:  MOVF   3B,F
00FA4:  BNZ   0FAC
00FA6:  MOVF   3A,W
00FA8:  SUBLW  32
00FAA:  BC    0FDA
00FAC:  BTFSC  1A.6
00FAE:  BRA    0FDA
....................          { 
....................             //poll_dht(); 
....................             dhth = 654; 
00FB0:  MOVLW  02
00FB2:  MOVWF  1D
00FB4:  MOVLW  8E
00FB6:  MOVWF  1C
....................             printf("%c",type[3]); 
00FB8:  MOVF   51,W
00FBA:  BTFSS  F9E.4
00FBC:  BRA    0FBA
00FBE:  MOVWF  FAD
....................             printf("%Ld\r",dhth); 
00FC0:  MOVLW  10
00FC2:  MOVWF  FE9
00FC4:  MOVFF  1D,86
00FC8:  MOVFF  1C,85
00FCC:  RCALL  0894
00FCE:  MOVLW  0D
00FD0:  BTFSS  F9E.4
00FD2:  BRA    0FD0
00FD4:  MOVWF  FAD
....................  
....................             polled_dht=1; 
00FD6:  BSF    1A.6
....................          }   
....................          else if((aux_multp>75)&&(polled_light==0))   //Luz 
00FD8:  BRA    109C
00FDA:  MOVF   3D,F
00FDC:  BNZ   0FEC
00FDE:  MOVF   3C,F
00FE0:  BNZ   0FEC
00FE2:  MOVF   3B,F
00FE4:  BNZ   0FEC
00FE6:  MOVF   3A,W
00FE8:  SUBLW  4B
00FEA:  BC    105A
00FEC:  BTFSC  1A.7
00FEE:  BRA    105A
....................          { 
....................             poll_light(); 
00FF0:  BRA    0C80
....................             if((ls=8)||(ls=9)) 
00FF2:  MOVLW  08
00FF4:  MOVWF  4A
00FF6:  MOVF   4A,F
00FF8:  BNZ   1002
00FFA:  MOVLW  09
00FFC:  MOVWF  4A
00FFE:  MOVF   4A,F
01000:  BZ    1008
....................             { 
....................                weather = 1;                
01002:  MOVLW  01
01004:  MOVWF  4B
....................             } 
....................             else if((ls<8)&&(dhth<750)) 
01006:  BRA    103C
01008:  MOVF   4A,W
0100A:  SUBLW  07
0100C:  BNC   1022
0100E:  MOVF   1D,W
01010:  SUBLW  02
01012:  BNC   1022
01014:  BNZ   101C
01016:  MOVF   1C,W
01018:  SUBLW  ED
0101A:  BNC   1022
....................             { 
....................                weather = 2; 
0101C:  MOVLW  02
0101E:  MOVWF  4B
....................             } 
....................             else if((ls<8)&&(dhth>750)) 
01020:  BRA    103C
01022:  MOVF   4A,W
01024:  SUBLW  07
01026:  BNC   103C
01028:  MOVF   1D,W
0102A:  SUBLW  01
0102C:  BC    103C
0102E:  XORLW  FF
01030:  BNZ   1038
01032:  MOVF   1C,W
01034:  SUBLW  EE
01036:  BC    103C
....................             { 
....................                weather = 3; 
01038:  MOVLW  03
0103A:  MOVWF  4B
....................             } 
....................  
....................             printf("W%u\r",weather); 
0103C:  MOVLW  57
0103E:  BTFSS  F9E.4
01040:  BRA    103E
01042:  MOVWF  FAD
01044:  MOVFF  4B,85
01048:  MOVLW  1B
0104A:  MOVWF  x86
0104C:  RCALL  0C14
0104E:  MOVLW  0D
01050:  BTFSS  F9E.4
01052:  BRA    1050
01054:  MOVWF  FAD
....................  
....................             polled_light=1;             
01056:  BSF    1A.7
....................          } 
....................          else if((aux_multp>100)&&(polled_dir==0))  //Direccion 
01058:  BRA    109C
0105A:  MOVF   3D,F
0105C:  BNZ   106C
0105E:  MOVF   3C,F
01060:  BNZ   106C
01062:  MOVF   3B,F
01064:  BNZ   106C
01066:  MOVF   3A,W
01068:  SUBLW  64
0106A:  BC    1076
0106C:  BTFSC  4C.0
0106E:  BRA    1076
....................          { 
....................             poll_dir(); 
01070:  BRA    0E00
....................  
....................             polled_dir=1; 
01072:  BSF    4C.0
....................          } 
....................          else if(aux_multp>125) 
01074:  BRA    109C
01076:  MOVF   3D,F
01078:  BNZ   1088
0107A:  MOVF   3C,F
0107C:  BNZ   1088
0107E:  MOVF   3B,F
01080:  BNZ   1088
01082:  MOVF   3A,W
01084:  SUBLW  7D
01086:  BC    109C
....................          { 
....................             polled_vel=0; 
01088:  BCF    1A.4
....................             polled_bmp=0; 
0108A:  BCF    1A.5
....................             polled_dht=0; 
0108C:  BCF    1A.6
....................             polled_light=0; 
0108E:  BCF    1A.7
....................             polled_dir=0; 
01090:  BCF    4C.0
....................  
....................             start_send=0; 
01092:  CLRF   41
01094:  CLRF   40
01096:  CLRF   3F
01098:  CLRF   3E
....................             go=1; 
0109A:  BSF    1A.3
....................          } 
....................  
....................       } 
0109C:  BRA    0EC0
....................        
....................        
....................        
....................        
....................       //ENDWHILE 
....................    } 
0109E:  BRA    0EC0
....................     
....................     
....................     
....................     
....................     
....................    //ENDMAIN 
.................... } 
....................  
....................  
.................... void poll_vel() 
.................... { 
010A0:  SLEEP 
....................     
....................    enable_interrupts(INT_TIMER1);    
*
00970:  BSF    F9D.0
....................    enable_interrupts(INT_EXT_H2L);   
00972:  BSF    FF2.4
00974:  BCF    FF1.6
....................    set_timer1(0); 
00976:  CLRF   FCF
00978:  CLRF   FCE
....................  
....................    while(1) 
....................    { 
....................       if(tim1>20) 
0097A:  MOVF   38,W
0097C:  SUBLW  14
0097E:  BC    09BA
....................       { 
....................          vel = 0; 
00980:  CLRF   33
00982:  CLRF   32
00984:  CLRF   31
00986:  CLRF   30
....................          printf("%c",type[4]); 
00988:  MOVF   52,W
0098A:  BTFSS  F9E.4
0098C:  BRA    098A
0098E:  MOVWF  FAD
....................          printf("%g\n",vel); 
00990:  MOVLW  89
00992:  MOVWF  FE9
00994:  MOVFF  33,88
00998:  MOVFF  32,87
0099C:  MOVFF  31,86
009A0:  MOVFF  30,85
009A4:  MOVLW  02
009A6:  MOVWF  x89
009A8:  BRA    0542
009AA:  MOVLW  0A
009AC:  BTFSS  F9E.4
009AE:  BRA    09AC
009B0:  MOVWF  FAD
....................          tim1=0; 
009B2:  CLRF   38
....................          ext=0; 
009B4:  CLRF   39
....................          set_timer1(0); 
009B6:  CLRF   FCF
009B8:  CLRF   FCE
....................       } 
....................       if(ext==1) 
009BA:  DECFSZ 39,W
009BC:  BRA    0B3E
....................       { 
....................          timer = get_timer1(); 
009BE:  MOVF   FCE,W
009C0:  MOVFF  FCF,03
009C4:  MOVWF  x85
009C6:  MOVFF  FCF,86
009CA:  RCALL  0704
009CC:  MOVFF  03,2F
009D0:  MOVFF  02,2E
009D4:  MOVFF  01,2D
009D8:  MOVFF  00,2C
....................  
....................          timer = timer * 0.000004; 
009DC:  MOVFF  2F,95
009E0:  MOVFF  2E,94
009E4:  MOVFF  2D,93
009E8:  MOVFF  2C,92
009EC:  MOVLW  BD
009EE:  MOVWF  x99
009F0:  MOVLW  37
009F2:  MOVWF  x98
009F4:  MOVLW  06
009F6:  MOVWF  x97
009F8:  MOVLW  6D
009FA:  MOVWF  x96
009FC:  CALL   0118
00A00:  MOVFF  03,2F
00A04:  MOVFF  02,2E
00A08:  MOVFF  01,2D
00A0C:  MOVFF  00,2C
....................           
....................          aux = tim1 * 0.065536; 
00A10:  CLRF   x86
00A12:  MOVFF  38,85
00A16:  RCALL  0704
00A18:  MOVFF  03,95
00A1C:  MOVFF  02,94
00A20:  MOVFF  01,93
00A24:  MOVFF  00,92
00A28:  MOVLW  BD
00A2A:  MOVWF  x99
00A2C:  MOVLW  37
00A2E:  MOVWF  x98
00A30:  MOVLW  06
00A32:  MOVWF  x97
00A34:  MOVLW  7B
00A36:  MOVWF  x96
00A38:  CALL   0118
00A3C:  MOVFF  03,37
00A40:  MOVFF  02,36
00A44:  MOVFF  01,35
00A48:  MOVFF  00,34
....................           
....................          timer = timer + aux; 
00A4C:  BCF    FD8.1
00A4E:  MOVFF  2F,95
00A52:  MOVFF  2E,94
00A56:  MOVFF  2D,93
00A5A:  MOVFF  2C,92
00A5E:  MOVFF  37,99
00A62:  MOVFF  36,98
00A66:  MOVFF  35,97
00A6A:  MOVFF  34,96
00A6E:  CALL   020A
00A72:  MOVFF  03,2F
00A76:  MOVFF  02,2E
00A7A:  MOVFF  01,2D
00A7E:  MOVFF  00,2C
....................          vel = 0.0942/timer; 
00A82:  MOVLW  EE
00A84:  MOVWF  x88
00A86:  MOVLW  EB
00A88:  MOVWF  x87
00A8A:  MOVLW  40
00A8C:  MOVWF  x86
00A8E:  MOVLW  7B
00A90:  MOVWF  x85
00A92:  MOVFF  2F,8C
00A96:  MOVFF  2E,8B
00A9A:  MOVFF  2D,8A
00A9E:  MOVFF  2C,89
00AA2:  RCALL  073A
00AA4:  MOVFF  03,33
00AA8:  MOVFF  02,32
00AAC:  MOVFF  01,31
00AB0:  MOVFF  00,30
....................          vel = vel/0.5144; 
00AB4:  MOVFF  33,88
00AB8:  MOVFF  32,87
00ABC:  MOVFF  31,86
00AC0:  MOVFF  30,85
00AC4:  MOVLW  B8
00AC6:  MOVWF  x8C
00AC8:  MOVLW  AF
00ACA:  MOVWF  x8B
00ACC:  MOVLW  03
00ACE:  MOVWF  x8A
00AD0:  MOVLW  7E
00AD2:  MOVWF  x89
00AD4:  RCALL  073A
00AD6:  MOVFF  03,33
00ADA:  MOVFF  02,32
00ADE:  MOVFF  01,31
00AE2:  MOVFF  00,30
....................  
....................          vel = vel*10; 
00AE6:  MOVFF  33,95
00AEA:  MOVFF  32,94
00AEE:  MOVFF  31,93
00AF2:  MOVFF  30,92
00AF6:  CLRF   x99
00AF8:  CLRF   x98
00AFA:  MOVLW  20
00AFC:  MOVWF  x97
00AFE:  MOVLW  82
00B00:  MOVWF  x96
00B02:  CALL   0118
00B06:  MOVFF  03,33
00B0A:  MOVFF  02,32
00B0E:  MOVFF  01,31
00B12:  MOVFF  00,30
....................          printf("%c",type[4]); 
00B16:  MOVF   52,W
00B18:  BTFSS  F9E.4
00B1A:  BRA    0B18
00B1C:  MOVWF  FAD
....................          printf("%Ld\r",vel); 
00B1E:  MOVLW  10
00B20:  MOVWF  FE9
00B22:  MOVFF  31,86
00B26:  MOVFF  30,85
00B2A:  RCALL  0894
00B2C:  MOVLW  0D
00B2E:  BTFSS  F9E.4
00B30:  BRA    0B2E
00B32:  MOVWF  FAD
....................      
....................        
....................  
....................          tim1=0; 
00B34:  CLRF   38
....................          ext=0; 
00B36:  CLRF   39
....................          set_timer1(0); 
00B38:  CLRF   FCF
00B3A:  CLRF   FCE
....................          break; 
00B3C:  BRA    0B54
....................  
....................       } 
....................       if(aux_multp>24) 
00B3E:  MOVF   3D,F
00B40:  BNZ   0B50
00B42:  MOVF   3C,F
00B44:  BNZ   0B50
00B46:  MOVF   3B,F
00B48:  BNZ   0B50
00B4A:  MOVF   3A,W
00B4C:  SUBLW  18
00B4E:  BC    0B52
....................       { 
....................          break; 
00B50:  BRA    0B54
....................       } 
....................    } 
00B52:  BRA    097A
....................     
....................    disable_interrupts(INT_TIMER1);    
00B54:  BCF    F9D.0
....................    disable_interrupts(INT_EXT_H2L);   
00B56:  BCF    FF2.4
....................     
.................... } 
00B58:  GOTO   0EF8 (RETURN)
....................  
.................... void poll_light() 
.................... { 
....................     
....................  
....................    set_adc_channel(0); 
*
00C80:  MOVLW  00
00C82:  MOVWF  01
00C84:  MOVF   FC2,W
00C86:  ANDLW  C3
00C88:  IORWF  01,W
00C8A:  MOVWF  FC2
....................    delay_us(10); 
00C8C:  MOVLW  06
00C8E:  MOVWF  00
00C90:  DECFSZ 00,F
00C92:  BRA    0C90
00C94:  NOP   
....................    ls0 = read_adc(); 
00C96:  BSF    FC2.1
00C98:  BTFSC  FC2.1
00C9A:  BRA    0C98
00C9C:  MOVFF  FC3,44
00CA0:  MOVFF  FC4,45
....................    delay_ms(10); 
00CA4:  MOVLW  0A
00CA6:  MOVWF  x85
00CA8:  RCALL  0B82
....................    set_adc_channel(1); 
00CAA:  MOVLW  04
00CAC:  MOVWF  01
00CAE:  MOVF   FC2,W
00CB0:  ANDLW  C3
00CB2:  IORWF  01,W
00CB4:  MOVWF  FC2
....................    delay_us(10); 
00CB6:  MOVLW  06
00CB8:  MOVWF  00
00CBA:  DECFSZ 00,F
00CBC:  BRA    0CBA
00CBE:  NOP   
....................    ls1 = read_adc(); 
00CC0:  BSF    FC2.1
00CC2:  BTFSC  FC2.1
00CC4:  BRA    0CC2
00CC6:  MOVFF  FC3,46
00CCA:  MOVFF  FC4,47
....................    delay_ms(10); 
00CCE:  MOVLW  0A
00CD0:  MOVWF  x85
00CD2:  RCALL  0B82
....................    set_adc_channel(2); 
00CD4:  MOVLW  08
00CD6:  MOVWF  01
00CD8:  MOVF   FC2,W
00CDA:  ANDLW  C3
00CDC:  IORWF  01,W
00CDE:  MOVWF  FC2
....................    delay_us(10); 
00CE0:  MOVLW  06
00CE2:  MOVWF  00
00CE4:  DECFSZ 00,F
00CE6:  BRA    0CE4
00CE8:  NOP   
....................    ls2 = read_adc(); 
00CEA:  BSF    FC2.1
00CEC:  BTFSC  FC2.1
00CEE:  BRA    0CEC
00CF0:  MOVFF  FC3,48
00CF4:  MOVFF  FC4,49
....................  
....................    pr_light=(ls0+ls1+ls2)/3; //Promedio 
00CF8:  MOVF   46,W
00CFA:  ADDWF  44,W
00CFC:  MOVWF  x85
00CFE:  MOVF   47,W
00D00:  ADDWFC 45,W
00D02:  MOVWF  x86
00D04:  MOVF   48,W
00D06:  ADDWF  x85,F
00D08:  MOVF   49,W
00D0A:  ADDWFC x86,F
00D0C:  MOVFF  86,88
00D10:  MOVFF  85,87
00D14:  CLRF   x8A
00D16:  MOVLW  03
00D18:  MOVWF  x89
00D1A:  BRA    0BA8
00D1C:  MOVFF  02,43
00D20:  MOVFF  01,42
....................    if(pr_light<103) 
00D24:  MOVF   43,F
00D26:  BNZ   0D32
00D28:  MOVF   42,W
00D2A:  SUBLW  66
00D2C:  BNC   0D32
....................    { 
....................       ls=0; 
00D2E:  CLRF   4A
....................    } 
....................    else if (pr_light<206) 
00D30:  BRA    0DE2
00D32:  MOVF   43,F
00D34:  BNZ   0D42
00D36:  MOVF   42,W
00D38:  SUBLW  CD
00D3A:  BNC   0D42
....................    { 
....................       ls=1;   
00D3C:  MOVLW  01
00D3E:  MOVWF  4A
....................    } 
....................    else if (pr_light<309) 
00D40:  BRA    0DE2
00D42:  MOVF   43,W
00D44:  SUBLW  01
00D46:  BNC   0D56
00D48:  BNZ   0D50
00D4A:  MOVF   42,W
00D4C:  SUBLW  34
00D4E:  BNC   0D56
....................    { 
....................       ls=2; 
00D50:  MOVLW  02
00D52:  MOVWF  4A
....................    } 
....................    else if (pr_light<412) 
00D54:  BRA    0DE2
00D56:  MOVF   43,W
00D58:  SUBLW  01
00D5A:  BNC   0D6A
00D5C:  BNZ   0D64
00D5E:  MOVF   42,W
00D60:  SUBLW  9B
00D62:  BNC   0D6A
....................    { 
....................       ls=3; 
00D64:  MOVLW  03
00D66:  MOVWF  4A
....................    } 
....................    else if (pr_light<515) 
00D68:  BRA    0DE2
00D6A:  MOVF   43,W
00D6C:  SUBLW  02
00D6E:  BNC   0D7E
00D70:  BNZ   0D78
00D72:  MOVF   42,W
00D74:  SUBLW  02
00D76:  BNC   0D7E
....................    { 
....................       ls=4; 
00D78:  MOVLW  04
00D7A:  MOVWF  4A
....................    } 
....................    else if (pr_light<618) 
00D7C:  BRA    0DE2
00D7E:  MOVF   43,W
00D80:  SUBLW  02
00D82:  BNC   0D92
00D84:  BNZ   0D8C
00D86:  MOVF   42,W
00D88:  SUBLW  69
00D8A:  BNC   0D92
....................    { 
....................       ls=5; 
00D8C:  MOVLW  05
00D8E:  MOVWF  4A
....................    } 
....................    else if (pr_light<721) 
00D90:  BRA    0DE2
00D92:  MOVF   43,W
00D94:  SUBLW  02
00D96:  BNC   0DA6
00D98:  BNZ   0DA0
00D9A:  MOVF   42,W
00D9C:  SUBLW  D0
00D9E:  BNC   0DA6
....................    { 
....................       ls=6; 
00DA0:  MOVLW  06
00DA2:  MOVWF  4A
....................    } 
....................    else if (pr_light<824) 
00DA4:  BRA    0DE2
00DA6:  MOVF   43,W
00DA8:  SUBLW  03
00DAA:  BNC   0DBA
00DAC:  BNZ   0DB4
00DAE:  MOVF   42,W
00DB0:  SUBLW  37
00DB2:  BNC   0DBA
....................    { 
....................       ls=7; 
00DB4:  MOVLW  07
00DB6:  MOVWF  4A
....................    } 
....................    else if (pr_light<927) 
00DB8:  BRA    0DE2
00DBA:  MOVF   43,W
00DBC:  SUBLW  03
00DBE:  BNC   0DCE
00DC0:  BNZ   0DC8
00DC2:  MOVF   42,W
00DC4:  SUBLW  9E
00DC6:  BNC   0DCE
....................    { 
....................       ls=8; 
00DC8:  MOVLW  08
00DCA:  MOVWF  4A
....................    } 
....................    else if (pr_light>=927)    
00DCC:  BRA    0DE2
00DCE:  MOVF   43,W
00DD0:  SUBLW  02
00DD2:  BC    0DE2
00DD4:  XORLW  FF
00DD6:  BNZ   0DDE
00DD8:  MOVF   42,W
00DDA:  SUBLW  9E
00DDC:  BC    0DE2
....................    { 
....................       ls=9; 
00DDE:  MOVLW  09
00DE0:  MOVWF  4A
....................    } 
....................    printf("L%u\r",ls); 
00DE2:  MOVLW  4C
00DE4:  BTFSS  F9E.4
00DE6:  BRA    0DE4
00DE8:  MOVWF  FAD
00DEA:  MOVFF  4A,85
00DEE:  MOVLW  1B
00DF0:  MOVWF  x86
00DF2:  RCALL  0C14
00DF4:  MOVLW  0D
00DF6:  BTFSS  F9E.4
00DF8:  BRA    0DF6
00DFA:  MOVWF  FAD
....................  
....................    
.................... } 
00DFC:  GOTO   0FF2 (RETURN)
....................  
.................... void poll_bmp() 
.................... { 
....................    bmp085Convert(&tbmp,&pbmp); 
....................    abmp = 44330*(1-(pow((pbmp/1013.25),(1/5.255)))); 
....................  
....................    tbmp = tbmp*10; 
....................    printf("%c",type[0]); 
....................    printf("%Ld\r",tbmp); 
....................  
....................    pbmp = pbmp*10; 
....................    printf("%c",type[1]); 
....................    printf("%Ld\r",pbmp); 
....................  
....................    abmp = abmp*10; 
....................    printf("%c",type[2]); 
....................    printf("%Ld\r",abmp); 
....................  
.................... } 
....................  
.................... void poll_dht() 
.................... { 
....................    leer_dht(&dhth,&dhtt); 
....................    printf("%c",type[3]); 
....................    printf("%Ld\r",dhth); 
.................... } 
....................  
.................... void poll_dir() 
.................... { 
....................    dir0 = input(PIN_DIR0); 
00E00:  BSF    F95.0
00E02:  BCF    1A.0
00E04:  BTFSC  F83.0
00E06:  BSF    1A.0
....................    dir1 = input(PIN_DIR1); 
00E08:  BSF    F95.1
00E0A:  BCF    1A.1
00E0C:  BTFSC  F83.1
00E0E:  BSF    1A.1
....................    dir2 = input(PIN_DIR2); 
00E10:  BSF    F95.2
00E12:  BCF    1A.2
00E14:  BTFSC  F83.2
00E16:  BSF    1A.2
....................  
....................    if(!dir2) 
00E18:  BTFSC  1A.2
00E1A:  BRA    0E20
....................    { 
....................       dir += 4; 
00E1C:  MOVLW  04
00E1E:  ADDWF  1B,F
....................    } 
....................    if(!dir1) 
00E20:  BTFSC  1A.1
00E22:  BRA    0E28
....................    { 
....................       dir += 2; 
00E24:  MOVLW  02
00E26:  ADDWF  1B,F
....................    } 
....................    if(!dir0) 
00E28:  BTFSC  1A.0
00E2A:  BRA    0E30
....................    { 
....................       dir += 1; 
00E2C:  MOVLW  01
00E2E:  ADDWF  1B,F
....................    } 
....................  
.................... } 
00E30:  GOTO   1072 (RETURN)

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV21 NOWDT WDT128
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
