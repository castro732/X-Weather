CCS PCH C Compiler, Version 4.104, 5967               03-mar-12 15:35

               Filename: C:\Users\MrDarkness\X-Weather\Config\config.lst

               ROM used: 12176 bytes (19%)
                         Largest free fragment is 53360
               RAM used: 1208 (36%) at main() level
                         1258 (38%) worst case
               Stack:    7 locations

*
00000:  GOTO   2D14
.................... #include "config.h" 
.................... #include <18F4680.h> 
.................... //////// Standard Header file for the PIC18F4680 device //////////////// 
.................... #device PIC18F4680 
.................... #list 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
.................... //#FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BBSIZ1K                  //1K words Boot Block size 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
....................  
.................... #use delay(crystal=8000000) 
*
004B0:  MOVLW  04
004B2:  MOVWF  FEA
004B4:  MOVLW  B8
004B6:  MOVWF  FE9
004B8:  MOVF   FEF,W
004BA:  BZ    04D6
004BC:  MOVLW  02
004BE:  MOVWF  01
004C0:  CLRF   00
004C2:  DECFSZ 00,F
004C4:  BRA    04C2
004C6:  DECFSZ 01,F
004C8:  BRA    04C0
004CA:  MOVLW  97
004CC:  MOVWF  00
004CE:  DECFSZ 00,F
004D0:  BRA    04CE
004D2:  DECFSZ FEF,F
004D4:  BRA    04BC
004D6:  GOTO   2F8C (RETURN)
.................... #use rs232(baud=115200,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,errors) 
....................  
....................  
....................  
.................... /*DEFINICIONES*/   
....................  
.................... #define FAST_GLCD 
....................  
....................  
.................... #DEFINE PIN_UP       PIN_A0 
.................... #DEFINE PIN_LEFT     PIN_A1 
.................... #DEFINE PIN_RIGHT    PIN_A2 
.................... #DEFINE PIN_DOWN     PIN_A3 
.................... #DEFINE PIN_ENTER    PIN_A4 
.................... #DEFINE PIN_CANCEL   PIN_A5 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /*FIN**DEFINICIONES*/   
....................  
....................  
.................... /****/ 
....................  
....................  
.................... /*VARIABLES**GLOBALES*/ 
....................  
.................... int i = 0; 
....................  
....................  
....................  
.................... int8 control = 0; 
....................  
.................... int pressed = 0; 
.................... int config; 
.................... int confpos,conftype,selconf; 
.................... int up,lastup; 
.................... int down,lastdown; 
.................... int enter,lastenter; 
.................... int left,lastleft; 
.................... int lastright,right; 
....................  
.................... /*MENU*/ 
....................  
.................... char MENUTITLE[] = "Configuracion"; 
....................  
.................... char MENU1[] =   "-Fecha y Hora"; 
....................  
.................... char MENU2[] =   "-Temperatura   "; 
....................  
.................... char MENU2ITEM1[] = "--Celsius"; 
.................... char MENU2ITEM2[] = "--Farenheit"; 
....................  
.................... char MENU3[] =   "-Presion"; 
.................... char MENU3ITEM1[] = "--Pascal"; 
.................... char MENU3ITEM2[] = "--Milibar"; 
....................  
....................  
.................... char MENU4[] =   "-Velocidad"; 
.................... char MENU4ITEM1[] = "--m/s"; 
.................... char MENU4ITEM2[] = "--km/h"; 
.................... char MENU4ITEM3[] = "--Nudos"; 
....................  
....................  
.................... char dia[] = "01"; 
.................... char mes[] = "01"; 
.................... char ao[] = "01"; 
.................... char hora[] = "10"; 
.................... char min[] = "10"; 
.................... char aop[] = "AM"; 
....................  
....................  
.................... char UniTemp[] = "C"; 
.................... char UniPres[] = "Pa "; 
....................  
.................... char UniVel[] = "m/s "; 
....................  
....................  
.................... /*FIN**VARIBLES**GLOBALES*/ 
....................  
....................  
....................  
.................... /****/ 
....................  
....................  
.................... /**INCLUDES**/ 
....................  
.................... #include "HDM64GS12.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           HDM64GS12.c                           //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// a KS0108 display controller. The HDM64GS12 is 128 by 64 pixels. //// 
.................... //// The driver treats the upper left pixel as (0,0).                //// 
.................... ////                                                                 //// 
.................... //// Use #define FAST_GLCD if the target chip has at least 1k of RAM //// 
.................... //// to decrease the time it takes to update the display.            //// 
.................... //// glcd_update() must then be called to update the display after   //// 
.................... //// changing the pixel information.                                 //// 
.................... //// See ex_glcd.c for suggested usage.                              //// 
.................... //// See KS0108.c for controlling a single 64 by 64 display          //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0  - LCD operating voltage (Constrast adjustment)        //// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_update()                                                  //// 
.................... ////     * Write the display data stored in RAM to the LCD           //// 
.................... ////     * Only available if FAST_GLCD is defined                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef HDM64GS12 
.................... #define HDM64GS12 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH   128 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1     PIN_B1   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2     PIN_B0   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI      PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW      PIN_B3   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E       PIN_B4   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST     PIN_B5   // Reset 
.................... #endif 
....................  
.................... #define GLCD_LEFT    0 
.................... #define GLCD_RIGHT   1 
....................  
.................... #ifndef ON 
.................... #define ON           1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF          0 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void glcd_init(int1 mode); 
.................... void glcd_pixel(int8 x, int8 y, int1 color); 
.................... void glcd_fillScreen(int1 color); 
.................... void glcd_writeByte(int1 side, BYTE data); 
.................... BYTE glcd_readByte(int1 side); 
.................... void glcd_update(); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef FAST_GLCD 
.................... struct 
.................... { 
....................    int8 left[512]; 
....................    int8 right[512]; 
.................... } displayData; 
.................... #endif 
....................  
....................  
.................... // Purpose:       Initialize the LCD. 
.................... //                Call before using any other LCD function. 
.................... // Inputs:        OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
00408:  BCF    F93.5
0040A:  BSF    F8A.5
....................    output_low(GLCD_E); 
0040C:  BCF    F93.4
0040E:  BCF    F8A.4
....................    output_low(GLCD_CS1); 
00410:  BCF    F93.1
00412:  BCF    F8A.1
....................    output_low(GLCD_CS2); 
00414:  BCF    F93.0
00416:  BCF    F8A.0
....................  
....................    output_low(GLCD_DI);                 // Set for instruction 
00418:  BCF    F93.2
0041A:  BCF    F8A.2
....................    glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top 
0041C:  MOVLB  4
0041E:  CLRF   xCA
00420:  MOVLW  C0
00422:  MOVWF  xCB
00424:  MOVLB  0
00426:  RCALL  02B6
....................    glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen 
00428:  MOVLW  01
0042A:  MOVLB  4
0042C:  MOVWF  xCA
0042E:  MOVLW  C0
00430:  MOVWF  xCB
00432:  MOVLB  0
00434:  RCALL  02B6
....................    glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0 
00436:  MOVLB  4
00438:  CLRF   xCA
0043A:  MOVLW  40
0043C:  MOVWF  xCB
0043E:  MOVLB  0
00440:  RCALL  02B6
....................    glcd_writeByte(GLCD_RIGHT, 0x40); 
00442:  MOVLW  01
00444:  MOVLB  4
00446:  MOVWF  xCA
00448:  MOVLW  40
0044A:  MOVWF  xCB
0044C:  MOVLB  0
0044E:  RCALL  02B6
....................    glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0 
00450:  MOVLB  4
00452:  CLRF   xCA
00454:  MOVLW  B8
00456:  MOVWF  xCB
00458:  MOVLB  0
0045A:  RCALL  02B6
....................    glcd_writeByte(GLCD_RIGHT, 0xB8); 
0045C:  MOVLW  01
0045E:  MOVLB  4
00460:  MOVWF  xCA
00462:  MOVLW  B8
00464:  MOVWF  xCB
00466:  MOVLB  0
00468:  RCALL  02B6
....................  
....................    if(mode == ON) 
0046A:  MOVLB  4
0046C:  DECFSZ xB8,W
0046E:  BRA    048C
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on 
00470:  CLRF   xCA
00472:  MOVLW  3F
00474:  MOVWF  xCB
00476:  MOVLB  0
00478:  RCALL  02B6
....................       glcd_writeByte(GLCD_RIGHT, 0x3F); 
0047A:  MOVLW  01
0047C:  MOVLB  4
0047E:  MOVWF  xCA
00480:  MOVLW  3F
00482:  MOVWF  xCB
00484:  MOVLB  0
00486:  RCALL  02B6
....................    } 
....................    else 
00488:  BRA    04A4
0048A:  MOVLB  4
....................    { 
....................       glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off 
0048C:  CLRF   xCA
0048E:  MOVLW  3E
00490:  MOVWF  xCB
00492:  MOVLB  0
00494:  RCALL  02B6
....................       glcd_writeByte(GLCD_RIGHT, 0x3E); 
00496:  MOVLW  01
00498:  MOVLB  4
0049A:  MOVWF  xCA
0049C:  MOVLW  3E
0049E:  MOVWF  xCB
004A0:  MOVLB  0
004A2:  RCALL  02B6
....................    } 
....................  
....................    glcd_fillScreen(OFF);                // Clear the display 
004A4:  MOVLB  4
004A6:  CLRF   xC3
004A8:  MOVLB  0
004AA:  RCALL  02F6
....................  
....................    #ifdef FAST_GLCD 
....................    glcd_update(); 
004AC:  RCALL  0350
....................    #endif 
.................... } 
004AE:  RETLW  00
....................  
....................  
.................... // Purpose:    Update the LCD with data from the display arrays 
.................... #ifdef FAST_GLCD 
.................... void glcd_update() 
.................... { 
....................    int8 i, j; 
....................    int8 *p1, *p2; 
....................  
....................    p1 = displayData.left; 
*
00350:  MOVLB  4
00352:  CLRF   xC6
00354:  MOVLW  B2
00356:  MOVWF  xC5
....................    p2 = displayData.right; 
00358:  MOVLW  02
0035A:  MOVWF  xC8
0035C:  MOVLW  B2
0035E:  MOVWF  xC7
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
00360:  CLRF   xC3
00362:  MOVF   xC3,W
00364:  SUBLW  07
00366:  BNC   0404
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
00368:  BCF    F93.2
0036A:  BCF    F8A.2
....................       glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0 
0036C:  CLRF   xCA
0036E:  MOVLW  40
00370:  MOVWF  xCB
00372:  MOVLB  0
00374:  RCALL  02B6
....................       glcd_writeByte(GLCD_RIGHT, 0x40); 
00376:  MOVLW  01
00378:  MOVLB  4
0037A:  MOVWF  xCA
0037C:  MOVLW  40
0037E:  MOVWF  xCB
00380:  MOVLB  0
00382:  RCALL  02B6
....................       glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address 
00384:  MOVLB  4
00386:  MOVF   xC3,W
00388:  IORLW  B8
0038A:  MOVWF  xC9
0038C:  CLRF   xCA
0038E:  MOVWF  xCB
00390:  MOVLB  0
00392:  RCALL  02B6
....................       glcd_writeByte(GLCD_RIGHT, i | 0xB8); 
00394:  MOVLB  4
00396:  MOVF   xC3,W
00398:  IORLW  B8
0039A:  MOVWF  xC9
0039C:  MOVLW  01
0039E:  MOVWF  xCA
003A0:  MOVFF  4C9,4CB
003A4:  MOVLB  0
003A6:  RCALL  02B6
....................       output_high(GLCD_DI);                     // Set for data 
003A8:  BCF    F93.2
003AA:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
003AC:  MOVLB  4
003AE:  CLRF   xC4
003B0:  MOVF   xC4,W
003B2:  SUBLW  3F
003B4:  BNC   0400
....................       { 
....................          glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off 
003B6:  MOVFF  4C6,03
003BA:  MOVF   xC5,W
003BC:  INCF   xC5,F
003BE:  BTFSC  FD8.2
003C0:  INCF   xC6,F
003C2:  MOVWF  FE9
003C4:  MOVFF  03,FEA
003C8:  MOVFF  FEF,4C9
003CC:  CLRF   xCA
003CE:  MOVFF  4C9,4CB
003D2:  MOVLB  0
003D4:  RCALL  02B6
....................          glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off 
003D6:  MOVLB  4
003D8:  MOVFF  4C8,03
003DC:  MOVF   xC7,W
003DE:  INCF   xC7,F
003E0:  BTFSC  FD8.2
003E2:  INCF   xC8,F
003E4:  MOVWF  FE9
003E6:  MOVFF  03,FEA
003EA:  MOVFF  FEF,4C9
003EE:  MOVLW  01
003F0:  MOVWF  xCA
003F2:  MOVFF  4C9,4CB
003F6:  MOVLB  0
003F8:  RCALL  02B6
....................       } 
003FA:  MOVLB  4
003FC:  INCF   xC4,F
003FE:  BRA    03B0
....................    } 
00400:  INCF   xC3,F
00402:  BRA    0362
.................... } 
00404:  MOVLB  0
00406:  RETLW  00
.................... #endif 
....................  
....................  
.................... // Purpose:    Turn a pixel on a graphic LCD on or off 
.................... // Inputs:     1) x - the x coordinate of the pixel 
.................... //             2) y - the y coordinate of the pixel 
.................... //             3) color - ON or OFF 
.................... void glcd_pixel(int8 x, int8 y, int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8* p; 
....................    int16 temp; 
....................    temp =  y/8; 
*
004DA:  MOVLB  4
004DC:  CLRF   xE7
004DE:  RRCF   xE2,W
004E0:  MOVWF  xE6
004E2:  RRCF   xE6,F
004E4:  RRCF   xE6,F
004E6:  MOVLW  1F
004E8:  ANDWF  xE6,F
....................    temp *= 64; 
004EA:  RLCF   xE6,F
004EC:  RLCF   xE7,F
004EE:  RLCF   xE6,F
004F0:  RLCF   xE7,F
004F2:  RLCF   xE6,F
004F4:  RLCF   xE7,F
004F6:  RLCF   xE6,F
004F8:  RLCF   xE7,F
004FA:  RLCF   xE6,F
004FC:  RLCF   xE7,F
004FE:  RLCF   xE6,F
00500:  RLCF   xE7,F
00502:  MOVLW  C0
00504:  ANDWF  xE6,F
....................    temp += x; 
00506:  MOVF   xE1,W
00508:  ADDWF  xE6,F
0050A:  MOVLW  00
0050C:  ADDWFC xE7,F
....................  
....................    if(x > 63) 
0050E:  MOVF   xE1,W
00510:  SUBLW  3F
00512:  BC    052E
....................    { 
....................       p = displayData.right + temp - 64; 
00514:  MOVLW  B2
00516:  ADDWF  xE6,W
00518:  MOVWF  xE8
0051A:  MOVLW  02
0051C:  ADDWFC xE7,W
0051E:  MOVWF  xE9
00520:  MOVLW  40
00522:  SUBWF  xE8,W
00524:  MOVWF  xE4
00526:  MOVLW  00
00528:  SUBWFB xE9,W
0052A:  MOVWF  xE5
....................    } 
....................    else 
0052C:  BRA    053A
....................    { 
....................       p = displayData.left + temp; 
0052E:  MOVLW  B2
00530:  ADDWF  xE6,W
00532:  MOVWF  xE4
00534:  MOVLW  00
00536:  ADDWFC xE7,W
00538:  MOVWF  xE5
....................    } 
....................  
....................    if(color) 
0053A:  MOVF   xE3,F
0053C:  BZ    0568
....................    { 
....................       bit_set(*p, y%8); 
0053E:  MOVFF  4E5,03
00542:  MOVFF  4E4,FE9
00546:  MOVFF  4E5,FEA
0054A:  MOVF   xE2,W
0054C:  ANDLW  07
0054E:  MOVWF  xE8
00550:  MOVLW  01
00552:  MOVWF  00
00554:  MOVF   xE8,W
00556:  MOVWF  01
00558:  BZ    0562
0055A:  BCF    FD8.0
0055C:  RLCF   00,F
0055E:  DECFSZ 01,F
00560:  BRA    055A
00562:  MOVF   00,W
00564:  IORWF  FEF,F
....................    } 
....................    else 
00566:  BRA    0592
....................    { 
....................       bit_clear(*p, y%8); 
00568:  MOVFF  4E5,03
0056C:  MOVFF  4E4,FE9
00570:  MOVFF  4E5,FEA
00574:  MOVF   xE2,W
00576:  ANDLW  07
00578:  MOVWF  xE8
0057A:  MOVLW  01
0057C:  MOVWF  00
0057E:  MOVF   xE8,W
00580:  MOVWF  01
00582:  BZ    058C
00584:  BCF    FD8.0
00586:  RLCF   00,F
00588:  DECFSZ 01,F
0058A:  BRA    0584
0058C:  MOVF   00,W
0058E:  XORLW  FF
00590:  ANDWF  FEF,F
....................    } 
.................... } 
00592:  MOVLB  0
00594:  RETLW  00
.................... #else 
.................... { 
....................    BYTE data; 
....................    int1 side = GLCD_LEFT;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)              // Check for first or second display area 
....................    { 
....................       x -= 64; 
....................       side = GLCD_RIGHT; 
....................    } 
....................  
....................    output_low(GLCD_DI);                         // Set for instruction 
....................    bit_clear(x,7);                              // Clear the MSB. Part of an instruction code 
....................    bit_set(x,6);                                // Set bit 6. Also part of an instruction code 
....................    glcd_writeByte(side, x);                     // Set the horizontal address 
....................    glcd_writeByte(side, (y/8 & 0xBF) | 0xB8);   // Set the vertical page address 
....................    output_high(GLCD_DI);                        // Set for data 
....................    glcd_readByte(side);                         // Need two reads to get data 
....................    data = glcd_readByte(side);                  //  at new address 
....................  
....................    if(color == ON) 
....................       bit_set(data, y%8);        // Turn the pixel on 
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
....................  
....................    output_low(GLCD_DI);          // Set for instruction 
....................    glcd_writeByte(side, x);      // Set the horizontal address 
....................    output_high(GLCD_DI);         // Set for data 
....................    glcd_writeByte(side, data);   // Write the pixel data 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Fill the LCD screen with the passed in color 
.................... // Inputs:     ON  - turn all the pixels on 
.................... //             OFF - turn all the pixels off 
.................... void glcd_fillScreen(int1 color) 
.................... #ifdef FAST_GLCD 
.................... { 
....................    int8  data; 
....................    int8  *p1, *p2; 
....................    int16 i; 
....................  
....................    p1 = displayData.left; 
*
002F6:  MOVLB  4
002F8:  CLRF   xC6
002FA:  MOVLW  B2
002FC:  MOVWF  xC5
....................    p2 = displayData.right; 
002FE:  MOVLW  02
00300:  MOVWF  xC8
00302:  MOVLW  B2
00304:  MOVWF  xC7
....................    data = 0xFF * color; 
00306:  MOVF   xC3,W
00308:  MULLW  FF
0030A:  MOVFF  FF3,4C4
....................  
....................    for(i=0; i<512; ++i) 
0030E:  CLRF   xCA
00310:  CLRF   xC9
00312:  MOVF   xCA,W
00314:  SUBLW  01
00316:  BNC   034C
....................    { 
....................       *p1++ = data; 
00318:  MOVFF  4C6,03
0031C:  MOVF   xC5,W
0031E:  INCF   xC5,F
00320:  BTFSC  FD8.2
00322:  INCF   xC6,F
00324:  MOVWF  FE9
00326:  MOVFF  03,FEA
0032A:  MOVFF  4C4,FEF
....................       *p2++ = data; 
0032E:  MOVFF  4C8,03
00332:  MOVF   xC7,W
00334:  INCF   xC7,F
00336:  BTFSC  FD8.2
00338:  INCF   xC8,F
0033A:  MOVWF  FE9
0033C:  MOVFF  03,FEA
00340:  MOVFF  4C4,FEF
....................    } 
00344:  INCF   xC9,F
00346:  BTFSC  FD8.2
00348:  INCF   xCA,F
0034A:  BRA    0312
.................... } 
0034C:  MOVLB  0
0034E:  RETLW  00
.................... #else 
.................... { 
....................    int8 i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_LEFT, 0b01000000);    // Set horizontal address to 0 
....................       glcd_writeByte(GLCD_RIGHT, 0b01000000); 
....................       glcd_writeByte(GLCD_LEFT, i | 0b10111000);// Set page address 
....................       glcd_writeByte(GLCD_RIGHT, i | 0b10111000); 
....................       output_high(GLCD_DI);                     // Set for data 
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
....................          glcd_writeByte(GLCD_LEFT, 0xFF*color);  // Turn pixels on or off 
....................          glcd_writeByte(GLCD_RIGHT, 0xFF*color); // Turn pixels on or off 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... // Purpose:    Write a byte of data to the specified chip 
.................... // Inputs:     1) chipSelect - which chip to write the data to 
.................... //             2) data - the byte of data to write 
.................... void glcd_writeByte(int1 side, BYTE data) 
.................... { 
....................    if(side)                   // Choose which side to write to 
*
002B6:  MOVLB  4
002B8:  MOVF   xCA,F
002BA:  BZ    02C2
....................       output_high(GLCD_CS2); 
002BC:  BCF    F93.0
002BE:  BSF    F8A.0
....................    else 
002C0:  BRA    02C6
....................       output_high(GLCD_CS1); 
002C2:  BCF    F93.1
002C4:  BSF    F8A.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
002C6:  BCF    F93.3
002C8:  BCF    F8A.3
....................    output_d(data);            // Put the data on the port 
002CA:  CLRF   F95
002CC:  MOVFF  4CB,F8C
....................    delay_cycles(16); 
002D0:  MOVLW  05
002D2:  MOVWF  00
002D4:  DECFSZ 00,F
002D6:  BRA    02D4
....................    output_high(GLCD_E);       // Pulse the enable pin 
002D8:  BCF    F93.4
002DA:  BSF    F8A.4
....................    delay_cycles(80); 
002DC:  MOVLW  1A
002DE:  MOVWF  00
002E0:  DECFSZ 00,F
002E2:  BRA    02E0
002E4:  NOP   
....................    output_low(GLCD_E); 
002E6:  BCF    F93.4
002E8:  BCF    F8A.4
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
002EA:  BCF    F93.1
002EC:  BCF    F8A.1
....................    output_low(GLCD_CS2); 
002EE:  BCF    F93.0
002F0:  BCF    F8A.0
.................... } 
002F2:  MOVLB  0
002F4:  RETLW  00
....................  
....................  
.................... // Purpose:    Reads a byte of data from the specified chip 
.................... // Ouputs:     A byte of data read from the chip 
.................... BYTE glcd_readByte(int1 side) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................  
....................    set_tris_d(0xFF);          // Set port d to input 
....................    output_high(GLCD_RW);      // Set for reading 
....................  
....................    if(side)                   // Choose which side to write to 
....................       output_high(GLCD_CS2); 
....................    else 
....................       output_high(GLCD_CS1); 
....................  
....................    delay_cycles(16); 
....................    output_high(GLCD_E);       // Pulse the enable pin 
....................    delay_cycles(64); 
....................    data = input_d();          // Get the data from the display's output register 
....................    output_low(GLCD_E); 
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
....................    output_low(GLCD_CS2); 
....................    return data;               // Return the read data 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "graphics.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          graphics.c                             //// 
.................... ////                                                                 //// 
.................... ////   This file contains functions to draw lines, rectangles, bars, //// 
.................... ////   circles and text to a display. A function which draws a       //// 
.................... ////   single pixel must be defined before calling the functions in  //// 
.................... ////   this file. Call it glcd_pixel(x, y, color) where x is the     //// 
.................... ////   horizontal coordinate, y is the vertical coordinate, and      //// 
.................... ////   color is 1 bit to turn the pixel on or off.                   //// 
.................... ////                                                                 //// 
.................... ////   * Note: (0, 0) is treated as the upper left corner            //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1, y1, x2, y2, color)                               //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color                                      //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1, y1, x2, y2, fill, color)                         //// 
.................... ////     * Draws a rectangle with one corner at point (x1,y1) and    //// 
.................... ////       the other corner at point (x2,y2)                         //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1, y1, x2, y2, width, color)                         //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point                                              //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x, y, radius, fill, color)                         //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x, y, textptr, size, color)                        //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y) //// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall            //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - This function wraps characters to the next line    //// 
.................... ////              use #define GLCD_WIDTH to specify a display width  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2004 Custom Computer Services        //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef GRAPHICS_DRAWING_FUNCTIONS 
.................... #define GRAPHICS_DRAWING_FUNCTIONS 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifndef ON 
.................... #define ON  1 
.................... #endif 
....................  
.................... #ifndef OFF 
.................... #define OFF 0 
.................... #endif 
....................  
.................... #ifndef YES 
.................... #define YES 1 
.................... #endif 
....................  
.................... #ifndef NO 
.................... #define NO  0 
.................... #endif 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Defines a 5x7 font 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const int8 FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const int8 FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_line(int16 x1, int16 y1, int16 x2, int16 y2, int1 color) 
.................... #else 
.................... void glcd_line(int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... #endif 
.................... { 
*
00B4C:  MOVLW  01
00B4E:  MOVLB  4
00B50:  MOVWF  xD7
00B52:  MOVWF  xD8
00B54:  CLRF   xDD
....................    int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
00B56:  MOVF   xCE,W
00B58:  SUBWF  xD0,W
00B5A:  MOVWF  xDE
00B5C:  MOVF   xDE,W
00B5E:  BTFSS  xDE.7
00B60:  BRA    0B68
00B62:  MOVLW  00
00B64:  BSF    FD8.0
00B66:  SUBFWB xDE,W
00B68:  CLRF   03
00B6A:  MOVWF  xD5
00B6C:  MOVFF  03,4D6
....................    dy = abs((signed int8)(y2 - y1)); 
00B70:  MOVF   xCF,W
00B72:  SUBWF  xD1,W
00B74:  MOVWF  xDE
00B76:  MOVF   xDE,W
00B78:  BTFSS  xDE.7
00B7A:  BRA    0B82
00B7C:  MOVLW  00
00B7E:  BSF    FD8.0
00B80:  SUBFWB xDE,W
00B82:  CLRF   03
00B84:  MOVWF  xD3
00B86:  MOVFF  03,4D4
....................    #endif 
....................  
....................    if(x1 > x2) 
00B8A:  MOVF   xCE,W
00B8C:  SUBWF  xD0,W
00B8E:  BC    0B94
....................       addx = -1; 
00B90:  MOVLW  FF
00B92:  MOVWF  xD7
....................    if(y1 > y2) 
00B94:  MOVF   xCF,W
00B96:  SUBWF  xD1,W
00B98:  BC    0B9E
....................       addy = -1; 
00B9A:  MOVLW  FF
00B9C:  MOVWF  xD8
....................  
....................    if(dx >= dy) 
00B9E:  MOVF   xD4,W
00BA0:  SUBWF  xD6,W
00BA2:  BNC   0C1A
00BA4:  BNZ   0BAC
00BA6:  MOVF   xD3,W
00BA8:  SUBWF  xD5,W
00BAA:  BNC   0C1A
....................    { 
....................       dy *= 2; 
00BAC:  BCF    FD8.0
00BAE:  RLCF   xD3,F
00BB0:  RLCF   xD4,F
....................       P = dy - dx; 
00BB2:  MOVF   xD5,W
00BB4:  SUBWF  xD3,W
00BB6:  MOVWF  00
00BB8:  MOVF   xD6,W
00BBA:  SUBWFB xD4,W
00BBC:  MOVFF  00,4D9
00BC0:  MOVWF  xDA
....................       diff = P - dx; 
00BC2:  MOVF   xD5,W
00BC4:  SUBWF  xD9,W
00BC6:  MOVWF  xDB
00BC8:  MOVF   xD6,W
00BCA:  SUBWFB xDA,W
00BCC:  MOVWF  xDC
....................  
....................       for(; i<=dx; ++i) 
00BCE:  MOVF   xD6,F
00BD0:  BNZ   0BD8
00BD2:  MOVF   xDD,W
00BD4:  SUBWF  xD5,W
00BD6:  BNC   0C18
....................       { 
....................          glcd_pixel(x1, y1, color); 
00BD8:  MOVFF  4CE,4E1
00BDC:  MOVFF  4CF,4E2
00BE0:  MOVFF  4D2,4E3
00BE4:  MOVLB  0
00BE6:  RCALL  04DA
....................  
....................          if(P < 0) 
00BE8:  MOVLB  4
00BEA:  BTFSC  xDA.7
00BEC:  BRA    0BF0
00BEE:  BRA    0C00
....................          { 
....................             P  += dy; 
00BF0:  MOVF   xD3,W
00BF2:  ADDWF  xD9,F
00BF4:  MOVF   xD4,W
00BF6:  ADDWFC xDA,F
....................             x1 += addx; 
00BF8:  MOVF   xD7,W
00BFA:  ADDWF  xCE,W
00BFC:  MOVWF  xCE
....................          } 
....................          else 
00BFE:  BRA    0C14
....................          { 
....................             P  += diff; 
00C00:  MOVF   xDB,W
00C02:  ADDWF  xD9,F
00C04:  MOVF   xDC,W
00C06:  ADDWFC xDA,F
....................             x1 += addx; 
00C08:  MOVF   xD7,W
00C0A:  ADDWF  xCE,W
00C0C:  MOVWF  xCE
....................             y1 += addy; 
00C0E:  MOVF   xD8,W
00C10:  ADDWF  xCF,W
00C12:  MOVWF  xCF
....................          } 
....................       } 
00C14:  INCF   xDD,F
00C16:  BRA    0BCE
....................    } 
....................    else 
00C18:  BRA    0C86
....................    { 
....................       dx *= 2; 
00C1A:  BCF    FD8.0
00C1C:  RLCF   xD5,F
00C1E:  RLCF   xD6,F
....................       P = dx - dy; 
00C20:  MOVF   xD3,W
00C22:  SUBWF  xD5,W
00C24:  MOVWF  00
00C26:  MOVF   xD4,W
00C28:  SUBWFB xD6,W
00C2A:  MOVFF  00,4D9
00C2E:  MOVWF  xDA
....................       diff = P - dy; 
00C30:  MOVF   xD3,W
00C32:  SUBWF  xD9,W
00C34:  MOVWF  xDB
00C36:  MOVF   xD4,W
00C38:  SUBWFB xDA,W
00C3A:  MOVWF  xDC
....................  
....................       for(; i<=dy; ++i) 
00C3C:  MOVF   xD4,F
00C3E:  BNZ   0C46
00C40:  MOVF   xDD,W
00C42:  SUBWF  xD3,W
00C44:  BNC   0C86
....................       { 
....................          glcd_pixel(x1, y1, color); 
00C46:  MOVFF  4CE,4E1
00C4A:  MOVFF  4CF,4E2
00C4E:  MOVFF  4D2,4E3
00C52:  MOVLB  0
00C54:  RCALL  04DA
....................  
....................          if(P < 0) 
00C56:  MOVLB  4
00C58:  BTFSC  xDA.7
00C5A:  BRA    0C5E
00C5C:  BRA    0C6E
....................          { 
....................             P  += dx; 
00C5E:  MOVF   xD5,W
00C60:  ADDWF  xD9,F
00C62:  MOVF   xD6,W
00C64:  ADDWFC xDA,F
....................             y1 += addy; 
00C66:  MOVF   xD8,W
00C68:  ADDWF  xCF,W
00C6A:  MOVWF  xCF
....................          } 
....................          else 
00C6C:  BRA    0C82
....................          { 
....................             P  += diff; 
00C6E:  MOVF   xDB,W
00C70:  ADDWF  xD9,F
00C72:  MOVF   xDC,W
00C74:  ADDWFC xDA,F
....................             x1 += addx; 
00C76:  MOVF   xD7,W
00C78:  ADDWF  xCE,W
00C7A:  MOVWF  xCE
....................             y1 += addy; 
00C7C:  MOVF   xD8,W
00C7E:  ADDWF  xCF,W
00C80:  MOVWF  xCF
....................          } 
....................       } 
00C82:  INCF   xDD,F
00C84:  BRA    0C3C
....................    } 
.................... } 
00C86:  MOVLB  0
00C88:  RETLW  00
.................... /*WIDE LINE*/ 
....................  
.................... #ifdef LARGE_LCD 
.................... void glcd_wline(int16 x1, int16 y1, int16 x2, int16 y2, int1 color) 
.................... #else 
.................... void glcd_wline(int8 x1, int8 y1, int8 x2, int8 y2, int1 color) 
.................... #endif 
.................... { 
....................    int16        dy, dx; 
....................    signed int8  addx=1, addy=1; 
....................    signed int16 P, diff; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
....................    dy = abs((signed int8)(y2 - y1)); 
....................    #endif 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       dy *= 2; 
....................       P = dy - dx; 
....................       diff = P - dx; 
....................  
....................       for(; i<=dx; ++i) 
....................       { 
....................          glcd_pixel(x1, y1, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P  += dy; 
....................             x1 += addx; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       dx *= 2; 
....................       P = dx - dy; 
....................       diff = P - dy; 
....................  
....................       for(; i<=dy; ++i) 
....................       { 
....................          glcd_pixel(x1, y1, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P  += dx; 
....................             y1 += addy; 
....................          } 
....................          else 
....................          { 
....................             P  += diff; 
....................             x1 += addx; 
....................             y1 += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_rect(int16 x1, int16 y1, int16 x2, int16 y2, int1 fill, int1 color) 
.................... #else 
.................... void glcd_rect(int8 x1, int8 y1, int8 x2, int8 y2, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    if(fill) 
*
0157A:  MOVLB  4
0157C:  MOVF   xC7,F
0157E:  BZ    15DE
....................    { 
....................       #ifdef LARGE_LCD 
....................       int16 i, xmin, xmax, ymin, ymax; 
....................       #else 
....................       int8  i, xmin, xmax, ymin, ymax; 
....................       #endif 
....................  
....................       if(x1 < x2)                            //  Find x min and max 
01580:  MOVF   xC5,W
01582:  SUBWF  xC3,W
01584:  BC    1590
....................       { 
....................          xmin = x1; 
01586:  MOVFF  4C3,4CA
....................          xmax = x2; 
0158A:  MOVFF  4C5,4CB
....................       } 
....................       else 
0158E:  BRA    1598
....................       { 
....................          xmin = x2; 
01590:  MOVFF  4C5,4CA
....................          xmax = x1; 
01594:  MOVFF  4C3,4CB
....................       } 
....................  
....................       if(y1 < y2)                            // Find the y min and max 
01598:  MOVF   xC6,W
0159A:  SUBWF  xC4,W
0159C:  BC    15A8
....................       { 
....................          ymin = y1; 
0159E:  MOVFF  4C4,4CC
....................          ymax = y2; 
015A2:  MOVFF  4C6,4CD
....................       } 
....................       else 
015A6:  BRA    15B0
....................       { 
....................          ymin = y2; 
015A8:  MOVFF  4C6,4CC
....................          ymax = y1; 
015AC:  MOVFF  4C4,4CD
....................       } 
....................  
....................       for(; xmin <= xmax; ++xmin) 
015B0:  MOVF   xCA,W
015B2:  SUBWF  xCB,W
015B4:  BNC   15DC
....................       { 
....................          for(i=ymin; i<=ymax; ++i) 
015B6:  MOVFF  4CC,4C9
015BA:  MOVF   xC9,W
015BC:  SUBWF  xCD,W
015BE:  BNC   15D8
....................          { 
....................             glcd_pixel(xmin, i, color); 
015C0:  MOVFF  4CA,4E1
015C4:  MOVFF  4C9,4E2
015C8:  MOVFF  4C8,4E3
015CC:  MOVLB  0
015CE:  CALL   04DA
....................          } 
015D2:  MOVLB  4
015D4:  INCF   xC9,F
015D6:  BRA    15BA
....................       } 
015D8:  INCF   xCA,F
015DA:  BRA    15B0
....................    } 
....................    else 
015DC:  BRA    1642
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
015DE:  MOVFF  4C3,4CE
015E2:  MOVFF  4C4,4CF
015E6:  MOVFF  4C5,4D0
015EA:  MOVFF  4C4,4D1
015EE:  MOVFF  4C8,4D2
015F2:  MOVLB  0
015F4:  CALL   0B4C
....................       glcd_line(x1, y2, x2, y2, color); 
015F8:  MOVFF  4C3,4CE
015FC:  MOVFF  4C6,4CF
01600:  MOVFF  4C5,4D0
01604:  MOVFF  4C6,4D1
01608:  MOVFF  4C8,4D2
0160C:  CALL   0B4C
....................       glcd_line(x1, y1, x1, y2, color); 
01610:  MOVFF  4C3,4CE
01614:  MOVFF  4C4,4CF
01618:  MOVFF  4C3,4D0
0161C:  MOVFF  4C6,4D1
01620:  MOVFF  4C8,4D2
01624:  CALL   0B4C
....................       glcd_line(x2, y1, x2, y2, color); 
01628:  MOVFF  4C5,4CE
0162C:  MOVFF  4C4,4CF
01630:  MOVFF  4C5,4D0
01634:  MOVFF  4C6,4D1
01638:  MOVFF  4C8,4D2
0163C:  CALL   0B4C
01640:  MOVLB  4
....................    } 
.................... } 
01642:  MOVLB  0
01644:  RETLW  00
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_bar(int16 x1, int16 y1, int16 x2, int16 y2, int8 width, int1 color) 
.................... #else 
.................... void glcd_bar(int8 x1, int8 y1, int8 x2, int8 y2, int8 width, int1 color) 
.................... #endif 
.................... { 
*
0079E:  MOVLW  01
007A0:  MOVLB  4
007A2:  MOVWF  xCE
007A4:  MOVWF  xCF
007A6:  CLRF   xD9
....................    int8         half_width; 
....................    signed int16 dy, dx; 
....................    signed int8  addx=1, addy=1, j; 
....................    signed int16 P, diff, c1, c2; 
....................  
....................    #ifdef LARGE_LCD 
....................    int16 i=0; 
....................    dx = abs((signed int16)(x2 - x1)); 
....................    dy = abs((signed int16)(y2 - y1)); 
....................    #else 
....................    int8 i=0; 
....................    dx = abs((signed int8)(x2 - x1)); 
007A8:  MOVF   xC3,W
007AA:  SUBWF  xC5,W
007AC:  MOVWF  xE0
007AE:  MOVF   xE0,W
007B0:  BTFSS  xE0.7
007B2:  BRA    07BA
007B4:  MOVLW  00
007B6:  BSF    FD8.0
007B8:  SUBFWB xE0,W
007BA:  CLRF   03
007BC:  BTFSC  FE8.7
007BE:  DECF   03,F
007C0:  MOVWF  xCC
007C2:  MOVFF  03,4CD
....................    dy = abs((signed int8)(y2 - y1)); 
007C6:  MOVF   xC4,W
007C8:  SUBWF  xC6,W
007CA:  MOVWF  xE0
007CC:  MOVF   xE0,W
007CE:  BTFSS  xE0.7
007D0:  BRA    07D8
007D2:  MOVLW  00
007D4:  BSF    FD8.0
007D6:  SUBFWB xE0,W
007D8:  CLRF   03
007DA:  BTFSC  FE8.7
007DC:  DECF   03,F
007DE:  MOVWF  xCA
007E0:  MOVFF  03,4CB
....................    #endif 
....................  
....................    half_width = width/2; 
007E4:  BCF    FD8.0
007E6:  RRCF   xC7,W
007E8:  MOVWF  xC9
....................    c1 = -(dx*x1 + dy*y1); 
007EA:  MOVFF  4CD,4E5
007EE:  MOVFF  4CC,4E4
007F2:  CLRF   xE7
007F4:  MOVFF  4C3,4E6
007F8:  MOVLB  0
007FA:  RCALL  074A
007FC:  MOVFF  02,4E1
00800:  MOVFF  01,4E0
00804:  MOVFF  4CB,4E5
00808:  MOVFF  4CA,4E4
0080C:  MOVLB  4
0080E:  CLRF   xE7
00810:  MOVFF  4C4,4E6
00814:  MOVLB  0
00816:  RCALL  074A
00818:  MOVFF  02,03
0081C:  MOVF   01,W
0081E:  MOVLB  4
00820:  ADDWF  xE0,W
00822:  MOVWF  01
00824:  MOVF   xE1,W
00826:  ADDWFC 03,F
00828:  MOVF   01,W
0082A:  XORLW  FF
0082C:  ADDLW  01
0082E:  MOVWF  xD5
00830:  MOVLW  00
00832:  SUBFWB 03,W
00834:  MOVWF  xD6
....................    c2 = -(dx*x2 + dy*y2); 
00836:  MOVFF  4CD,4E5
0083A:  MOVFF  4CC,4E4
0083E:  CLRF   xE7
00840:  MOVFF  4C5,4E6
00844:  MOVLB  0
00846:  RCALL  074A
00848:  MOVFF  02,4E1
0084C:  MOVFF  01,4E0
00850:  MOVFF  4CB,4E5
00854:  MOVFF  4CA,4E4
00858:  MOVLB  4
0085A:  CLRF   xE7
0085C:  MOVFF  4C6,4E6
00860:  MOVLB  0
00862:  RCALL  074A
00864:  MOVFF  02,03
00868:  MOVF   01,W
0086A:  MOVLB  4
0086C:  ADDWF  xE0,W
0086E:  MOVWF  01
00870:  MOVF   xE1,W
00872:  ADDWFC 03,F
00874:  MOVF   01,W
00876:  XORLW  FF
00878:  ADDLW  01
0087A:  MOVWF  xD7
0087C:  MOVLW  00
0087E:  SUBFWB 03,W
00880:  MOVWF  xD8
....................  
....................    if(x1 > x2) 
00882:  MOVF   xC3,W
00884:  SUBWF  xC5,W
00886:  BC    08A4
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
00888:  MOVFF  4D6,4DB
0088C:  MOVFF  4D5,4DA
....................       c1 = c2; 
00890:  MOVFF  4D8,4D6
00894:  MOVFF  4D7,4D5
....................       c2 = temp; 
00898:  MOVFF  4DB,4D8
0089C:  MOVFF  4DA,4D7
....................       addx = -1; 
008A0:  MOVLW  FF
008A2:  MOVWF  xCE
....................    } 
....................    if(y1 > y2) 
008A4:  MOVF   xC4,W
008A6:  SUBWF  xC6,W
008A8:  BC    08C6
....................    { 
....................       signed int16 temp; 
....................       temp = c1; 
008AA:  MOVFF  4D6,4DD
008AE:  MOVFF  4D5,4DC
....................       c1 = c2; 
008B2:  MOVFF  4D8,4D6
008B6:  MOVFF  4D7,4D5
....................       c2 = temp; 
008BA:  MOVFF  4DD,4D8
008BE:  MOVFF  4DC,4D7
....................       addy = -1; 
008C2:  MOVLW  FF
008C4:  MOVWF  xCF
....................    } 
....................  
....................    if(dx >= dy) 
008C6:  BTFSS  xCB.7
008C8:  BRA    08D0
008CA:  BTFSS  xCD.7
008CC:  BRA    08E6
008CE:  BRA    08D4
008D0:  BTFSC  xCD.7
008D2:  BRA    0A18
008D4:  MOVF   xCB,W
008D6:  SUBWF  xCD,W
008D8:  BTFSS  FD8.0
008DA:  BRA    0A18
008DC:  BNZ   08E6
008DE:  MOVF   xCA,W
008E0:  SUBWF  xCC,W
008E2:  BTFSS  FD8.0
008E4:  BRA    0A18
....................    { 
....................       P = 2*dy - dx; 
008E6:  CLRF   xE5
008E8:  MOVLW  02
008EA:  MOVWF  xE4
008EC:  MOVFF  4CB,4E7
008F0:  MOVFF  4CA,4E6
008F4:  MOVLB  0
008F6:  RCALL  074A
008F8:  MOVLB  4
008FA:  MOVF   xCC,W
008FC:  SUBWF  01,W
008FE:  MOVWF  xD1
00900:  MOVF   xCD,W
00902:  SUBWFB 02,W
00904:  MOVWF  xD2
....................       diff = P - dx; 
00906:  MOVF   xCC,W
00908:  SUBWF  xD1,W
0090A:  MOVWF  xD3
0090C:  MOVF   xCD,W
0090E:  SUBWFB xD2,W
00910:  MOVWF  xD4
....................  
....................       for(i=0; i<=dx; ++i) 
00912:  CLRF   xD9
00914:  BTFSC  xCD.7
00916:  BRA    0A16
00918:  MOVF   xCD,F
0091A:  BNZ   0924
0091C:  MOVF   xD9,W
0091E:  SUBWF  xCC,W
00920:  BTFSS  FD8.0
00922:  BRA    0A16
....................       { 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
00924:  MOVLW  00
00926:  BSF    FD8.0
00928:  SUBFWB xC9,W
0092A:  MOVWF  xD0
0092C:  MOVF   xC7,W
0092E:  ANDLW  01
00930:  ADDWF  xC9,W
00932:  BTFSC  xD0.7
00934:  BRA    093A
00936:  SUBWF  xD0,W
00938:  BC    09D4
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
0093A:  MOVFF  4CD,4E5
0093E:  MOVFF  4CC,4E4
00942:  CLRF   xE7
00944:  MOVFF  4C3,4E6
00948:  MOVLB  0
0094A:  RCALL  074A
0094C:  MOVFF  02,4E1
00950:  MOVFF  01,4E0
00954:  MOVLB  4
00956:  MOVF   xD0,W
00958:  ADDWF  xC4,W
0095A:  CLRF   03
0095C:  MOVWF  00
0095E:  BTFSC  FE8.7
00960:  DECF   03,F
00962:  MOVWF  xE2
00964:  MOVFF  03,4E3
00968:  MOVFF  4CB,4E5
0096C:  MOVFF  4CA,4E4
00970:  MOVFF  03,4E7
00974:  MOVWF  xE6
00976:  MOVLB  0
00978:  RCALL  074A
0097A:  MOVFF  02,03
0097E:  MOVF   01,W
00980:  MOVLB  4
00982:  ADDWF  xE0,W
00984:  MOVWF  01
00986:  MOVF   xE1,W
00988:  ADDWFC 03,F
0098A:  MOVFF  01,4DE
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
0098E:  MOVF   xDE,W
00990:  ADDWF  xD5,W
00992:  MOVWF  xE0
00994:  MOVLW  00
00996:  ADDWFC xD6,W
00998:  MOVWF  xE1
0099A:  BTFSC  FE8.7
0099C:  BRA    09D0
0099E:  BRA    09A0
009A0:  MOVF   xDE,W
009A2:  ADDWF  xD7,W
009A4:  MOVWF  xE0
009A6:  MOVLW  00
009A8:  ADDWFC xD8,W
009AA:  MOVWF  xE1
009AC:  BTFSC  FE8.7
009AE:  BRA    09BA
009B0:  MOVF   xE1,F
009B2:  BNZ   09D0
009B4:  MOVF   xE0,W
009B6:  SUBLW  00
009B8:  BNC   09D0
....................                glcd_pixel(x1, y1+j, color); 
009BA:  MOVF   xD0,W
009BC:  ADDWF  xC4,W
009BE:  MOVWF  xE0
009C0:  MOVFF  4C3,4E1
009C4:  MOVWF  xE2
009C6:  MOVFF  4C8,4E3
009CA:  MOVLB  0
009CC:  RCALL  04DA
009CE:  MOVLB  4
....................          } 
009D0:  INCF   xD0,F
009D2:  BRA    092C
....................          if(P < 0) 
009D4:  BTFSC  xD2.7
009D6:  BRA    09DA
009D8:  BRA    09FE
....................          { 
....................             P  += 2*dy; 
009DA:  CLRF   xE5
009DC:  MOVLW  02
009DE:  MOVWF  xE4
009E0:  MOVFF  4CB,4E7
009E4:  MOVFF  4CA,4E6
009E8:  MOVLB  0
009EA:  RCALL  074A
009EC:  MOVF   01,W
009EE:  MOVLB  4
009F0:  ADDWF  xD1,F
009F2:  MOVF   02,W
009F4:  ADDWFC xD2,F
....................             x1 += addx; 
009F6:  MOVF   xCE,W
009F8:  ADDWF  xC3,W
009FA:  MOVWF  xC3
....................          } 
....................          else 
009FC:  BRA    0A12
....................          { 
....................             P  += diff; 
009FE:  MOVF   xD3,W
00A00:  ADDWF  xD1,F
00A02:  MOVF   xD4,W
00A04:  ADDWFC xD2,F
....................             x1 += addx; 
00A06:  MOVF   xCE,W
00A08:  ADDWF  xC3,W
00A0A:  MOVWF  xC3
....................             y1 += addy; 
00A0C:  MOVF   xCF,W
00A0E:  ADDWF  xC4,W
00A10:  MOVWF  xC4
....................          } 
....................       } 
00A12:  INCF   xD9,F
00A14:  BRA    0914
....................    } 
....................    else 
00A16:  BRA    0B48
....................    { 
....................       P = 2*dx - dy; 
00A18:  CLRF   xE5
00A1A:  MOVLW  02
00A1C:  MOVWF  xE4
00A1E:  MOVFF  4CD,4E7
00A22:  MOVFF  4CC,4E6
00A26:  MOVLB  0
00A28:  RCALL  074A
00A2A:  MOVLB  4
00A2C:  MOVF   xCA,W
00A2E:  SUBWF  01,W
00A30:  MOVWF  xD1
00A32:  MOVF   xCB,W
00A34:  SUBWFB 02,W
00A36:  MOVWF  xD2
....................       diff = P - dy; 
00A38:  MOVF   xCA,W
00A3A:  SUBWF  xD1,W
00A3C:  MOVWF  xD3
00A3E:  MOVF   xCB,W
00A40:  SUBWFB xD2,W
00A42:  MOVWF  xD4
....................  
....................       for(i=0; i<=dy; ++i) 
00A44:  CLRF   xD9
00A46:  BTFSC  xCB.7
00A48:  BRA    0B48
00A4A:  MOVF   xCB,F
00A4C:  BNZ   0A56
00A4E:  MOVF   xD9,W
00A50:  SUBWF  xCA,W
00A52:  BTFSS  FD8.0
00A54:  BRA    0B48
....................       { 
....................          if(P < 0) 
00A56:  BTFSC  xD2.7
00A58:  BRA    0A5C
00A5A:  BRA    0A80
....................          { 
....................             P  += 2*dx; 
00A5C:  CLRF   xE5
00A5E:  MOVLW  02
00A60:  MOVWF  xE4
00A62:  MOVFF  4CD,4E7
00A66:  MOVFF  4CC,4E6
00A6A:  MOVLB  0
00A6C:  RCALL  074A
00A6E:  MOVF   01,W
00A70:  MOVLB  4
00A72:  ADDWF  xD1,F
00A74:  MOVF   02,W
00A76:  ADDWFC xD2,F
....................             y1 += addy; 
00A78:  MOVF   xCF,W
00A7A:  ADDWF  xC4,W
00A7C:  MOVWF  xC4
....................          } 
....................          else 
00A7E:  BRA    0A94
....................          { 
....................             P  += diff; 
00A80:  MOVF   xD3,W
00A82:  ADDWF  xD1,F
00A84:  MOVF   xD4,W
00A86:  ADDWFC xD2,F
....................             x1 += addx; 
00A88:  MOVF   xCE,W
00A8A:  ADDWF  xC3,W
00A8C:  MOVWF  xC3
....................             y1 += addy; 
00A8E:  MOVF   xCF,W
00A90:  ADDWF  xC4,W
00A92:  MOVWF  xC4
....................          } 
....................          for(j=-half_width; j<half_width+width%2; ++j) 
00A94:  MOVLW  00
00A96:  BSF    FD8.0
00A98:  SUBFWB xC9,W
00A9A:  MOVWF  xD0
00A9C:  MOVF   xC7,W
00A9E:  ANDLW  01
00AA0:  ADDWF  xC9,W
00AA2:  BTFSC  xD0.7
00AA4:  BRA    0AAA
00AA6:  SUBWF  xD0,W
00AA8:  BC    0B44
....................          { 
....................             #ifdef LARGE_LCD 
....................             int16 temp; 
....................             #else 
....................             int8 temp; 
....................             #endif 
....................  
....................             temp = dx*x1+dy*(y1+j);    // Use more RAM to increase speed 
00AAA:  MOVFF  4CD,4E5
00AAE:  MOVFF  4CC,4E4
00AB2:  CLRF   xE7
00AB4:  MOVFF  4C3,4E6
00AB8:  MOVLB  0
00ABA:  RCALL  074A
00ABC:  MOVFF  02,4E1
00AC0:  MOVFF  01,4E0
00AC4:  MOVLB  4
00AC6:  MOVF   xD0,W
00AC8:  ADDWF  xC4,W
00ACA:  CLRF   03
00ACC:  MOVWF  00
00ACE:  BTFSC  FE8.7
00AD0:  DECF   03,F
00AD2:  MOVWF  xE2
00AD4:  MOVFF  03,4E3
00AD8:  MOVFF  4CB,4E5
00ADC:  MOVFF  4CA,4E4
00AE0:  MOVFF  03,4E7
00AE4:  MOVWF  xE6
00AE6:  MOVLB  0
00AE8:  RCALL  074A
00AEA:  MOVFF  02,03
00AEE:  MOVF   01,W
00AF0:  MOVLB  4
00AF2:  ADDWF  xE0,W
00AF4:  MOVWF  01
00AF6:  MOVF   xE1,W
00AF8:  ADDWFC 03,F
00AFA:  MOVFF  01,4DF
....................             if(temp+c1 >= 0 && temp+c2 <=0) 
00AFE:  MOVF   xDF,W
00B00:  ADDWF  xD5,W
00B02:  MOVWF  xE0
00B04:  MOVLW  00
00B06:  ADDWFC xD6,W
00B08:  MOVWF  xE1
00B0A:  BTFSC  FE8.7
00B0C:  BRA    0B40
00B0E:  BRA    0B10
00B10:  MOVF   xDF,W
00B12:  ADDWF  xD7,W
00B14:  MOVWF  xE0
00B16:  MOVLW  00
00B18:  ADDWFC xD8,W
00B1A:  MOVWF  xE1
00B1C:  BTFSC  FE8.7
00B1E:  BRA    0B2A
00B20:  MOVF   xE1,F
00B22:  BNZ   0B40
00B24:  MOVF   xE0,W
00B26:  SUBLW  00
00B28:  BNC   0B40
....................                glcd_pixel(x1+j, y1, color); 
00B2A:  MOVF   xD0,W
00B2C:  ADDWF  xC3,W
00B2E:  MOVWF  xE0
00B30:  MOVWF  xE1
00B32:  MOVFF  4C4,4E2
00B36:  MOVFF  4C8,4E3
00B3A:  MOVLB  0
00B3C:  RCALL  04DA
00B3E:  MOVLB  4
....................          } 
00B40:  INCF   xD0,F
00B42:  BRA    0A9C
....................       } 
00B44:  INCF   xD9,F
00B46:  BRA    0A46
....................    } 
.................... } 
00B48:  MOVLB  0
00B4A:  RETLW  00
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_circle(int16 x, int16 y, int16 radius, int1 fill, int1 color) 
.................... #else 
.................... void glcd_circle(int8 x, int8 y, int8 radius, int1 fill, int1 color) 
.................... #endif 
.................... { 
....................    #ifdef LARGE_LCD 
....................    signed int16 a, b, P; 
....................    #else 
....................    signed int8  a, b, P; 
....................    #endif 
....................  
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P += 3 + 2 * a++; 
....................       else 
....................          P += 5 + 2 * (a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #ifdef LARGE_LCD 
.................... void glcd_text57(int16 x, int16 y, char* textptr, int8 size, int1 color) 
.................... #else 
.................... void glcd_text57(int8 x, int8 y, char* textptr, int8 size, int1 color) 
.................... #endif 
.................... { 
....................    int8 j, k, l, m;                       // Loop counters 
....................    int8 pixelData[5];                     // Stores character data 
....................  
....................    for(; *textptr != '\0'; ++textptr, ++x)// Loop through the passed string 
*
00596:  MOVFF  4C6,03
0059A:  MOVLB  4
0059C:  MOVFF  4C5,FE9
005A0:  MOVFF  4C6,FEA
005A4:  MOVF   FEF,F
005A6:  BTFSC  FD8.2
005A8:  BRA    0746
....................    { 
....................       if(*textptr < 'S') // Checks if the letter is in the first font array 
005AA:  MOVFF  4C6,03
005AE:  MOVFF  4C5,FE9
005B2:  MOVFF  4C6,FEA
005B6:  MOVF   FEF,W
005B8:  SUBLW  52
005BA:  BNC   0608
....................          memcpy(pixelData, FONT[*textptr - ' '], 5); 
005BC:  MOVFF  4C6,03
005C0:  MOVFF  4C5,FE9
005C4:  MOVFF  4C6,FEA
005C8:  MOVLW  20
005CA:  SUBWF  FEF,W
005CC:  MULLW  05
005CE:  MOVF   FF3,W
005D0:  CLRF   03
005D2:  MOVWF  xD2
005D4:  MOVLW  04
005D6:  MOVWF  FEA
005D8:  MOVLW  CD
005DA:  MOVWF  FE9
005DC:  CLRF   xD6
005DE:  MOVFF  4D2,4D5
005E2:  MOVFF  FF2,4D3
005E6:  BCF    FF2.7
005E8:  MOVLW  05
005EA:  MOVWF  01
005EC:  CLRF   FF7
005EE:  MOVF   xD2,W
005F0:  MOVLB  0
005F2:  RCALL  0004
005F4:  TBLRD*-
005F6:  TBLRD*+
005F8:  MOVFF  FF5,FEE
005FC:  DECFSZ 01,F
005FE:  BRA    05F6
00600:  MOVLB  4
00602:  BTFSC  xD3.7
00604:  BSF    FF2.7
....................       else if(*textptr <= '~') // Check if the letter is in the second font array 
00606:  BRA    0670
00608:  MOVFF  4C6,03
0060C:  MOVFF  4C5,FE9
00610:  MOVFF  4C6,FEA
00614:  MOVF   FEF,W
00616:  SUBLW  7E
00618:  BNC   0666
....................          memcpy(pixelData, FONT2[*textptr - 'S'], 5); 
0061A:  MOVFF  4C6,03
0061E:  MOVFF  4C5,FE9
00622:  MOVFF  4C6,FEA
00626:  MOVLW  53
00628:  SUBWF  FEF,W
0062A:  MULLW  05
0062C:  MOVF   FF3,W
0062E:  CLRF   03
00630:  MOVWF  xD2
00632:  MOVLW  04
00634:  MOVWF  FEA
00636:  MOVLW  CD
00638:  MOVWF  FE9
0063A:  CLRF   xD6
0063C:  MOVFF  4D2,4D5
00640:  MOVFF  FF2,4D3
00644:  BCF    FF2.7
00646:  MOVLW  05
00648:  MOVWF  01
0064A:  CLRF   FF7
0064C:  MOVF   xD2,W
0064E:  MOVLB  0
00650:  RCALL  0114
00652:  TBLRD*-
00654:  TBLRD*+
00656:  MOVFF  FF5,FEE
0065A:  DECFSZ 01,F
0065C:  BRA    0654
0065E:  MOVLB  4
00660:  BTFSC  xD3.7
00662:  BSF    FF2.7
....................       else 
00664:  BRA    0670
....................          memcpy(pixelData, FONT[0], 5);   // Default to space 
00666:  CLRF   xCD
00668:  CLRF   xCE
0066A:  CLRF   xCF
0066C:  CLRF   xD0
0066E:  CLRF   xD1
....................  
....................       // Handles newline and carriage returns 
....................       switch(*textptr) 
....................       { 
00670:  MOVFF  4C6,03
00674:  MOVF   xC5,W
00676:  MOVWF  FE9
00678:  MOVFF  03,FEA
0067C:  MOVF   FEF,W
0067E:  XORLW  0A
00680:  MOVLB  0
00682:  BZ    068A
00684:  XORLW  07
00686:  BZ    069A
00688:  BRA    06A0
....................          case '\n': 
....................             y += 7*size + 1; 
0068A:  MOVLB  4
0068C:  MOVF   xC7,W
0068E:  MULLW  07
00690:  MOVF   FF3,W
00692:  ADDLW  01
00694:  ADDWF  xC4,F
....................             continue; 
00696:  BRA    0738
00698:  MOVLB  0
....................          case '\r': 
....................             x = 0; 
0069A:  MOVLB  4
0069C:  CLRF   xC3
....................             continue; 
0069E:  BRA    0738
....................       } 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
006A0:  MOVLB  4
006A2:  MOVF   xC7,W
006A4:  MULLW  05
006A6:  MOVF   FF3,W
006A8:  ADDWF  xC3,W
006AA:  SUBLW  7F
006AC:  BC    06BA
....................       { 
....................          x = 0;                           // Set x at far left position 
006AE:  CLRF   xC3
....................          y += 7*size + 1;                 // Set y at next position down 
006B0:  MOVF   xC7,W
006B2:  MULLW  07
006B4:  MOVF   FF3,W
006B6:  ADDLW  01
006B8:  ADDWF  xC4,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
006BA:  CLRF   xC9
006BC:  MOVF   xC9,W
006BE:  SUBLW  04
006C0:  BNC   0738
....................       { 
....................          for(k=0; k < 7; ++k)             // Loop through the vertical pixels 
006C2:  CLRF   xCA
006C4:  MOVF   xCA,W
006C6:  SUBLW  06
006C8:  BNC   0730
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
006CA:  CLRF   03
006CC:  MOVF   xC9,W
006CE:  ADDLW  CD
006D0:  MOVWF  FE9
006D2:  MOVLW  04
006D4:  ADDWFC 03,W
006D6:  MOVWF  FEA
006D8:  MOVFF  FEF,4D2
006DC:  MOVFF  4D2,00
006E0:  MOVF   xCA,W
006E2:  MOVWF  01
006E4:  BZ    06EE
006E6:  BCF    FD8.0
006E8:  RRCF   00,F
006EA:  DECFSZ 01,F
006EC:  BRA    06E6
006EE:  BTFSS  00.0
006F0:  BRA    072C
....................             { 
....................                for(l=0; l < size; ++l)    // These two loops change the 
006F2:  CLRF   xCB
006F4:  MOVF   xC7,W
006F6:  SUBWF  xCB,W
006F8:  BC    072C
....................                {                          // character's size 
....................                   for(m=0; m < size; ++m) 
006FA:  CLRF   xCC
006FC:  MOVF   xC7,W
006FE:  SUBWF  xCC,W
00700:  BC    0728
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
00702:  MOVF   xCC,W
00704:  ADDWF  xC3,W
00706:  MOVWF  xD2
00708:  MOVF   xCA,W
0070A:  MULWF  xC7
0070C:  MOVF   FF3,W
0070E:  ADDWF  xC4,W
00710:  ADDWF  xCB,W
00712:  MOVWF  xD3
00714:  MOVFF  4D2,4E1
00718:  MOVWF  xE2
0071A:  MOVFF  4C8,4E3
0071E:  MOVLB  0
00720:  RCALL  04DA
....................                   } 
00722:  MOVLB  4
00724:  INCF   xCC,F
00726:  BRA    06FC
....................                } 
00728:  INCF   xCB,F
0072A:  BRA    06F4
....................             } 
....................          } 
0072C:  INCF   xCA,F
0072E:  BRA    06C4
....................       } 
00730:  INCF   xC9,F
00732:  MOVF   xC7,W
00734:  ADDWF  xC3,F
00736:  BRA    06BC
....................    } 
00738:  INCF   xC5,F
0073A:  BTFSC  FD8.2
0073C:  INCF   xC6,F
0073E:  INCF   xC3,F
00740:  MOVLB  0
00742:  BRA    0596
00744:  MOVLB  4
.................... } 
00746:  MOVLB  0
00748:  RETLW  00
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
01696:  MOVLB  4
01698:  CLRF   xC8
....................    sign = 0; 
0169A:  CLRF   xC6
....................    base = 10; 
0169C:  MOVLW  0A
0169E:  MOVWF  xC7
....................    result = 0; 
016A0:  CLRF   xC5
....................  
....................    if (!s) 
016A2:  MOVF   xC3,W
016A4:  IORWF  xC4,W
016A6:  BNZ   16AE
....................       return 0; 
016A8:  MOVLW  00
016AA:  MOVWF  01
016AC:  BRA    1834
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
016AE:  MOVF   xC8,W
016B0:  INCF   xC8,F
016B2:  CLRF   03
016B4:  ADDWF  xC3,W
016B6:  MOVWF  FE9
016B8:  MOVF   xC4,W
016BA:  ADDWFC 03,W
016BC:  MOVWF  FEA
016BE:  MOVFF  FEF,4C9
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
016C2:  MOVF   xC9,W
016C4:  SUBLW  2D
016C6:  BNZ   16E2
....................    { 
....................       sign = 1;         // Set the sign to negative 
016C8:  MOVLW  01
016CA:  MOVWF  xC6
....................       c = s[index++]; 
016CC:  MOVF   xC8,W
016CE:  INCF   xC8,F
016D0:  CLRF   03
016D2:  ADDWF  xC3,W
016D4:  MOVWF  FE9
016D6:  MOVF   xC4,W
016D8:  ADDWFC 03,W
016DA:  MOVWF  FEA
016DC:  MOVFF  FEF,4C9
....................    } 
....................    else if (c == '+') 
016E0:  BRA    16FC
016E2:  MOVF   xC9,W
016E4:  SUBLW  2B
016E6:  BNZ   16FC
....................    { 
....................       c = s[index++]; 
016E8:  MOVF   xC8,W
016EA:  INCF   xC8,F
016EC:  CLRF   03
016EE:  ADDWF  xC3,W
016F0:  MOVWF  FE9
016F2:  MOVF   xC4,W
016F4:  ADDWFC 03,W
016F6:  MOVWF  FEA
016F8:  MOVFF  FEF,4C9
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
016FC:  MOVF   xC9,W
016FE:  SUBLW  2F
01700:  BTFSC  FD8.0
01702:  BRA    1824
01704:  MOVF   xC9,W
01706:  SUBLW  39
01708:  BTFSS  FD8.0
0170A:  BRA    1824
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0170C:  MOVF   xC9,W
0170E:  SUBLW  30
01710:  BNZ   1754
01712:  CLRF   03
01714:  MOVF   xC8,W
01716:  ADDWF  xC3,W
01718:  MOVWF  FE9
0171A:  MOVF   xC4,W
0171C:  ADDWFC 03,W
0171E:  MOVWF  FEA
01720:  MOVF   FEF,W
01722:  SUBLW  78
01724:  BZ    173A
01726:  CLRF   03
01728:  MOVF   xC8,W
0172A:  ADDWF  xC3,W
0172C:  MOVWF  FE9
0172E:  MOVF   xC4,W
01730:  ADDWFC 03,W
01732:  MOVWF  FEA
01734:  MOVF   FEF,W
01736:  SUBLW  58
01738:  BNZ   1754
....................       { 
....................          base = 16; 
0173A:  MOVLW  10
0173C:  MOVWF  xC7
....................          index++; 
0173E:  INCF   xC8,F
....................          c = s[index++]; 
01740:  MOVF   xC8,W
01742:  INCF   xC8,F
01744:  CLRF   03
01746:  ADDWF  xC3,W
01748:  MOVWF  FE9
0174A:  MOVF   xC4,W
0174C:  ADDWFC 03,W
0174E:  MOVWF  FEA
01750:  MOVFF  FEF,4C9
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
01754:  MOVF   xC7,W
01756:  SUBLW  0A
01758:  BNZ   1794
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
0175A:  MOVF   xC9,W
0175C:  SUBLW  2F
0175E:  BC    1792
01760:  MOVF   xC9,W
01762:  SUBLW  39
01764:  BNC   1792
....................             result = 10*result + (c - '0'); 
01766:  MOVLW  0A
01768:  MOVWF  xCA
0176A:  MOVFF  4C5,4CB
0176E:  MOVLB  0
01770:  BRA    1646
01772:  MOVLW  30
01774:  MOVLB  4
01776:  SUBWF  xC9,W
01778:  ADDWF  01,W
0177A:  MOVWF  xC5
....................             c = s[index++]; 
0177C:  MOVF   xC8,W
0177E:  INCF   xC8,F
01780:  CLRF   03
01782:  ADDWF  xC3,W
01784:  MOVWF  FE9
01786:  MOVF   xC4,W
01788:  ADDWFC 03,W
0178A:  MOVWF  FEA
0178C:  MOVFF  FEF,4C9
....................          } 
01790:  BRA    175A
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
01792:  BRA    1824
01794:  MOVF   xC7,W
01796:  SUBLW  10
01798:  BNZ   1824
....................       { 
....................          c = toupper(c); 
0179A:  MOVF   xC9,W
0179C:  SUBLW  60
0179E:  BC    17AC
017A0:  MOVF   xC9,W
017A2:  SUBLW  7A
017A4:  BNC   17AC
017A6:  MOVF   xC9,W
017A8:  ANDLW  DF
017AA:  BRA    17AE
017AC:  MOVF   xC9,W
017AE:  MOVWF  xC9
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
017B0:  MOVF   xC9,W
017B2:  SUBLW  2F
017B4:  BC    17BC
017B6:  MOVF   xC9,W
017B8:  SUBLW  39
017BA:  BC    17C8
017BC:  MOVF   xC9,W
017BE:  SUBLW  40
017C0:  BC    1824
017C2:  MOVF   xC9,W
017C4:  SUBLW  46
017C6:  BNC   1824
....................             if (c >= '0' && c <= '9') 
017C8:  MOVF   xC9,W
017CA:  SUBLW  2F
017CC:  BC    17E6
017CE:  MOVF   xC9,W
017D0:  SUBLW  39
017D2:  BNC   17E6
....................                result = (result << 4) + (c - '0'); 
017D4:  SWAPF  xC5,W
017D6:  MOVWF  xCA
017D8:  MOVLW  F0
017DA:  ANDWF  xCA,F
017DC:  MOVLW  30
017DE:  SUBWF  xC9,W
017E0:  ADDWF  xCA,W
017E2:  MOVWF  xC5
....................             else 
017E4:  BRA    17F8
....................                result = (result << 4) + (c - 'A' + 10); 
017E6:  SWAPF  xC5,W
017E8:  MOVWF  xCA
017EA:  MOVLW  F0
017EC:  ANDWF  xCA,F
017EE:  MOVLW  41
017F0:  SUBWF  xC9,W
017F2:  ADDLW  0A
017F4:  ADDWF  xCA,W
017F6:  MOVWF  xC5
....................  
....................             c = s[index++]; 
017F8:  MOVF   xC8,W
017FA:  INCF   xC8,F
017FC:  CLRF   03
017FE:  ADDWF  xC3,W
01800:  MOVWF  FE9
01802:  MOVF   xC4,W
01804:  ADDWFC 03,W
01806:  MOVWF  FEA
01808:  MOVFF  FEF,4C9
....................             c = toupper(c); 
0180C:  MOVF   xC9,W
0180E:  SUBLW  60
01810:  BC    181E
01812:  MOVF   xC9,W
01814:  SUBLW  7A
01816:  BNC   181E
01818:  MOVF   xC9,W
0181A:  ANDLW  DF
0181C:  BRA    1820
0181E:  MOVF   xC9,W
01820:  MOVWF  xC9
....................          } 
01822:  BRA    17B0
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
01824:  DECFSZ xC6,W
01826:  BRA    1830
01828:  MOVF   xC7,W
0182A:  SUBLW  0A
0182C:  BNZ   1830
....................        result = -result; 
0182E:  NEGF   xC5
....................  
....................    return(result); 
01830:  MOVFF  4C5,01
.................... } 
01834:  MOVLB  0
01836:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
*
0196C:  MOVLB  4
0196E:  CLRF   xCD
01970:  CLRF   xCC
01972:  CLRF   xCB
01974:  MOVLW  01
01976:  MOVWF  xCA
01978:  CLRF   xCF
0197A:  CLRF   xD0
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0197C:  BTFSC  xC6.7
0197E:  BRA    1982
01980:  BRA    19B6
....................          sign=1;        // Check for negative number 
01982:  MOVLW  01
01984:  MOVWF  xCF
....................          num*=-1; 
01986:  MOVFF  4C6,4D5
0198A:  MOVFF  4C5,4D4
0198E:  MOVFF  4C4,4D3
01992:  MOVFF  4C3,4D2
01996:  MOVLW  FF
01998:  MOVWF  xD9
0199A:  MOVWF  xD8
0199C:  MOVWF  xD7
0199E:  MOVWF  xD6
019A0:  MOVLB  0
019A2:  BRA    1838
019A4:  MOVFF  03,4C6
019A8:  MOVFF  02,4C5
019AC:  MOVFF  01,4C4
019B0:  MOVFF  00,4C3
019B4:  MOVLB  4
....................      } 
....................  
....................      while(temp>0) { 
019B6:  MOVF   xCA,F
019B8:  BNZ   19C6
019BA:  MOVF   xCB,F
019BC:  BNZ   19C6
019BE:  MOVF   xCC,F
019C0:  BNZ   19C6
019C2:  MOVF   xCD,F
019C4:  BZ    1AB4
....................          temp=(num/base); 
019C6:  MOVFF  4C6,4D9
019CA:  MOVFF  4C5,4D8
019CE:  MOVFF  4C4,4D7
019D2:  MOVFF  4C3,4D6
019D6:  CLRF   xDD
019D8:  CLRF   xDC
019DA:  CLRF   xDB
019DC:  MOVFF  4C7,4DA
019E0:  MOVLB  0
019E2:  RCALL  1896
019E4:  MOVFF  03,4CD
019E8:  MOVFF  02,4CC
019EC:  MOVFF  01,4CB
019F0:  MOVFF  00,4CA
....................          s[cnt]=(num%base)+'0';    // Conversion 
019F4:  CLRF   03
019F6:  MOVLB  4
019F8:  MOVF   xD0,W
019FA:  ADDWF  xC8,W
019FC:  MOVWF  01
019FE:  MOVF   xC9,W
01A00:  ADDWFC 03,F
01A02:  MOVFF  01,4D2
01A06:  MOVFF  03,4D3
01A0A:  MOVFF  FEA,4D5
01A0E:  MOVFF  FE9,4D4
01A12:  MOVFF  4C6,4D9
01A16:  MOVFF  4C5,4D8
01A1A:  MOVFF  4C4,4D7
01A1E:  MOVFF  4C3,4D6
01A22:  CLRF   xDD
01A24:  CLRF   xDC
01A26:  CLRF   xDB
01A28:  MOVFF  4C7,4DA
01A2C:  MOVLB  0
01A2E:  RCALL  1896
01A30:  MOVFF  FEF,00
01A34:  MOVFF  FEC,01
01A38:  MOVFF  FEC,02
01A3C:  MOVFF  FEC,03
01A40:  MOVFF  4D5,FEA
01A44:  MOVFF  4D4,FE9
01A48:  MOVFF  03,4D9
01A4C:  MOVFF  02,4D8
01A50:  MOVFF  01,4D7
01A54:  MOVFF  00,4D6
01A58:  MOVLW  30
01A5A:  MOVLB  4
01A5C:  ADDWF  00,W
01A5E:  MOVWF  00
01A60:  MOVLW  00
01A62:  ADDWFC 01,W
01A64:  MOVLW  00
01A66:  ADDWFC 02,W
01A68:  MOVLW  00
01A6A:  ADDWFC 03,W
01A6C:  MOVFF  4D3,FEA
01A70:  MOVFF  4D2,FE9
01A74:  MOVFF  00,FEF
....................  
....................          if(s[cnt]>0x39) 
01A78:  CLRF   03
01A7A:  MOVF   xD0,W
01A7C:  ADDWF  xC8,W
01A7E:  MOVWF  FE9
01A80:  MOVF   xC9,W
01A82:  ADDWFC 03,W
01A84:  MOVWF  FEA
01A86:  MOVF   FEF,W
01A88:  SUBLW  39
01A8A:  BC    1AA0
....................             s[cnt]+=0x7; 
01A8C:  CLRF   03
01A8E:  MOVF   xD0,W
01A90:  ADDWF  xC8,W
01A92:  MOVWF  FE9
01A94:  MOVF   xC9,W
01A96:  ADDWFC 03,W
01A98:  MOVWF  FEA
01A9A:  MOVLW  07
01A9C:  ADDWF  FEF,W
01A9E:  MOVWF  FEF
....................  
....................          cnt++; 
01AA0:  INCF   xD0,F
....................          num=temp; 
01AA2:  MOVFF  4CD,4C6
01AA6:  MOVFF  4CC,4C5
01AAA:  MOVFF  4CB,4C4
01AAE:  MOVFF  4CA,4C3
....................      } 
01AB2:  BRA    19B6
....................  
....................      if(sign==1) { 
01AB4:  DECFSZ xCF,W
01AB6:  BRA    1ACC
....................          s[cnt]=0x2D;      // Negative sign 
01AB8:  CLRF   03
01ABA:  MOVF   xD0,W
01ABC:  ADDWF  xC8,W
01ABE:  MOVWF  FE9
01AC0:  MOVF   xC9,W
01AC2:  ADDWFC 03,W
01AC4:  MOVWF  FEA
01AC6:  MOVLW  2D
01AC8:  MOVWF  FEF
....................          cnt++; 
01ACA:  INCF   xD0,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
01ACC:  CLRF   xCE
01ACE:  BCF    FD8.0
01AD0:  RRCF   xD0,W
01AD2:  SUBWF  xCE,W
01AD4:  BC    1B34
....................  
....................          c=s[i]; 
01AD6:  CLRF   03
01AD8:  MOVF   xCE,W
01ADA:  ADDWF  xC8,W
01ADC:  MOVWF  FE9
01ADE:  MOVF   xC9,W
01AE0:  ADDWFC 03,W
01AE2:  MOVWF  FEA
01AE4:  MOVFF  FEF,4D1
....................          s[i]=s[cnt-i-1];        // Reverse the number 
01AE8:  CLRF   03
01AEA:  MOVF   xCE,W
01AEC:  ADDWF  xC8,W
01AEE:  MOVWF  01
01AF0:  MOVF   xC9,W
01AF2:  ADDWFC 03,F
01AF4:  MOVFF  03,4D3
01AF8:  MOVF   xCE,W
01AFA:  SUBWF  xD0,W
01AFC:  ADDLW  FF
01AFE:  CLRF   03
01B00:  ADDWF  xC8,W
01B02:  MOVWF  FE9
01B04:  MOVF   xC9,W
01B06:  ADDWFC 03,W
01B08:  MOVWF  FEA
01B0A:  MOVFF  FEF,4D4
01B0E:  MOVFF  4D3,FEA
01B12:  MOVFF  01,FE9
01B16:  MOVFF  4D4,FEF
....................          s[cnt-i-1]=c; 
01B1A:  MOVF   xCE,W
01B1C:  SUBWF  xD0,W
01B1E:  ADDLW  FF
01B20:  CLRF   03
01B22:  ADDWF  xC8,W
01B24:  MOVWF  FE9
01B26:  MOVF   xC9,W
01B28:  ADDWFC 03,W
01B2A:  MOVWF  FEA
01B2C:  MOVFF  4D1,FEF
....................      } 
01B30:  INCF   xCE,F
01B32:  BRA    1ACE
....................      s[cnt]='\0';     // End the string 
01B34:  CLRF   03
01B36:  MOVF   xD0,W
01B38:  ADDWF  xC8,W
01B3A:  MOVWF  FE9
01B3C:  MOVF   xC9,W
01B3E:  ADDWFC 03,W
01B40:  MOVWF  FEA
01B42:  CLRF   FEF
....................      return s; 
01B44:  MOVFF  4C8,01
01B48:  MOVFF  4C9,02
.................... } 
01B4C:  MOVLB  0
01B4E:  RETLW  00
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "menu.c" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           Menu.c                                //// 
.................... ////                                                                 //// 
.................... //// Ester archivo contiene las funciones para implementar un menu   //// 
.................... //// en una pantalla lcd grafica de 128x64 con controlador KS0108    //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  readbuttons(void)                                              //// 
.................... ////     * Lee los estados de los botones          .                 //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... ////  menu_entrar(int8 tb, int8 color)                               //// 
.................... ////     * Dibuja una flecha al final de una linea de texto.         //// 
.................... ////       - tb es el pixel donde comienza el texto.                 //// 
.................... ////       - color puede ser ON o OFF                                //// 
.................... ////                                                                 //// 
.................... ////  menu_select(char item, char menu)                              //// 
.................... ////     * Selecciona una linea de texto invirtiendo los colores.    //// 
.................... ////       - item es la linea a seleccionar.                         //// 
.................... ////       - menu identifica el menu principal o submenu             //// 
.................... ////                                                                 //// 
.................... ////  menu_submenu(char menu)                                        //// 
.................... ////     * Selecciona el submenu a dibujar                           //// 
.................... ////       - menu es el numero de submenu                            //// 
.................... ////                                                                 //// 
.................... ////  menu_mainmenu(void)                                            //// 
.................... ////     * Dibuja el menu principal y maneja los submenu             //// 
.................... ////                                                                 //// 
.................... ////  menu_timemenu(void)                                            //// 
.................... ////     * Dibuja y maneja el setup de fecha y hora                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Function Prototypes 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void readbuttons(void); 
.................... void menu_entrar(int8 tb, int8 color); 
.................... void menu_select(char item, char menu); 
.................... void menu_submenu(char menu); 
.................... void menu_mainmenu(void); 
.................... void menu_timemenu(void); 
.................... void menu_drawmain(void); 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void readbuttons(void) 
.................... { 
.................... while (pressed==0) 
....................        { 
*
00E48:  MOVF   08,F
00E4A:  BNZ   0EAC
....................          lastup = up; 
00E4C:  MOVFF  0D,0E
....................          lastdown = down; 
00E50:  MOVFF  0F,10
....................          lastleft = left; 
00E54:  MOVFF  13,14
....................          lastright = right; 
00E58:  MOVFF  16,15
....................          lastenter = enter; 
00E5C:  MOVFF  11,12
....................          up = input(PIN_UP); 
00E60:  BSF    F92.0
00E62:  CLRF   0D
00E64:  BTFSC  F80.0
00E66:  INCF   0D,F
....................          down = input(PIN_DOWN); 
00E68:  BSF    F92.3
00E6A:  CLRF   0F
00E6C:  BTFSC  F80.3
00E6E:  INCF   0F,F
....................          left = input(PIN_LEFT); 
00E70:  BSF    F92.1
00E72:  CLRF   13
00E74:  BTFSC  F80.1
00E76:  INCF   13,F
....................          right = input(PIN_RIGHT); 
00E78:  BSF    F92.2
00E7A:  CLRF   16
00E7C:  BTFSC  F80.2
00E7E:  INCF   16,F
....................          enter = input(PIN_ENTER); 
00E80:  BSF    F92.4
00E82:  CLRF   11
00E84:  BTFSC  F80.4
00E86:  INCF   11,F
....................          if ((up!=lastup)||(down!=lastdown)||(enter!=lastenter)||(lastleft!=left)||(lastright!=right)) 
00E88:  MOVF   0E,W
00E8A:  SUBWF  0D,W
00E8C:  BNZ   0EA6
00E8E:  MOVF   10,W
00E90:  SUBWF  0F,W
00E92:  BNZ   0EA6
00E94:  MOVF   12,W
00E96:  SUBWF  11,W
00E98:  BNZ   0EA6
00E9A:  MOVF   13,W
00E9C:  SUBWF  14,W
00E9E:  BNZ   0EA6
00EA0:  MOVF   16,W
00EA2:  SUBWF  15,W
00EA4:  BZ    0EAA
....................          { 
....................             pressed = 1; 
00EA6:  MOVLW  01
00EA8:  MOVWF  08
....................          }         
....................        } 
00EAA:  BRA    0E48
.................... } 
00EAC:  RETLW  00
....................  
....................  
.................... void menu_entrar(int8 tb, int8 color) 
.................... { 
....................    glcd_line(124,tb,124,tb+7,color); 
*
00C8A:  MOVLW  07
00C8C:  MOVLB  4
00C8E:  ADDWF  xBB,W
00C90:  MOVWF  xBD
00C92:  MOVLW  7C
00C94:  MOVWF  xCE
00C96:  MOVFF  4BB,4CF
00C9A:  MOVWF  xD0
00C9C:  MOVFF  4BD,4D1
00CA0:  MOVFF  4BC,4D2
00CA4:  MOVLB  0
00CA6:  RCALL  0B4C
....................    glcd_line(125,tb+1,125,tb+6,color); 
00CA8:  MOVLW  01
00CAA:  MOVLB  4
00CAC:  ADDWF  xBB,W
00CAE:  MOVWF  xBD
00CB0:  MOVLW  06
00CB2:  ADDWF  xBB,W
00CB4:  MOVWF  xBE
00CB6:  MOVLW  7D
00CB8:  MOVWF  xCE
00CBA:  MOVFF  4BD,4CF
00CBE:  MOVWF  xD0
00CC0:  MOVFF  4BE,4D1
00CC4:  MOVFF  4BC,4D2
00CC8:  MOVLB  0
00CCA:  RCALL  0B4C
....................    glcd_line(126,tb+2,126,tb+5,color); 
00CCC:  MOVLW  02
00CCE:  MOVLB  4
00CD0:  ADDWF  xBB,W
00CD2:  MOVWF  xBD
00CD4:  MOVLW  05
00CD6:  ADDWF  xBB,W
00CD8:  MOVWF  xBE
00CDA:  MOVLW  7E
00CDC:  MOVWF  xCE
00CDE:  MOVFF  4BD,4CF
00CE2:  MOVWF  xD0
00CE4:  MOVFF  4BE,4D1
00CE8:  MOVFF  4BC,4D2
00CEC:  MOVLB  0
00CEE:  RCALL  0B4C
....................    glcd_line(127,tb+3,127,tb+4,color); 
00CF0:  MOVLW  03
00CF2:  MOVLB  4
00CF4:  ADDWF  xBB,W
00CF6:  MOVWF  xBD
00CF8:  MOVLW  04
00CFA:  ADDWF  xBB,W
00CFC:  MOVWF  xBE
00CFE:  MOVLW  7F
00D00:  MOVWF  xCE
00D02:  MOVFF  4BD,4CF
00D06:  MOVWF  xD0
00D08:  MOVFF  4BE,4D1
00D0C:  MOVFF  4BC,4D2
00D10:  MOVLB  0
00D12:  RCALL  0B4C
....................     
.................... } 
00D14:  RETLW  00
....................  
....................  
.................... void menu_select(char item, char menu) 
.................... { 
....................    switch (menu) 
....................    { 
*
00EAE:  MOVLB  4
00EB0:  MOVF   xBA,W
00EB2:  ADDLW  FB
00EB4:  BTFSC  FD8.0
00EB6:  BRA    1530
00EB8:  ADDLW  05
00EBA:  MOVLB  0
00EBC:  GOTO   1556
....................       case 0: 
....................       { 
....................          switch (item) 
....................          { 
00EC0:  MOVLW  01
00EC2:  MOVLB  4
00EC4:  SUBWF  xB9,W
00EC6:  ADDLW  FC
00EC8:  BTFSC  FD8.0
00ECA:  BRA    1066
00ECC:  ADDLW  04
00ECE:  MOVLB  0
00ED0:  GOTO   1534
....................             case 1: 
....................             { 
....................                menu_drawmain(); 
00ED4:  RCALL  0D16
....................                 
....................                glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
00ED6:  MOVLB  4
00ED8:  CLRF   xC3
00EDA:  MOVLW  11
00EDC:  MOVWF  xC4
00EDE:  MOVLW  7F
00EE0:  MOVWF  xC5
00EE2:  MOVLW  11
00EE4:  MOVWF  xC6
00EE6:  MOVLW  09
00EE8:  MOVWF  xC7
00EEA:  MOVLW  01
00EEC:  MOVWF  xC8
00EEE:  MOVLB  0
00EF0:  RCALL  079E
....................                glcd_text57(0, 14, MENU1, 1, OFF); 
00EF2:  MOVLB  4
00EF4:  CLRF   xC3
00EF6:  MOVLW  0E
00EF8:  MOVWF  xC4
00EFA:  CLRF   xC6
00EFC:  MOVLW  25
00EFE:  MOVWF  xC5
00F00:  MOVLW  01
00F02:  MOVWF  xC7
00F04:  CLRF   xC8
00F06:  MOVLB  0
00F08:  CALL   0596
....................                menu_entrar(14,OFF); 
00F0C:  MOVLW  0E
00F0E:  MOVLB  4
00F10:  MOVWF  xBB
00F12:  CLRF   xBC
00F14:  MOVLB  0
00F16:  RCALL  0C8A
....................                 
....................                glcd_update(); 
00F18:  CALL   0350
....................                break; 
00F1C:  MOVLB  4
00F1E:  BRA    1066
00F20:  MOVLB  0
....................             } 
....................             case 2: 
....................             { 
....................                menu_drawmain();   
00F22:  RCALL  0D16
....................                 
....................                glcd_bar(0, 26, 127, 26, 9, ON);    //selected 
00F24:  MOVLB  4
00F26:  CLRF   xC3
00F28:  MOVLW  1A
00F2A:  MOVWF  xC4
00F2C:  MOVLW  7F
00F2E:  MOVWF  xC5
00F30:  MOVLW  1A
00F32:  MOVWF  xC6
00F34:  MOVLW  09
00F36:  MOVWF  xC7
00F38:  MOVLW  01
00F3A:  MOVWF  xC8
00F3C:  MOVLB  0
00F3E:  RCALL  079E
....................                glcd_text57(0, 23, MENU2, 1, OFF); 
00F40:  MOVLB  4
00F42:  CLRF   xC3
00F44:  MOVLW  17
00F46:  MOVWF  xC4
00F48:  CLRF   xC6
00F4A:  MOVLW  33
00F4C:  MOVWF  xC5
00F4E:  MOVLW  01
00F50:  MOVWF  xC7
00F52:  CLRF   xC8
00F54:  MOVLB  0
00F56:  CALL   0596
....................                glcd_text57(100, 23, UniTemp, 1, OFF); 
00F5A:  MOVLW  64
00F5C:  MOVLB  4
00F5E:  MOVWF  xC3
00F60:  MOVLW  17
00F62:  MOVWF  xC4
00F64:  CLRF   xC6
00F66:  MOVLW  A7
00F68:  MOVWF  xC5
00F6A:  MOVLW  01
00F6C:  MOVWF  xC7
00F6E:  CLRF   xC8
00F70:  MOVLB  0
00F72:  CALL   0596
....................                menu_entrar(23,OFF); 
00F76:  MOVLW  17
00F78:  MOVLB  4
00F7A:  MOVWF  xBB
00F7C:  CLRF   xBC
00F7E:  MOVLB  0
00F80:  RCALL  0C8A
....................                 
....................                glcd_update(); 
00F82:  CALL   0350
....................                break; 
00F86:  MOVLB  4
00F88:  BRA    1066
00F8A:  MOVLB  0
....................             } 
....................             case 3: 
....................             { 
....................                menu_drawmain();   
00F8C:  RCALL  0D16
....................                
....................                glcd_bar(0, 35, 127, 35, 9, ON); //selected 
00F8E:  MOVLB  4
00F90:  CLRF   xC3
00F92:  MOVLW  23
00F94:  MOVWF  xC4
00F96:  MOVLW  7F
00F98:  MOVWF  xC5
00F9A:  MOVLW  23
00F9C:  MOVWF  xC6
00F9E:  MOVLW  09
00FA0:  MOVWF  xC7
00FA2:  MOVLW  01
00FA4:  MOVWF  xC8
00FA6:  MOVLB  0
00FA8:  CALL   079E
....................                glcd_text57(0, 32, MENU3, 1, OFF); 
00FAC:  MOVLB  4
00FAE:  CLRF   xC3
00FB0:  MOVLW  20
00FB2:  MOVWF  xC4
00FB4:  CLRF   xC6
00FB6:  MOVLW  59
00FB8:  MOVWF  xC5
00FBA:  MOVLW  01
00FBC:  MOVWF  xC7
00FBE:  CLRF   xC8
00FC0:  MOVLB  0
00FC2:  CALL   0596
....................                glcd_text57(100, 32, UniPres, 1, OFF); 
00FC6:  MOVLW  64
00FC8:  MOVLB  4
00FCA:  MOVWF  xC3
00FCC:  MOVLW  20
00FCE:  MOVWF  xC4
00FD0:  CLRF   xC6
00FD2:  MOVLW  A9
00FD4:  MOVWF  xC5
00FD6:  MOVLW  01
00FD8:  MOVWF  xC7
00FDA:  CLRF   xC8
00FDC:  MOVLB  0
00FDE:  CALL   0596
....................                menu_entrar(32,OFF); 
00FE2:  MOVLW  20
00FE4:  MOVLB  4
00FE6:  MOVWF  xBB
00FE8:  CLRF   xBC
00FEA:  MOVLB  0
00FEC:  RCALL  0C8A
....................                 
....................                
....................                glcd_update(); 
00FEE:  CALL   0350
....................                break; 
00FF2:  MOVLB  4
00FF4:  BRA    1066
00FF6:  MOVLB  0
....................             } 
....................             case 4: 
....................             { 
....................                menu_drawmain();  
00FF8:  RCALL  0D16
....................                 
....................                glcd_bar(0, 44, 127, 44, 9, ON); //selected 
00FFA:  MOVLB  4
00FFC:  CLRF   xC3
00FFE:  MOVLW  2C
01000:  MOVWF  xC4
01002:  MOVLW  7F
01004:  MOVWF  xC5
01006:  MOVLW  2C
01008:  MOVWF  xC6
0100A:  MOVLW  09
0100C:  MOVWF  xC7
0100E:  MOVLW  01
01010:  MOVWF  xC8
01012:  MOVLB  0
01014:  CALL   079E
....................                glcd_text57(0, 41, MENU4, 1, OFF); 
01018:  MOVLB  4
0101A:  CLRF   xC3
0101C:  MOVLW  29
0101E:  MOVWF  xC4
01020:  CLRF   xC6
01022:  MOVLW  75
01024:  MOVWF  xC5
01026:  MOVLW  01
01028:  MOVWF  xC7
0102A:  CLRF   xC8
0102C:  MOVLB  0
0102E:  CALL   0596
....................                glcd_text57(100, 41, UniVel, 1, OFF); 
01032:  MOVLW  64
01034:  MOVLB  4
01036:  MOVWF  xC3
01038:  MOVLW  29
0103A:  MOVWF  xC4
0103C:  CLRF   xC6
0103E:  MOVLW  AD
01040:  MOVWF  xC5
01042:  MOVLW  01
01044:  MOVWF  xC7
01046:  CLRF   xC8
01048:  MOVLB  0
0104A:  CALL   0596
....................                menu_entrar(41,OFF); 
0104E:  MOVLW  29
01050:  MOVLB  4
01052:  MOVWF  xBB
01054:  CLRF   xBC
01056:  MOVLB  0
01058:  RCALL  0C8A
....................                 
....................           
....................                 
....................                glcd_update(); 
0105A:  CALL   0350
....................                break; 
0105E:  MOVLB  4
01060:  BRA    1066
01062:  MOVLB  0
01064:  MOVLB  4
....................             }             
....................          } 
....................          break; 
01066:  BRA    1530
01068:  MOVLB  0
....................       } 
....................       case 1: 
....................       { 
....................           
....................          break; 
0106A:  MOVLB  4
0106C:  BRA    1530
0106E:  MOVLB  0
....................       } 
....................       case 2: 
....................       { 
....................          switch (item) 
....................          { 
01070:  MOVLB  4
01072:  MOVF   xB9,W
01074:  XORLW  01
01076:  MOVLB  0
01078:  BZ    1080
0107A:  XORLW  03
0107C:  BZ    1118
0107E:  BRA    11B0
....................             case 1: 
....................             { 
....................                glcd_fillScreen(OFF); 
01080:  MOVLB  4
01082:  CLRF   xC3
01084:  MOVLB  0
01086:  CALL   02F6
....................                glcd_text57(0, 0, MENU2, 1, ON)   ; //Titulo 
0108A:  MOVLB  4
0108C:  CLRF   xC3
0108E:  CLRF   xC4
01090:  CLRF   xC6
01092:  MOVLW  33
01094:  MOVWF  xC5
01096:  MOVLW  01
01098:  MOVWF  xC7
0109A:  MOVWF  xC8
0109C:  MOVLB  0
0109E:  CALL   0596
....................                glcd_bar(0, 9, 127, 9, 2, ON);      //div 
010A2:  MOVLB  4
010A4:  CLRF   xC3
010A6:  MOVLW  09
010A8:  MOVWF  xC4
010AA:  MOVLW  7F
010AC:  MOVWF  xC5
010AE:  MOVLW  09
010B0:  MOVWF  xC6
010B2:  MOVLW  02
010B4:  MOVWF  xC7
010B6:  MOVLW  01
010B8:  MOVWF  xC8
010BA:  MOVLB  0
010BC:  CALL   079E
....................                glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
010C0:  MOVLB  4
010C2:  CLRF   xC3
010C4:  MOVLW  11
010C6:  MOVWF  xC4
010C8:  MOVLW  7F
010CA:  MOVWF  xC5
010CC:  MOVLW  11
010CE:  MOVWF  xC6
010D0:  MOVLW  09
010D2:  MOVWF  xC7
010D4:  MOVLW  01
010D6:  MOVWF  xC8
010D8:  MOVLB  0
010DA:  CALL   079E
....................                glcd_text57(0, 14, MENU2ITEM1, 1, OFF); 
010DE:  MOVLB  4
010E0:  CLRF   xC3
010E2:  MOVLW  0E
010E4:  MOVWF  xC4
010E6:  CLRF   xC6
010E8:  MOVLW  43
010EA:  MOVWF  xC5
010EC:  MOVLW  01
010EE:  MOVWF  xC7
010F0:  CLRF   xC8
010F2:  MOVLB  0
010F4:  CALL   0596
....................                   
....................                glcd_text57(0, 23, MENU2ITEM2, 1, ON)   ; 
010F8:  MOVLB  4
010FA:  CLRF   xC3
010FC:  MOVLW  17
010FE:  MOVWF  xC4
01100:  CLRF   xC6
01102:  MOVLW  4D
01104:  MOVWF  xC5
01106:  MOVLW  01
01108:  MOVWF  xC7
0110A:  MOVWF  xC8
0110C:  MOVLB  0
0110E:  CALL   0596
....................                 
....................                glcd_update(); 
01112:  CALL   0350
....................                break; 
01116:  BRA    11B0
....................             } 
....................             case 2: 
....................             { 
....................                glcd_fillScreen(OFF); 
01118:  MOVLB  4
0111A:  CLRF   xC3
0111C:  MOVLB  0
0111E:  CALL   02F6
....................                glcd_text57(0, 0, MENU2, 1, ON);       //Titulo 
01122:  MOVLB  4
01124:  CLRF   xC3
01126:  CLRF   xC4
01128:  CLRF   xC6
0112A:  MOVLW  33
0112C:  MOVWF  xC5
0112E:  MOVLW  01
01130:  MOVWF  xC7
01132:  MOVWF  xC8
01134:  MOVLB  0
01136:  CALL   0596
....................                glcd_bar(0, 9, 127, 9, 2, ON);         //div 
0113A:  MOVLB  4
0113C:  CLRF   xC3
0113E:  MOVLW  09
01140:  MOVWF  xC4
01142:  MOVLW  7F
01144:  MOVWF  xC5
01146:  MOVLW  09
01148:  MOVWF  xC6
0114A:  MOVLW  02
0114C:  MOVWF  xC7
0114E:  MOVLW  01
01150:  MOVWF  xC8
01152:  MOVLB  0
01154:  CALL   079E
....................                glcd_text57(0, 14, MENU2ITEM1, 1, ON); 
01158:  MOVLB  4
0115A:  CLRF   xC3
0115C:  MOVLW  0E
0115E:  MOVWF  xC4
01160:  CLRF   xC6
01162:  MOVLW  43
01164:  MOVWF  xC5
01166:  MOVLW  01
01168:  MOVWF  xC7
0116A:  MOVWF  xC8
0116C:  MOVLB  0
0116E:  CALL   0596
....................                glcd_bar(0, 26, 127, 26, 9, ON);       //selected 
01172:  MOVLB  4
01174:  CLRF   xC3
01176:  MOVLW  1A
01178:  MOVWF  xC4
0117A:  MOVLW  7F
0117C:  MOVWF  xC5
0117E:  MOVLW  1A
01180:  MOVWF  xC6
01182:  MOVLW  09
01184:  MOVWF  xC7
01186:  MOVLW  01
01188:  MOVWF  xC8
0118A:  MOVLB  0
0118C:  CALL   079E
....................                glcd_text57(0, 23, MENU2ITEM2, 1, OFF); 
01190:  MOVLB  4
01192:  CLRF   xC3
01194:  MOVLW  17
01196:  MOVWF  xC4
01198:  CLRF   xC6
0119A:  MOVLW  4D
0119C:  MOVWF  xC5
0119E:  MOVLW  01
011A0:  MOVWF  xC7
011A2:  CLRF   xC8
011A4:  MOVLB  0
011A6:  CALL   0596
....................           
....................                
....................                glcd_update(); 
011AA:  CALL   0350
....................                break; 
011AE:  BRA    11B0
....................             } 
....................              
....................          } 
....................        break; 
011B0:  MOVLB  4
011B2:  BRA    1530
011B4:  MOVLB  0
....................       } 
....................       case 3: 
....................       { 
....................          switch (item) 
....................                { 
011B6:  MOVLB  4
011B8:  MOVF   xB9,W
011BA:  XORLW  01
011BC:  MOVLB  0
011BE:  BZ    11C6
011C0:  XORLW  03
011C2:  BZ    125E
011C4:  BRA    12F6
....................                   case 1: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
011C6:  MOVLB  4
011C8:  CLRF   xC3
011CA:  MOVLB  0
011CC:  CALL   02F6
....................                      glcd_text57(0, 0, MENU3, 1, ON)   ; //Titulo 
011D0:  MOVLB  4
011D2:  CLRF   xC3
011D4:  CLRF   xC4
011D6:  CLRF   xC6
011D8:  MOVLW  59
011DA:  MOVWF  xC5
011DC:  MOVLW  01
011DE:  MOVWF  xC7
011E0:  MOVWF  xC8
011E2:  MOVLB  0
011E4:  CALL   0596
....................                      glcd_bar(0, 9, 127, 9, 2, ON);      //div 
011E8:  MOVLB  4
011EA:  CLRF   xC3
011EC:  MOVLW  09
011EE:  MOVWF  xC4
011F0:  MOVLW  7F
011F2:  MOVWF  xC5
011F4:  MOVLW  09
011F6:  MOVWF  xC6
011F8:  MOVLW  02
011FA:  MOVWF  xC7
011FC:  MOVLW  01
011FE:  MOVWF  xC8
01200:  MOVLB  0
01202:  CALL   079E
....................                      glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
01206:  MOVLB  4
01208:  CLRF   xC3
0120A:  MOVLW  11
0120C:  MOVWF  xC4
0120E:  MOVLW  7F
01210:  MOVWF  xC5
01212:  MOVLW  11
01214:  MOVWF  xC6
01216:  MOVLW  09
01218:  MOVWF  xC7
0121A:  MOVLW  01
0121C:  MOVWF  xC8
0121E:  MOVLB  0
01220:  CALL   079E
....................                      glcd_text57(0, 14, MENU3ITEM1, 1, OFF); 
01224:  MOVLB  4
01226:  CLRF   xC3
01228:  MOVLW  0E
0122A:  MOVWF  xC4
0122C:  CLRF   xC6
0122E:  MOVLW  62
01230:  MOVWF  xC5
01232:  MOVLW  01
01234:  MOVWF  xC7
01236:  CLRF   xC8
01238:  MOVLB  0
0123A:  CALL   0596
....................                         
....................                      glcd_text57(0, 23, MENU3ITEM2, 1, ON)   ; 
0123E:  MOVLB  4
01240:  CLRF   xC3
01242:  MOVLW  17
01244:  MOVWF  xC4
01246:  CLRF   xC6
01248:  MOVLW  6B
0124A:  MOVWF  xC5
0124C:  MOVLW  01
0124E:  MOVWF  xC7
01250:  MOVWF  xC8
01252:  MOVLB  0
01254:  CALL   0596
....................                       
....................                      glcd_update(); 
01258:  CALL   0350
....................                      break; 
0125C:  BRA    12F6
....................                   } 
....................                   case 2: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
0125E:  MOVLB  4
01260:  CLRF   xC3
01262:  MOVLB  0
01264:  CALL   02F6
....................                      glcd_text57(0, 0, MENU3, 1, ON);       //Titulo 
01268:  MOVLB  4
0126A:  CLRF   xC3
0126C:  CLRF   xC4
0126E:  CLRF   xC6
01270:  MOVLW  59
01272:  MOVWF  xC5
01274:  MOVLW  01
01276:  MOVWF  xC7
01278:  MOVWF  xC8
0127A:  MOVLB  0
0127C:  CALL   0596
....................                      glcd_bar(0, 9, 127, 9, 2, ON);         //div 
01280:  MOVLB  4
01282:  CLRF   xC3
01284:  MOVLW  09
01286:  MOVWF  xC4
01288:  MOVLW  7F
0128A:  MOVWF  xC5
0128C:  MOVLW  09
0128E:  MOVWF  xC6
01290:  MOVLW  02
01292:  MOVWF  xC7
01294:  MOVLW  01
01296:  MOVWF  xC8
01298:  MOVLB  0
0129A:  CALL   079E
....................                      glcd_text57(0, 14, MENU3ITEM1, 1, ON); 
0129E:  MOVLB  4
012A0:  CLRF   xC3
012A2:  MOVLW  0E
012A4:  MOVWF  xC4
012A6:  CLRF   xC6
012A8:  MOVLW  62
012AA:  MOVWF  xC5
012AC:  MOVLW  01
012AE:  MOVWF  xC7
012B0:  MOVWF  xC8
012B2:  MOVLB  0
012B4:  CALL   0596
....................                      glcd_bar(0, 26, 127, 26, 9, ON);       //selected 
012B8:  MOVLB  4
012BA:  CLRF   xC3
012BC:  MOVLW  1A
012BE:  MOVWF  xC4
012C0:  MOVLW  7F
012C2:  MOVWF  xC5
012C4:  MOVLW  1A
012C6:  MOVWF  xC6
012C8:  MOVLW  09
012CA:  MOVWF  xC7
012CC:  MOVLW  01
012CE:  MOVWF  xC8
012D0:  MOVLB  0
012D2:  CALL   079E
....................                      glcd_text57(0, 23, MENU3ITEM2, 1, OFF); 
012D6:  MOVLB  4
012D8:  CLRF   xC3
012DA:  MOVLW  17
012DC:  MOVWF  xC4
012DE:  CLRF   xC6
012E0:  MOVLW  6B
012E2:  MOVWF  xC5
012E4:  MOVLW  01
012E6:  MOVWF  xC7
012E8:  CLRF   xC8
012EA:  MOVLB  0
012EC:  CALL   0596
....................                 
....................                      
....................                      glcd_update(); 
012F0:  CALL   0350
....................                      break; 
012F4:  BRA    12F6
....................                   } 
....................                } 
....................                break; 
012F6:  MOVLB  4
012F8:  BRA    1530
012FA:  MOVLB  0
....................       } 
....................       case 4: 
....................       { 
....................          switch (item) 
....................                { 
012FC:  MOVLB  4
012FE:  MOVF   xB9,W
01300:  XORLW  01
01302:  MOVLB  0
01304:  BZ    1312
01306:  XORLW  03
01308:  BZ    13C4
0130A:  XORLW  01
0130C:  BTFSC  FD8.2
0130E:  BRA    1476
01310:  BRA    1528
....................                   case 1: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
01312:  MOVLB  4
01314:  CLRF   xC3
01316:  MOVLB  0
01318:  CALL   02F6
....................                      glcd_text57(0, 0, MENU4, 1, ON)   ; //Titulo 
0131C:  MOVLB  4
0131E:  CLRF   xC3
01320:  CLRF   xC4
01322:  CLRF   xC6
01324:  MOVLW  75
01326:  MOVWF  xC5
01328:  MOVLW  01
0132A:  MOVWF  xC7
0132C:  MOVWF  xC8
0132E:  MOVLB  0
01330:  CALL   0596
....................                      glcd_bar(0, 9, 127, 9, 2, ON);      //div 
01334:  MOVLB  4
01336:  CLRF   xC3
01338:  MOVLW  09
0133A:  MOVWF  xC4
0133C:  MOVLW  7F
0133E:  MOVWF  xC5
01340:  MOVLW  09
01342:  MOVWF  xC6
01344:  MOVLW  02
01346:  MOVWF  xC7
01348:  MOVLW  01
0134A:  MOVWF  xC8
0134C:  MOVLB  0
0134E:  CALL   079E
....................                      glcd_bar(0, 17, 127, 17, 9, ON);    //selected 
01352:  MOVLB  4
01354:  CLRF   xC3
01356:  MOVLW  11
01358:  MOVWF  xC4
0135A:  MOVLW  7F
0135C:  MOVWF  xC5
0135E:  MOVLW  11
01360:  MOVWF  xC6
01362:  MOVLW  09
01364:  MOVWF  xC7
01366:  MOVLW  01
01368:  MOVWF  xC8
0136A:  MOVLB  0
0136C:  CALL   079E
....................                      glcd_text57(0, 14, MENU4ITEM1, 1, OFF); 
01370:  MOVLB  4
01372:  CLRF   xC3
01374:  MOVLW  0E
01376:  MOVWF  xC4
01378:  CLRF   xC6
0137A:  MOVLW  80
0137C:  MOVWF  xC5
0137E:  MOVLW  01
01380:  MOVWF  xC7
01382:  CLRF   xC8
01384:  MOVLB  0
01386:  CALL   0596
....................                         
....................                      glcd_text57(0, 23, MENU4ITEM2, 1, ON)   ; 
0138A:  MOVLB  4
0138C:  CLRF   xC3
0138E:  MOVLW  17
01390:  MOVWF  xC4
01392:  CLRF   xC6
01394:  MOVLW  86
01396:  MOVWF  xC5
01398:  MOVLW  01
0139A:  MOVWF  xC7
0139C:  MOVWF  xC8
0139E:  MOVLB  0
013A0:  CALL   0596
....................                      glcd_text57(0, 32, MENU4ITEM3, 1, ON)   ; 
013A4:  MOVLB  4
013A6:  CLRF   xC3
013A8:  MOVLW  20
013AA:  MOVWF  xC4
013AC:  CLRF   xC6
013AE:  MOVLW  8D
013B0:  MOVWF  xC5
013B2:  MOVLW  01
013B4:  MOVWF  xC7
013B6:  MOVWF  xC8
013B8:  MOVLB  0
013BA:  CALL   0596
....................                      glcd_update(); 
013BE:  CALL   0350
....................                      break; 
013C2:  BRA    1528
....................                   } 
....................                   case 2: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
013C4:  MOVLB  4
013C6:  CLRF   xC3
013C8:  MOVLB  0
013CA:  CALL   02F6
....................                      glcd_text57(0, 0, MENU4, 1, ON);       //Titulo 
013CE:  MOVLB  4
013D0:  CLRF   xC3
013D2:  CLRF   xC4
013D4:  CLRF   xC6
013D6:  MOVLW  75
013D8:  MOVWF  xC5
013DA:  MOVLW  01
013DC:  MOVWF  xC7
013DE:  MOVWF  xC8
013E0:  MOVLB  0
013E2:  CALL   0596
....................                      glcd_bar(0, 9, 127, 9, 2, ON);         //div 
013E6:  MOVLB  4
013E8:  CLRF   xC3
013EA:  MOVLW  09
013EC:  MOVWF  xC4
013EE:  MOVLW  7F
013F0:  MOVWF  xC5
013F2:  MOVLW  09
013F4:  MOVWF  xC6
013F6:  MOVLW  02
013F8:  MOVWF  xC7
013FA:  MOVLW  01
013FC:  MOVWF  xC8
013FE:  MOVLB  0
01400:  CALL   079E
....................                      glcd_text57(0, 14, MENU4ITEM1, 1, ON); 
01404:  MOVLB  4
01406:  CLRF   xC3
01408:  MOVLW  0E
0140A:  MOVWF  xC4
0140C:  CLRF   xC6
0140E:  MOVLW  80
01410:  MOVWF  xC5
01412:  MOVLW  01
01414:  MOVWF  xC7
01416:  MOVWF  xC8
01418:  MOVLB  0
0141A:  CALL   0596
....................                      glcd_bar(0, 26, 127, 26, 9, ON);       //selected 
0141E:  MOVLB  4
01420:  CLRF   xC3
01422:  MOVLW  1A
01424:  MOVWF  xC4
01426:  MOVLW  7F
01428:  MOVWF  xC5
0142A:  MOVLW  1A
0142C:  MOVWF  xC6
0142E:  MOVLW  09
01430:  MOVWF  xC7
01432:  MOVLW  01
01434:  MOVWF  xC8
01436:  MOVLB  0
01438:  CALL   079E
....................                      glcd_text57(0, 23, MENU4ITEM2, 1, OFF); 
0143C:  MOVLB  4
0143E:  CLRF   xC3
01440:  MOVLW  17
01442:  MOVWF  xC4
01444:  CLRF   xC6
01446:  MOVLW  86
01448:  MOVWF  xC5
0144A:  MOVLW  01
0144C:  MOVWF  xC7
0144E:  CLRF   xC8
01450:  MOVLB  0
01452:  CALL   0596
....................                      glcd_text57(0, 32, MENU4ITEM3, 1, ON)   ; 
01456:  MOVLB  4
01458:  CLRF   xC3
0145A:  MOVLW  20
0145C:  MOVWF  xC4
0145E:  CLRF   xC6
01460:  MOVLW  8D
01462:  MOVWF  xC5
01464:  MOVLW  01
01466:  MOVWF  xC7
01468:  MOVWF  xC8
0146A:  MOVLB  0
0146C:  CALL   0596
....................                      
....................                      glcd_update(); 
01470:  CALL   0350
....................                      break; 
01474:  BRA    1528
....................                   } 
....................                   case 3: 
....................                   { 
....................                      glcd_fillScreen(OFF); 
01476:  MOVLB  4
01478:  CLRF   xC3
0147A:  MOVLB  0
0147C:  CALL   02F6
....................                      glcd_text57(0, 0, MENU4, 1, ON);       //Titulo 
01480:  MOVLB  4
01482:  CLRF   xC3
01484:  CLRF   xC4
01486:  CLRF   xC6
01488:  MOVLW  75
0148A:  MOVWF  xC5
0148C:  MOVLW  01
0148E:  MOVWF  xC7
01490:  MOVWF  xC8
01492:  MOVLB  0
01494:  CALL   0596
....................                      glcd_bar(0, 9, 127, 9, 2, ON);         //div 
01498:  MOVLB  4
0149A:  CLRF   xC3
0149C:  MOVLW  09
0149E:  MOVWF  xC4
014A0:  MOVLW  7F
014A2:  MOVWF  xC5
014A4:  MOVLW  09
014A6:  MOVWF  xC6
014A8:  MOVLW  02
014AA:  MOVWF  xC7
014AC:  MOVLW  01
014AE:  MOVWF  xC8
014B0:  MOVLB  0
014B2:  CALL   079E
....................                      glcd_text57(0, 14, MENU4ITEM1, 1, ON); 
014B6:  MOVLB  4
014B8:  CLRF   xC3
014BA:  MOVLW  0E
014BC:  MOVWF  xC4
014BE:  CLRF   xC6
014C0:  MOVLW  80
014C2:  MOVWF  xC5
014C4:  MOVLW  01
014C6:  MOVWF  xC7
014C8:  MOVWF  xC8
014CA:  MOVLB  0
014CC:  CALL   0596
....................                      
....................                      glcd_text57(0, 23, MENU4ITEM2, 1, ON); 
014D0:  MOVLB  4
014D2:  CLRF   xC3
014D4:  MOVLW  17
014D6:  MOVWF  xC4
014D8:  CLRF   xC6
014DA:  MOVLW  86
014DC:  MOVWF  xC5
014DE:  MOVLW  01
014E0:  MOVWF  xC7
014E2:  MOVWF  xC8
014E4:  MOVLB  0
014E6:  CALL   0596
....................                      glcd_bar(0, 35, 127, 35, 9, ON); //selected 
014EA:  MOVLB  4
014EC:  CLRF   xC3
014EE:  MOVLW  23
014F0:  MOVWF  xC4
014F2:  MOVLW  7F
014F4:  MOVWF  xC5
014F6:  MOVLW  23
014F8:  MOVWF  xC6
014FA:  MOVLW  09
014FC:  MOVWF  xC7
014FE:  MOVLW  01
01500:  MOVWF  xC8
01502:  MOVLB  0
01504:  CALL   079E
....................                      glcd_text57(0, 32, MENU4ITEM3, 1, OFF)   ; 
01508:  MOVLB  4
0150A:  CLRF   xC3
0150C:  MOVLW  20
0150E:  MOVWF  xC4
01510:  CLRF   xC6
01512:  MOVLW  8D
01514:  MOVWF  xC5
01516:  MOVLW  01
01518:  MOVWF  xC7
0151A:  CLRF   xC8
0151C:  MOVLB  0
0151E:  CALL   0596
....................                      
....................                      glcd_update(); 
01522:  CALL   0350
....................                      break; 
01526:  BRA    1528
....................                   } 
....................                } 
....................                break; 
01528:  MOVLB  4
0152A:  BRA    1530
0152C:  MOVLB  0
0152E:  MOVLB  4
....................       } 
....................     
....................    } 
.................... } 
01530:  MOVLB  0
01532:  RETLW  00
....................  
.................... void menu_submenu(char menu) 
.................... { 
....................    switch (menu) 
....................    { 
*
028FC:  MOVLW  01
028FE:  MOVLB  4
02900:  SUBWF  xB8,W
02902:  ADDLW  FC
02904:  BTFSC  FD8.0
02906:  BRA    2ABA
02908:  ADDLW  04
0290A:  MOVLB  0
0290C:  GOTO   2C64
....................       case 1: 
....................       {   
....................          menu_timemenu(); 
02910:  GOTO   1B50
....................          i=0; 
02914:  CLRF   06
....................          return; 
02916:  BRA    2C62
....................          break; 
02918:  MOVLB  4
0291A:  BRA    2ABA
0291C:  MOVLB  0
....................       } 
....................       case 2: 
....................       {   
....................           
....................          glcd_fillScreen(OFF); 
0291E:  MOVLB  4
02920:  CLRF   xC3
02922:  MOVLB  0
02924:  CALL   02F6
....................          glcd_text57(0, 0, MENU2, 1, ON)   ; 
02928:  MOVLB  4
0292A:  CLRF   xC3
0292C:  CLRF   xC4
0292E:  CLRF   xC6
02930:  MOVLW  33
02932:  MOVWF  xC5
02934:  MOVLW  01
02936:  MOVWF  xC7
02938:  MOVWF  xC8
0293A:  MOVLB  0
0293C:  CALL   0596
....................          glcd_bar(0, 9, 127, 9, 2, ON); //div 
02940:  MOVLB  4
02942:  CLRF   xC3
02944:  MOVLW  09
02946:  MOVWF  xC4
02948:  MOVLW  7F
0294A:  MOVWF  xC5
0294C:  MOVLW  09
0294E:  MOVWF  xC6
02950:  MOVLW  02
02952:  MOVWF  xC7
02954:  MOVLW  01
02956:  MOVWF  xC8
02958:  MOVLB  0
0295A:  CALL   079E
....................          glcd_text57(0, 14, MENU2ITEM1, 1, ON)   ; 
0295E:  MOVLB  4
02960:  CLRF   xC3
02962:  MOVLW  0E
02964:  MOVWF  xC4
02966:  CLRF   xC6
02968:  MOVLW  43
0296A:  MOVWF  xC5
0296C:  MOVLW  01
0296E:  MOVWF  xC7
02970:  MOVWF  xC8
02972:  MOVLB  0
02974:  CALL   0596
....................          glcd_text57(0, 23, MENU2ITEM2, 1, ON)   ; 
02978:  MOVLB  4
0297A:  CLRF   xC3
0297C:  MOVLW  17
0297E:  MOVWF  xC4
02980:  CLRF   xC6
02982:  MOVLW  4D
02984:  MOVWF  xC5
02986:  MOVLW  01
02988:  MOVWF  xC7
0298A:  MOVWF  xC8
0298C:  MOVLB  0
0298E:  CALL   0596
....................          glcd_update(); 
02992:  CALL   0350
....................          i = 0; 
02996:  CLRF   06
....................          break; 
02998:  MOVLB  4
0299A:  BRA    2ABA
0299C:  MOVLB  0
....................       } 
....................       case 3: 
....................       {   
....................          glcd_fillScreen(OFF); 
0299E:  MOVLB  4
029A0:  CLRF   xC3
029A2:  MOVLB  0
029A4:  CALL   02F6
....................          glcd_text57(0, 0, MENU3, 1, ON)   ; 
029A8:  MOVLB  4
029AA:  CLRF   xC3
029AC:  CLRF   xC4
029AE:  CLRF   xC6
029B0:  MOVLW  59
029B2:  MOVWF  xC5
029B4:  MOVLW  01
029B6:  MOVWF  xC7
029B8:  MOVWF  xC8
029BA:  MOVLB  0
029BC:  CALL   0596
....................          glcd_bar(0, 9, 127, 9, 2, ON); //div 
029C0:  MOVLB  4
029C2:  CLRF   xC3
029C4:  MOVLW  09
029C6:  MOVWF  xC4
029C8:  MOVLW  7F
029CA:  MOVWF  xC5
029CC:  MOVLW  09
029CE:  MOVWF  xC6
029D0:  MOVLW  02
029D2:  MOVWF  xC7
029D4:  MOVLW  01
029D6:  MOVWF  xC8
029D8:  MOVLB  0
029DA:  CALL   079E
....................          glcd_text57(0, 14, MENU3ITEM1, 1, ON)   ; 
029DE:  MOVLB  4
029E0:  CLRF   xC3
029E2:  MOVLW  0E
029E4:  MOVWF  xC4
029E6:  CLRF   xC6
029E8:  MOVLW  62
029EA:  MOVWF  xC5
029EC:  MOVLW  01
029EE:  MOVWF  xC7
029F0:  MOVWF  xC8
029F2:  MOVLB  0
029F4:  CALL   0596
....................          glcd_text57(0, 23, MENU3ITEM2, 1, ON)   ; 
029F8:  MOVLB  4
029FA:  CLRF   xC3
029FC:  MOVLW  17
029FE:  MOVWF  xC4
02A00:  CLRF   xC6
02A02:  MOVLW  6B
02A04:  MOVWF  xC5
02A06:  MOVLW  01
02A08:  MOVWF  xC7
02A0A:  MOVWF  xC8
02A0C:  MOVLB  0
02A0E:  CALL   0596
....................          glcd_update(); 
02A12:  CALL   0350
....................          i = 0; 
02A16:  CLRF   06
....................          break; 
02A18:  MOVLB  4
02A1A:  BRA    2ABA
02A1C:  MOVLB  0
....................       } 
....................       case 4: 
....................       {   
....................          glcd_fillScreen(OFF); 
02A1E:  MOVLB  4
02A20:  CLRF   xC3
02A22:  MOVLB  0
02A24:  CALL   02F6
....................          glcd_text57(0, 0, MENU4, 1, ON)   ; 
02A28:  MOVLB  4
02A2A:  CLRF   xC3
02A2C:  CLRF   xC4
02A2E:  CLRF   xC6
02A30:  MOVLW  75
02A32:  MOVWF  xC5
02A34:  MOVLW  01
02A36:  MOVWF  xC7
02A38:  MOVWF  xC8
02A3A:  MOVLB  0
02A3C:  CALL   0596
....................          glcd_bar(0, 9, 127, 9, 2, ON); //div 
02A40:  MOVLB  4
02A42:  CLRF   xC3
02A44:  MOVLW  09
02A46:  MOVWF  xC4
02A48:  MOVLW  7F
02A4A:  MOVWF  xC5
02A4C:  MOVLW  09
02A4E:  MOVWF  xC6
02A50:  MOVLW  02
02A52:  MOVWF  xC7
02A54:  MOVLW  01
02A56:  MOVWF  xC8
02A58:  MOVLB  0
02A5A:  CALL   079E
....................          glcd_text57(0, 14, MENU4ITEM1, 1, ON)   ; 
02A5E:  MOVLB  4
02A60:  CLRF   xC3
02A62:  MOVLW  0E
02A64:  MOVWF  xC4
02A66:  CLRF   xC6
02A68:  MOVLW  80
02A6A:  MOVWF  xC5
02A6C:  MOVLW  01
02A6E:  MOVWF  xC7
02A70:  MOVWF  xC8
02A72:  MOVLB  0
02A74:  CALL   0596
....................          glcd_text57(0, 23, MENU4ITEM2, 1, ON)   ; 
02A78:  MOVLB  4
02A7A:  CLRF   xC3
02A7C:  MOVLW  17
02A7E:  MOVWF  xC4
02A80:  CLRF   xC6
02A82:  MOVLW  86
02A84:  MOVWF  xC5
02A86:  MOVLW  01
02A88:  MOVWF  xC7
02A8A:  MOVWF  xC8
02A8C:  MOVLB  0
02A8E:  CALL   0596
....................          glcd_text57(0, 32, MENU4ITEM3, 1, ON)   ; 
02A92:  MOVLB  4
02A94:  CLRF   xC3
02A96:  MOVLW  20
02A98:  MOVWF  xC4
02A9A:  CLRF   xC6
02A9C:  MOVLW  8D
02A9E:  MOVWF  xC5
02AA0:  MOVLW  01
02AA2:  MOVWF  xC7
02AA4:  MOVWF  xC8
02AA6:  MOVLB  0
02AA8:  CALL   0596
....................          glcd_update(); 
02AAC:  CALL   0350
....................          i = 0; 
02AB0:  CLRF   06
....................          break; 
02AB2:  MOVLB  4
02AB4:  BRA    2ABA
02AB6:  MOVLB  0
02AB8:  MOVLB  4
....................       } 
....................    } 
....................     
....................    while(1) 
....................    { 
....................       readbuttons(); 
02ABA:  MOVLB  0
02ABC:  CALL   0E48
....................       if ((up==0)&&(down==1)) 
02AC0:  MOVF   0D,F
02AC2:  BNZ   2AD8
02AC4:  DECFSZ 0F,W
02AC6:  BRA    2AD8
....................       { 
....................          i+=1; 
02AC8:  MOVLW  01
02ACA:  ADDWF  06,F
....................          menu_select(i,menu); 
02ACC:  MOVFF  06,4B9
02AD0:  MOVFF  4B8,4BA
02AD4:  CALL   0EAE
....................           
....................       } 
....................       if ((up==1)&&(down==0)) 
02AD8:  DECFSZ 0D,W
02ADA:  BRA    2AF0
02ADC:  MOVF   0F,F
02ADE:  BNZ   2AF0
....................       { 
....................          i-=1; 
02AE0:  MOVLW  01
02AE2:  SUBWF  06,F
....................          menu_select(i,menu); 
02AE4:  MOVFF  06,4B9
02AE8:  MOVFF  4B8,4BA
02AEC:  CALL   0EAE
....................           
....................       } 
....................       if (left==1) 
02AF0:  DECFSZ 13,W
02AF2:  BRA    2AFA
....................       { 
....................          i = 0; 
02AF4:  CLRF   06
....................           
....................          pressed = 0; 
02AF6:  CLRF   08
....................          break; 
02AF8:  BRA    2C62
....................       } 
....................       if (enter==1) 
02AFA:  DECFSZ 11,W
02AFC:  BRA    2C5E
....................       { 
....................          switch (menu) 
....................          { 
02AFE:  MOVLB  4
02B00:  MOVF   xB8,W
02B02:  XORLW  02
02B04:  MOVLB  0
02B06:  BZ    2B12
02B08:  XORLW  01
02B0A:  BZ    2B70
02B0C:  XORLW  07
02B0E:  BZ    2BCE
02B10:  BRA    2C58
....................             case 2: 
....................             { 
....................                switch (i) 
....................                { 
02B12:  MOVF   06,W
02B14:  XORLW  01
02B16:  BZ    2B1E
02B18:  XORLW  03
02B1A:  BZ    2B46
02B1C:  BRA    2B6E
....................                   case 1: 
....................                   { 
....................                      UniTemp = "C"; 
02B1E:  CLRF   FEA
02B20:  MOVLW  A7
02B22:  MOVWF  FE9
02B24:  MOVFF  FF2,4B9
02B28:  BCF    FF2.7
02B2A:  MOVLW  00
02B2C:  CALL   0200
02B30:  TBLRD*-
02B32:  TBLRD*+
02B34:  MOVF   FF5,W
02B36:  MOVWF  FEE
02B38:  IORLW  00
02B3A:  BNZ   2B32
02B3C:  MOVLB  4
02B3E:  BTFSC  xB9.7
02B40:  BSF    FF2.7
....................                       
....................                      break; 
02B42:  MOVLB  0
02B44:  BRA    2B6E
....................                   } 
....................                   case 2: 
....................                   { 
....................                      UniTemp = "F"; 
02B46:  CLRF   FEA
02B48:  MOVLW  A7
02B4A:  MOVWF  FE9
02B4C:  MOVFF  FF2,4B9
02B50:  BCF    FF2.7
02B52:  MOVLW  00
02B54:  CALL   0212
02B58:  TBLRD*-
02B5A:  TBLRD*+
02B5C:  MOVF   FF5,W
02B5E:  MOVWF  FEE
02B60:  IORLW  00
02B62:  BNZ   2B5A
02B64:  MOVLB  4
02B66:  BTFSC  xB9.7
02B68:  BSF    FF2.7
....................                       
....................                      break; 
02B6A:  MOVLB  0
02B6C:  BRA    2B6E
....................                   } 
....................                } 
....................                break; 
02B6E:  BRA    2C58
....................             } 
....................             case 3: 
....................             { 
....................                switch (i) 
....................                { 
02B70:  MOVF   06,W
02B72:  XORLW  01
02B74:  BZ    2B7C
02B76:  XORLW  03
02B78:  BZ    2BA4
02B7A:  BRA    2BCC
....................                   case 1: 
....................                   { 
....................                      UniPres = "Pa"; 
02B7C:  CLRF   FEA
02B7E:  MOVLW  A9
02B80:  MOVWF  FE9
02B82:  MOVFF  FF2,4B9
02B86:  BCF    FF2.7
02B88:  MOVLW  00
02B8A:  CALL   0224
02B8E:  TBLRD*-
02B90:  TBLRD*+
02B92:  MOVF   FF5,W
02B94:  MOVWF  FEE
02B96:  IORLW  00
02B98:  BNZ   2B90
02B9A:  MOVLB  4
02B9C:  BTFSC  xB9.7
02B9E:  BSF    FF2.7
....................                       
....................                      break; 
02BA0:  MOVLB  0
02BA2:  BRA    2BCC
....................                   } 
....................                   case 2: 
....................                   { 
....................                      UniPres = "mBa\0"; 
02BA4:  CLRF   FEA
02BA6:  MOVLW  A9
02BA8:  MOVWF  FE9
02BAA:  MOVFF  FF2,4B9
02BAE:  BCF    FF2.7
02BB0:  MOVLW  00
02BB2:  CALL   0238
02BB6:  TBLRD*-
02BB8:  TBLRD*+
02BBA:  MOVF   FF5,W
02BBC:  MOVWF  FEE
02BBE:  IORLW  00
02BC0:  BNZ   2BB8
02BC2:  MOVLB  4
02BC4:  BTFSC  xB9.7
02BC6:  BSF    FF2.7
....................                       
....................                      break; 
02BC8:  MOVLB  0
02BCA:  BRA    2BCC
....................                   } 
....................                } 
....................                break; 
02BCC:  BRA    2C58
....................             } 
....................             case 4: 
....................             { 
....................                switch (i) 
....................                { 
02BCE:  MOVF   06,W
02BD0:  XORLW  01
02BD2:  BZ    2BDE
02BD4:  XORLW  03
02BD6:  BZ    2C06
02BD8:  XORLW  01
02BDA:  BZ    2C2E
02BDC:  BRA    2C56
....................                   case 1: 
....................                   { 
....................                      UniVel = "m/s"; 
02BDE:  CLRF   FEA
02BE0:  MOVLW  AD
02BE2:  MOVWF  FE9
02BE4:  MOVFF  FF2,4B9
02BE8:  BCF    FF2.7
02BEA:  MOVLW  00
02BEC:  CALL   024E
02BF0:  TBLRD*-
02BF2:  TBLRD*+
02BF4:  MOVF   FF5,W
02BF6:  MOVWF  FEE
02BF8:  IORLW  00
02BFA:  BNZ   2BF2
02BFC:  MOVLB  4
02BFE:  BTFSC  xB9.7
02C00:  BSF    FF2.7
....................                       
....................                      break; 
02C02:  MOVLB  0
02C04:  BRA    2C56
....................                   } 
....................                   case 2: 
....................                   { 
....................                      UniVel = "km/h"; 
02C06:  CLRF   FEA
02C08:  MOVLW  AD
02C0A:  MOVWF  FE9
02C0C:  MOVFF  FF2,4B9
02C10:  BCF    FF2.7
02C12:  MOVLW  00
02C14:  CALL   0262
02C18:  TBLRD*-
02C1A:  TBLRD*+
02C1C:  MOVF   FF5,W
02C1E:  MOVWF  FEE
02C20:  IORLW  00
02C22:  BNZ   2C1A
02C24:  MOVLB  4
02C26:  BTFSC  xB9.7
02C28:  BSF    FF2.7
....................                       
....................                      break; 
02C2A:  MOVLB  0
02C2C:  BRA    2C56
....................                   } 
....................                   case 3: 
....................                   { 
....................                      UniVel = "Nud";  
02C2E:  CLRF   FEA
02C30:  MOVLW  AD
02C32:  MOVWF  FE9
02C34:  MOVFF  FF2,4B9
02C38:  BCF    FF2.7
02C3A:  MOVLW  00
02C3C:  CALL   0278
02C40:  TBLRD*-
02C42:  TBLRD*+
02C44:  MOVF   FF5,W
02C46:  MOVWF  FEE
02C48:  IORLW  00
02C4A:  BNZ   2C42
02C4C:  MOVLB  4
02C4E:  BTFSC  xB9.7
02C50:  BSF    FF2.7
....................                      break; 
02C52:  MOVLB  0
02C54:  BRA    2C56
....................                   } 
....................                } 
....................                break; 
02C56:  BRA    2C58
....................             } 
....................                 
....................          } 
....................          i=0; 
02C58:  CLRF   06
....................          pressed=0; 
02C5A:  CLRF   08
....................          break; 
02C5C:  BRA    2C62
....................       } 
....................       pressed = 0; 
02C5E:  CLRF   08
....................    } 
02C60:  BRA    2ABC
.................... } 
02C62:  RETLW  00
....................  
.................... void menu_mainmenu(void) 
.................... { 
....................    menu_drawmain(); 
*
02C86:  CALL   0D16
....................    while (1) 
....................    { 
....................       readbuttons(); 
02C8A:  CALL   0E48
....................       if ((up==0)&&(down==1)) 
02C8E:  MOVF   0D,F
02C90:  BNZ   2CA8
02C92:  DECFSZ 0F,W
02C94:  BRA    2CA8
....................       { 
....................          i+=1; 
02C96:  MOVLW  01
02C98:  ADDWF  06,F
....................          menu_select(i,0); 
02C9A:  MOVFF  06,4B9
02C9E:  MOVLB  4
02CA0:  CLRF   xBA
02CA2:  MOVLB  0
02CA4:  CALL   0EAE
....................           
....................       } 
....................       if ((up==1)&&(down==0)) 
02CA8:  DECFSZ 0D,W
02CAA:  BRA    2CC2
02CAC:  MOVF   0F,F
02CAE:  BNZ   2CC2
....................       { 
....................          i-=1; 
02CB0:  MOVLW  01
02CB2:  SUBWF  06,F
....................          menu_select(i,0); 
02CB4:  MOVFF  06,4B9
02CB8:  MOVLB  4
02CBA:  CLRF   xBA
02CBC:  MOVLB  0
02CBE:  CALL   0EAE
....................           
....................       } 
....................       if (right==1) 
02CC2:  DECFSZ 16,W
02CC4:  BRA    2D0C
....................       { 
....................          if (i==1) 
02CC6:  DECFSZ 06,W
02CC8:  BRA    2CD4
....................          { 
....................             menu_submenu(1); 
02CCA:  MOVLW  01
02CCC:  MOVLB  4
02CCE:  MOVWF  xB8
02CD0:  MOVLB  0
02CD2:  RCALL  28FC
....................          } 
....................          if (i==2) 
02CD4:  MOVF   06,W
02CD6:  SUBLW  02
02CD8:  BNZ   2CE4
....................          { 
....................             menu_submenu(2); 
02CDA:  MOVLW  02
02CDC:  MOVLB  4
02CDE:  MOVWF  xB8
02CE0:  MOVLB  0
02CE2:  RCALL  28FC
....................          } 
....................          if (i==3) 
02CE4:  MOVF   06,W
02CE6:  SUBLW  03
02CE8:  BNZ   2CF4
....................          { 
....................             menu_submenu(3); 
02CEA:  MOVLW  03
02CEC:  MOVLB  4
02CEE:  MOVWF  xB8
02CF0:  MOVLB  0
02CF2:  RCALL  28FC
....................          } 
....................          if (i==4) 
02CF4:  MOVF   06,W
02CF6:  SUBLW  04
02CF8:  BNZ   2D04
....................          { 
....................             menu_submenu(4); 
02CFA:  MOVLW  04
02CFC:  MOVLB  4
02CFE:  MOVWF  xB8
02D00:  MOVLB  0
02D02:  RCALL  28FC
....................          } 
....................          if (i==0) 
02D04:  MOVF   06,F
02D06:  BNZ   2D0C
....................          { 
....................             menu_drawmain(); 
02D08:  CALL   0D16
....................          } 
....................       } 
....................       pressed = 0; 
02D0C:  CLRF   08
....................    } 
02D0E:  BRA    2C8A
.................... } 
02D10:  GOTO   2F8E (RETURN)
....................  
.................... void menu_timemenu(void) 
.................... { 
....................    glcd_fillScreen(OFF); 
*
01B50:  MOVLB  4
01B52:  CLRF   xC3
01B54:  MOVLB  0
01B56:  CALL   02F6
....................    glcd_text57(0, 0, MENU1, 1, ON); 
01B5A:  MOVLB  4
01B5C:  CLRF   xC3
01B5E:  CLRF   xC4
01B60:  CLRF   xC6
01B62:  MOVLW  25
01B64:  MOVWF  xC5
01B66:  MOVLW  01
01B68:  MOVWF  xC7
01B6A:  MOVWF  xC8
01B6C:  MOVLB  0
01B6E:  CALL   0596
....................    glcd_bar(0, 9, 127, 9, 2, ON); //div 
01B72:  MOVLB  4
01B74:  CLRF   xC3
01B76:  MOVLW  09
01B78:  MOVWF  xC4
01B7A:  MOVLW  7F
01B7C:  MOVWF  xC5
01B7E:  MOVLW  09
01B80:  MOVWF  xC6
01B82:  MOVLW  02
01B84:  MOVWF  xC7
01B86:  MOVLW  01
01B88:  MOVWF  xC8
01B8A:  MOVLB  0
01B8C:  CALL   079E
....................     
....................    glcd_rect(5, 20, 25, 35, NO, ON);         //Dia    
01B90:  MOVLW  05
01B92:  MOVLB  4
01B94:  MOVWF  xC3
01B96:  MOVLW  14
01B98:  MOVWF  xC4
01B9A:  MOVLW  19
01B9C:  MOVWF  xC5
01B9E:  MOVLW  23
01BA0:  MOVWF  xC6
01BA2:  CLRF   xC7
01BA4:  MOVLW  01
01BA6:  MOVWF  xC8
01BA8:  MOVLB  0
01BAA:  RCALL  157A
....................    glcd_text57(9, 24, dia, 1, ON); 
01BAC:  MOVLW  09
01BAE:  MOVLB  4
01BB0:  MOVWF  xC3
01BB2:  MOVLW  18
01BB4:  MOVWF  xC4
01BB6:  CLRF   xC6
01BB8:  MOVLW  95
01BBA:  MOVWF  xC5
01BBC:  MOVLW  01
01BBE:  MOVWF  xC7
01BC0:  MOVWF  xC8
01BC2:  MOVLB  0
01BC4:  CALL   0596
....................     
....................    glcd_rect(35, 20, 55, 35, NO, ON);        //Mes 
01BC8:  MOVLW  23
01BCA:  MOVLB  4
01BCC:  MOVWF  xC3
01BCE:  MOVLW  14
01BD0:  MOVWF  xC4
01BD2:  MOVLW  37
01BD4:  MOVWF  xC5
01BD6:  MOVLW  23
01BD8:  MOVWF  xC6
01BDA:  CLRF   xC7
01BDC:  MOVLW  01
01BDE:  MOVWF  xC8
01BE0:  MOVLB  0
01BE2:  RCALL  157A
....................    glcd_text57(39, 24, mes, 1, ON); 
01BE4:  MOVLW  27
01BE6:  MOVLB  4
01BE8:  MOVWF  xC3
01BEA:  MOVLW  18
01BEC:  MOVWF  xC4
01BEE:  CLRF   xC6
01BF0:  MOVLW  98
01BF2:  MOVWF  xC5
01BF4:  MOVLW  01
01BF6:  MOVWF  xC7
01BF8:  MOVWF  xC8
01BFA:  MOVLB  0
01BFC:  CALL   0596
....................     
....................    glcd_rect(65, 20, 85, 35, NO, ON);        //Ao 
01C00:  MOVLW  41
01C02:  MOVLB  4
01C04:  MOVWF  xC3
01C06:  MOVLW  14
01C08:  MOVWF  xC4
01C0A:  MOVLW  55
01C0C:  MOVWF  xC5
01C0E:  MOVLW  23
01C10:  MOVWF  xC6
01C12:  CLRF   xC7
01C14:  MOVLW  01
01C16:  MOVWF  xC8
01C18:  MOVLB  0
01C1A:  RCALL  157A
....................    glcd_text57(69, 24, ao, 1, ON); 
01C1C:  MOVLW  45
01C1E:  MOVLB  4
01C20:  MOVWF  xC3
01C22:  MOVLW  18
01C24:  MOVWF  xC4
01C26:  CLRF   xC6
01C28:  MOVLW  9B
01C2A:  MOVWF  xC5
01C2C:  MOVLW  01
01C2E:  MOVWF  xC7
01C30:  MOVWF  xC8
01C32:  MOVLB  0
01C34:  CALL   0596
....................     
....................     
....................    glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
01C38:  MOVLW  05
01C3A:  MOVLB  4
01C3C:  MOVWF  xC3
01C3E:  MOVLW  2D
01C40:  MOVWF  xC4
01C42:  MOVLW  19
01C44:  MOVWF  xC5
01C46:  MOVLW  3C
01C48:  MOVWF  xC6
01C4A:  CLRF   xC7
01C4C:  MOVLW  01
01C4E:  MOVWF  xC8
01C50:  MOVLB  0
01C52:  RCALL  157A
....................    glcd_text57(9, 49, hora, 1, ON); 
01C54:  MOVLW  09
01C56:  MOVLB  4
01C58:  MOVWF  xC3
01C5A:  MOVLW  31
01C5C:  MOVWF  xC4
01C5E:  CLRF   xC6
01C60:  MOVLW  9E
01C62:  MOVWF  xC5
01C64:  MOVLW  01
01C66:  MOVWF  xC7
01C68:  MOVWF  xC8
01C6A:  MOVLB  0
01C6C:  CALL   0596
....................     
....................    glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
01C70:  MOVLW  23
01C72:  MOVLB  4
01C74:  MOVWF  xC3
01C76:  MOVLW  2D
01C78:  MOVWF  xC4
01C7A:  MOVLW  37
01C7C:  MOVWF  xC5
01C7E:  MOVLW  3C
01C80:  MOVWF  xC6
01C82:  CLRF   xC7
01C84:  MOVLW  01
01C86:  MOVWF  xC8
01C88:  MOVLB  0
01C8A:  RCALL  157A
....................    glcd_text57(39, 49, min, 1, ON); 
01C8C:  MOVLW  27
01C8E:  MOVLB  4
01C90:  MOVWF  xC3
01C92:  MOVLW  31
01C94:  MOVWF  xC4
01C96:  CLRF   xC6
01C98:  MOVLW  A1
01C9A:  MOVWF  xC5
01C9C:  MOVLW  01
01C9E:  MOVWF  xC7
01CA0:  MOVWF  xC8
01CA2:  MOVLB  0
01CA4:  CALL   0596
....................     
....................    glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
01CA8:  MOVLW  41
01CAA:  MOVLB  4
01CAC:  MOVWF  xC3
01CAE:  MOVLW  2D
01CB0:  MOVWF  xC4
01CB2:  MOVLW  55
01CB4:  MOVWF  xC5
01CB6:  MOVLW  3C
01CB8:  MOVWF  xC6
01CBA:  CLRF   xC7
01CBC:  MOVLW  01
01CBE:  MOVWF  xC8
01CC0:  MOVLB  0
01CC2:  RCALL  157A
....................    glcd_text57(69, 49, aop, 1, ON); 
01CC4:  MOVLW  45
01CC6:  MOVLB  4
01CC8:  MOVWF  xC3
01CCA:  MOVLW  31
01CCC:  MOVWF  xC4
01CCE:  CLRF   xC6
01CD0:  MOVLW  A4
01CD2:  MOVWF  xC5
01CD4:  MOVLW  01
01CD6:  MOVWF  xC7
01CD8:  MOVWF  xC8
01CDA:  MOVLB  0
01CDC:  CALL   0596
....................     
....................     
....................    glcd_update(); 
01CE0:  CALL   0350
....................     
....................  
....................     
....................    while (1) 
....................    { 
....................       readbuttons(); 
01CE4:  CALL   0E48
....................       if ((right==1)) 
01CE8:  DECFSZ 16,W
01CEA:  BRA    1CFA
....................       { 
....................          control+=1; 
01CEC:  MOVLW  01
01CEE:  ADDWF  07,F
....................          if (control>=7) 
01CF0:  MOVF   07,W
01CF2:  SUBLW  06
01CF4:  BC    1CFA
....................          { 
....................             control = 1; 
01CF6:  MOVLW  01
01CF8:  MOVWF  07
....................          } 
....................       } 
....................       if (left==1) 
01CFA:  DECFSZ 13,W
01CFC:  BRA    1D0A
....................       { 
....................          control-=1; 
01CFE:  MOVLW  01
01D00:  SUBWF  07,F
....................          if (control<=0) 
01D02:  MOVF   07,F
01D04:  BNZ   1D0A
....................          { 
....................             control = 6; 
01D06:  MOVLW  06
01D08:  MOVWF  07
....................          } 
....................       } 
....................       if (enter==1) 
01D0A:  DECFSZ 11,W
01D0C:  BRA    1D12
....................       { 
....................          control = 10; 
01D0E:  MOVLW  0A
01D10:  MOVWF  07
....................       } 
....................           
....................           
....................          switch (control) 
....................          { 
01D12:  MOVLW  01
01D14:  SUBWF  07,W
01D16:  ADDLW  F6
01D18:  BTFSC  FD8.0
01D1A:  GOTO   28BC
01D1E:  ADDLW  0A
01D20:  GOTO   28CE
....................             case 1:           // DIA 
....................             { 
....................                             
....................                glcd_rect(65, 45, 85, 60, YES, OFF);  
01D24:  MOVLW  41
01D26:  MOVLB  4
01D28:  MOVWF  xC3
01D2A:  MOVLW  2D
01D2C:  MOVWF  xC4
01D2E:  MOVLW  55
01D30:  MOVWF  xC5
01D32:  MOVLW  3C
01D34:  MOVWF  xC6
01D36:  MOVLW  01
01D38:  MOVWF  xC7
01D3A:  CLRF   xC8
01D3C:  MOVLB  0
01D3E:  RCALL  157A
....................                glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
01D40:  MOVLW  41
01D42:  MOVLB  4
01D44:  MOVWF  xC3
01D46:  MOVLW  2D
01D48:  MOVWF  xC4
01D4A:  MOVLW  55
01D4C:  MOVWF  xC5
01D4E:  MOVLW  3C
01D50:  MOVWF  xC6
01D52:  CLRF   xC7
01D54:  MOVLW  01
01D56:  MOVWF  xC8
01D58:  MOVLB  0
01D5A:  RCALL  157A
....................                glcd_text57(69, 49, aop, 1, ON); 
01D5C:  MOVLW  45
01D5E:  MOVLB  4
01D60:  MOVWF  xC3
01D62:  MOVLW  31
01D64:  MOVWF  xC4
01D66:  CLRF   xC6
01D68:  MOVLW  A4
01D6A:  MOVWF  xC5
01D6C:  MOVLW  01
01D6E:  MOVWF  xC7
01D70:  MOVWF  xC8
01D72:  MOVLB  0
01D74:  CALL   0596
....................                 
....................                glcd_rect(35, 20, 55, 35, YES, OFF);  
01D78:  MOVLW  23
01D7A:  MOVLB  4
01D7C:  MOVWF  xC3
01D7E:  MOVLW  14
01D80:  MOVWF  xC4
01D82:  MOVLW  37
01D84:  MOVWF  xC5
01D86:  MOVLW  23
01D88:  MOVWF  xC6
01D8A:  MOVLW  01
01D8C:  MOVWF  xC7
01D8E:  CLRF   xC8
01D90:  MOVLB  0
01D92:  CALL   157A
....................                glcd_rect(35, 20, 55, 35, NO, ON);         //Mes         
01D96:  MOVLW  23
01D98:  MOVLB  4
01D9A:  MOVWF  xC3
01D9C:  MOVLW  14
01D9E:  MOVWF  xC4
01DA0:  MOVLW  37
01DA2:  MOVWF  xC5
01DA4:  MOVLW  23
01DA6:  MOVWF  xC6
01DA8:  CLRF   xC7
01DAA:  MOVLW  01
01DAC:  MOVWF  xC8
01DAE:  MOVLB  0
01DB0:  CALL   157A
....................                glcd_text57(39, 24, mes, 1, ON); 
01DB4:  MOVLW  27
01DB6:  MOVLB  4
01DB8:  MOVWF  xC3
01DBA:  MOVLW  18
01DBC:  MOVWF  xC4
01DBE:  CLRF   xC6
01DC0:  MOVLW  98
01DC2:  MOVWF  xC5
01DC4:  MOVLW  01
01DC6:  MOVWF  xC7
01DC8:  MOVWF  xC8
01DCA:  MOVLB  0
01DCC:  CALL   0596
....................                 
....................                if ((up==0)&&(down==1)) 
01DD0:  MOVF   0D,F
01DD2:  BNZ   1E72
01DD4:  DECFSZ 0F,W
01DD6:  BRA    1E72
....................                {   
....................                   int8 auxdia; 
....................                   auxdia = atoi(dia); 
01DD8:  MOVLB  4
01DDA:  CLRF   xC4
01DDC:  MOVLW  95
01DDE:  MOVWF  xC3
01DE0:  MOVLB  0
01DE2:  RCALL  1696
01DE4:  MOVFF  01,4B9
....................                   auxdia -=1; 
01DE8:  MOVLW  01
01DEA:  MOVLB  4
01DEC:  SUBWF  xB9,F
....................                   if (auxdia==0) 
01DEE:  MOVF   xB9,F
01DF0:  BNZ   1E1C
....................                   { 
....................                      if (mes=="2") 
01DF2:  MOVLW  00
01DF4:  MOVWF  02
01DF6:  MOVLW  02
01DF8:  MOVWF  01
01DFA:  MOVLW  B4
01DFC:  MOVWF  00
01DFE:  CLRF   03
01E00:  MOVF   00,W
01E02:  SUBLW  98
01E04:  BNZ   1E18
01E06:  MOVF   01,F
01E08:  BNZ   1E18
01E0A:  MOVF   02,F
01E0C:  BNZ   1E18
01E0E:  MOVF   03,F
01E10:  BNZ   1E18
....................                      { 
....................                         auxdia = 28; 
01E12:  MOVLW  1C
01E14:  MOVWF  xB9
....................                      } 
....................                      else 
01E16:  BRA    1E1C
....................                      { 
....................                         auxdia = 31; 
01E18:  MOVLW  1F
01E1A:  MOVWF  xB9
....................                      } 
....................                   } 
....................                   itoa(auxdia,10,dia); 
01E1C:  CLRF   xC6
01E1E:  CLRF   xC5
01E20:  CLRF   xC4
01E22:  MOVFF  4B9,4C3
01E26:  MOVLW  0A
01E28:  MOVWF  xC7
01E2A:  CLRF   xC9
01E2C:  MOVLW  95
01E2E:  MOVWF  xC8
01E30:  MOVLB  0
01E32:  RCALL  196C
....................                   glcd_rect(5, 20, 25, 35, YES, ON);         //Dia 
01E34:  MOVLW  05
01E36:  MOVLB  4
01E38:  MOVWF  xC3
01E3A:  MOVLW  14
01E3C:  MOVWF  xC4
01E3E:  MOVLW  19
01E40:  MOVWF  xC5
01E42:  MOVLW  23
01E44:  MOVWF  xC6
01E46:  MOVLW  01
01E48:  MOVWF  xC7
01E4A:  MOVWF  xC8
01E4C:  MOVLB  0
01E4E:  CALL   157A
....................                    
....................                   glcd_text57(9, 24, dia, 1, OFF); 
01E52:  MOVLW  09
01E54:  MOVLB  4
01E56:  MOVWF  xC3
01E58:  MOVLW  18
01E5A:  MOVWF  xC4
01E5C:  CLRF   xC6
01E5E:  MOVLW  95
01E60:  MOVWF  xC5
01E62:  MOVLW  01
01E64:  MOVWF  xC7
01E66:  CLRF   xC8
01E68:  MOVLB  0
01E6A:  CALL   0596
....................                   glcd_update(); 
01E6E:  CALL   0350
....................                } 
....................                if ((up==1)&&(down==0)) 
01E72:  DECFSZ 0D,W
01E74:  BRA    1EF0
01E76:  MOVF   0F,F
01E78:  BNZ   1EF0
....................                { 
....................                   int8 auxdia; 
....................                   auxdia = atoi(dia); 
01E7A:  MOVLB  4
01E7C:  CLRF   xC4
01E7E:  MOVLW  95
01E80:  MOVWF  xC3
01E82:  MOVLB  0
01E84:  RCALL  1696
01E86:  MOVFF  01,4BA
....................                   auxdia +=1; 
01E8A:  MOVLW  01
01E8C:  MOVLB  4
01E8E:  ADDWF  xBA,F
....................                   if (auxdia==32) 
01E90:  MOVF   xBA,W
01E92:  SUBLW  20
01E94:  BNZ   1E9A
....................                   { 
....................                      auxdia = 1; 
01E96:  MOVLW  01
01E98:  MOVWF  xBA
....................                   } 
....................                   itoa(auxdia,10,dia); 
01E9A:  CLRF   xC6
01E9C:  CLRF   xC5
01E9E:  CLRF   xC4
01EA0:  MOVFF  4BA,4C3
01EA4:  MOVLW  0A
01EA6:  MOVWF  xC7
01EA8:  CLRF   xC9
01EAA:  MOVLW  95
01EAC:  MOVWF  xC8
01EAE:  MOVLB  0
01EB0:  RCALL  196C
....................                   glcd_rect(5, 20, 25, 35, YES, ON);         //Dia 
01EB2:  MOVLW  05
01EB4:  MOVLB  4
01EB6:  MOVWF  xC3
01EB8:  MOVLW  14
01EBA:  MOVWF  xC4
01EBC:  MOVLW  19
01EBE:  MOVWF  xC5
01EC0:  MOVLW  23
01EC2:  MOVWF  xC6
01EC4:  MOVLW  01
01EC6:  MOVWF  xC7
01EC8:  MOVWF  xC8
01ECA:  MOVLB  0
01ECC:  CALL   157A
....................                    
....................                   glcd_text57(9, 24, dia, 1, OFF); 
01ED0:  MOVLW  09
01ED2:  MOVLB  4
01ED4:  MOVWF  xC3
01ED6:  MOVLW  18
01ED8:  MOVWF  xC4
01EDA:  CLRF   xC6
01EDC:  MOVLW  95
01EDE:  MOVWF  xC5
01EE0:  MOVLW  01
01EE2:  MOVWF  xC7
01EE4:  CLRF   xC8
01EE6:  MOVLB  0
01EE8:  CALL   0596
....................                   glcd_update(); 
01EEC:  CALL   0350
....................           
....................                } 
....................                break; 
01EF0:  GOTO   28BC
....................             } 
....................             case 2:           // MES 
....................             { 
....................                glcd_rect(5, 20, 25, 35, YES, OFF);  
01EF4:  MOVLW  05
01EF6:  MOVLB  4
01EF8:  MOVWF  xC3
01EFA:  MOVLW  14
01EFC:  MOVWF  xC4
01EFE:  MOVLW  19
01F00:  MOVWF  xC5
01F02:  MOVLW  23
01F04:  MOVWF  xC6
01F06:  MOVLW  01
01F08:  MOVWF  xC7
01F0A:  CLRF   xC8
01F0C:  MOVLB  0
01F0E:  CALL   157A
....................                glcd_rect(5, 20, 25, 35, NO, ON);         //Dia 
01F12:  MOVLW  05
01F14:  MOVLB  4
01F16:  MOVWF  xC3
01F18:  MOVLW  14
01F1A:  MOVWF  xC4
01F1C:  MOVLW  19
01F1E:  MOVWF  xC5
01F20:  MOVLW  23
01F22:  MOVWF  xC6
01F24:  CLRF   xC7
01F26:  MOVLW  01
01F28:  MOVWF  xC8
01F2A:  MOVLB  0
01F2C:  CALL   157A
....................                glcd_text57(9, 24, dia, 1, ON); 
01F30:  MOVLW  09
01F32:  MOVLB  4
01F34:  MOVWF  xC3
01F36:  MOVLW  18
01F38:  MOVWF  xC4
01F3A:  CLRF   xC6
01F3C:  MOVLW  95
01F3E:  MOVWF  xC5
01F40:  MOVLW  01
01F42:  MOVWF  xC7
01F44:  MOVWF  xC8
01F46:  MOVLB  0
01F48:  CALL   0596
....................                 
....................                glcd_rect(65, 20, 85, 35, YES, OFF);  
01F4C:  MOVLW  41
01F4E:  MOVLB  4
01F50:  MOVWF  xC3
01F52:  MOVLW  14
01F54:  MOVWF  xC4
01F56:  MOVLW  55
01F58:  MOVWF  xC5
01F5A:  MOVLW  23
01F5C:  MOVWF  xC6
01F5E:  MOVLW  01
01F60:  MOVWF  xC7
01F62:  CLRF   xC8
01F64:  MOVLB  0
01F66:  CALL   157A
....................                glcd_rect(65, 20, 85, 35, NO, ON);         //Ao 
01F6A:  MOVLW  41
01F6C:  MOVLB  4
01F6E:  MOVWF  xC3
01F70:  MOVLW  14
01F72:  MOVWF  xC4
01F74:  MOVLW  55
01F76:  MOVWF  xC5
01F78:  MOVLW  23
01F7A:  MOVWF  xC6
01F7C:  CLRF   xC7
01F7E:  MOVLW  01
01F80:  MOVWF  xC8
01F82:  MOVLB  0
01F84:  CALL   157A
....................                glcd_text57(69, 24, ao, 1, ON); 
01F88:  MOVLW  45
01F8A:  MOVLB  4
01F8C:  MOVWF  xC3
01F8E:  MOVLW  18
01F90:  MOVWF  xC4
01F92:  CLRF   xC6
01F94:  MOVLW  9B
01F96:  MOVWF  xC5
01F98:  MOVLW  01
01F9A:  MOVWF  xC7
01F9C:  MOVWF  xC8
01F9E:  MOVLB  0
01FA0:  CALL   0596
....................                 
....................                if ((up==0)&&(down==1)) 
01FA4:  MOVF   0D,F
01FA6:  BNZ   2022
01FA8:  DECFSZ 0F,W
01FAA:  BRA    2022
....................                {   
....................                   int8 auxmes; 
....................                   auxmes = atoi(mes); 
01FAC:  MOVLB  4
01FAE:  CLRF   xC4
01FB0:  MOVLW  98
01FB2:  MOVWF  xC3
01FB4:  MOVLB  0
01FB6:  CALL   1696
01FBA:  MOVFF  01,4BB
....................                   auxmes -=1; 
01FBE:  MOVLW  01
01FC0:  MOVLB  4
01FC2:  SUBWF  xBB,F
....................                   if (auxmes==0) 
01FC4:  MOVF   xBB,F
01FC6:  BNZ   1FCC
....................                   { 
....................                      auxmes = 12; 
01FC8:  MOVLW  0C
01FCA:  MOVWF  xBB
....................                   } 
....................                   itoa(auxmes,10,mes); 
01FCC:  CLRF   xC6
01FCE:  CLRF   xC5
01FD0:  CLRF   xC4
01FD2:  MOVFF  4BB,4C3
01FD6:  MOVLW  0A
01FD8:  MOVWF  xC7
01FDA:  CLRF   xC9
01FDC:  MOVLW  98
01FDE:  MOVWF  xC8
01FE0:  MOVLB  0
01FE2:  RCALL  196C
....................                   glcd_rect(35, 20, 55, 35, YES, ON);         //Mes 
01FE4:  MOVLW  23
01FE6:  MOVLB  4
01FE8:  MOVWF  xC3
01FEA:  MOVLW  14
01FEC:  MOVWF  xC4
01FEE:  MOVLW  37
01FF0:  MOVWF  xC5
01FF2:  MOVLW  23
01FF4:  MOVWF  xC6
01FF6:  MOVLW  01
01FF8:  MOVWF  xC7
01FFA:  MOVWF  xC8
01FFC:  MOVLB  0
01FFE:  CALL   157A
....................                    
....................                   glcd_text57(39, 24, mes, 1, OFF); 
02002:  MOVLW  27
02004:  MOVLB  4
02006:  MOVWF  xC3
02008:  MOVLW  18
0200A:  MOVWF  xC4
0200C:  CLRF   xC6
0200E:  MOVLW  98
02010:  MOVWF  xC5
02012:  MOVLW  01
02014:  MOVWF  xC7
02016:  CLRF   xC8
02018:  MOVLB  0
0201A:  CALL   0596
....................                   glcd_update(); 
0201E:  CALL   0350
....................                } 
....................                if ((up==1)&&(down==0)) 
02022:  DECFSZ 0D,W
02024:  BRA    20A2
02026:  MOVF   0F,F
02028:  BNZ   20A2
....................                { 
....................                   int8 auxmes; 
....................                   auxmes = atoi(mes); 
0202A:  MOVLB  4
0202C:  CLRF   xC4
0202E:  MOVLW  98
02030:  MOVWF  xC3
02032:  MOVLB  0
02034:  CALL   1696
02038:  MOVFF  01,4BC
....................                   auxmes +=1; 
0203C:  MOVLW  01
0203E:  MOVLB  4
02040:  ADDWF  xBC,F
....................                   if (auxmes==13) 
02042:  MOVF   xBC,W
02044:  SUBLW  0D
02046:  BNZ   204C
....................                   { 
....................                      auxmes = 1; 
02048:  MOVLW  01
0204A:  MOVWF  xBC
....................                   } 
....................                   itoa(auxmes,10,mes); 
0204C:  CLRF   xC6
0204E:  CLRF   xC5
02050:  CLRF   xC4
02052:  MOVFF  4BC,4C3
02056:  MOVLW  0A
02058:  MOVWF  xC7
0205A:  CLRF   xC9
0205C:  MOVLW  98
0205E:  MOVWF  xC8
02060:  MOVLB  0
02062:  RCALL  196C
....................                   glcd_rect(35, 20, 55, 35, YES, ON);         //Mes 
02064:  MOVLW  23
02066:  MOVLB  4
02068:  MOVWF  xC3
0206A:  MOVLW  14
0206C:  MOVWF  xC4
0206E:  MOVLW  37
02070:  MOVWF  xC5
02072:  MOVLW  23
02074:  MOVWF  xC6
02076:  MOVLW  01
02078:  MOVWF  xC7
0207A:  MOVWF  xC8
0207C:  MOVLB  0
0207E:  CALL   157A
....................                    
....................                   glcd_text57(39, 24, mes, 1, OFF); 
02082:  MOVLW  27
02084:  MOVLB  4
02086:  MOVWF  xC3
02088:  MOVLW  18
0208A:  MOVWF  xC4
0208C:  CLRF   xC6
0208E:  MOVLW  98
02090:  MOVWF  xC5
02092:  MOVLW  01
02094:  MOVWF  xC7
02096:  CLRF   xC8
02098:  MOVLB  0
0209A:  CALL   0596
....................                   glcd_update(); 
0209E:  CALL   0350
....................           
....................                } 
....................                break; 
020A2:  GOTO   28BC
....................             } 
....................             case 3:           // AO 
....................             { 
....................                 
....................                glcd_rect(35, 20, 55, 35, YES, OFF);  
020A6:  MOVLW  23
020A8:  MOVLB  4
020AA:  MOVWF  xC3
020AC:  MOVLW  14
020AE:  MOVWF  xC4
020B0:  MOVLW  37
020B2:  MOVWF  xC5
020B4:  MOVLW  23
020B6:  MOVWF  xC6
020B8:  MOVLW  01
020BA:  MOVWF  xC7
020BC:  CLRF   xC8
020BE:  MOVLB  0
020C0:  CALL   157A
....................                glcd_rect(35, 20, 55, 35, NO, ON);         //Mes          
020C4:  MOVLW  23
020C6:  MOVLB  4
020C8:  MOVWF  xC3
020CA:  MOVLW  14
020CC:  MOVWF  xC4
020CE:  MOVLW  37
020D0:  MOVWF  xC5
020D2:  MOVLW  23
020D4:  MOVWF  xC6
020D6:  CLRF   xC7
020D8:  MOVLW  01
020DA:  MOVWF  xC8
020DC:  MOVLB  0
020DE:  CALL   157A
....................                glcd_text57(39, 24, mes, 1, ON); 
020E2:  MOVLW  27
020E4:  MOVLB  4
020E6:  MOVWF  xC3
020E8:  MOVLW  18
020EA:  MOVWF  xC4
020EC:  CLRF   xC6
020EE:  MOVLW  98
020F0:  MOVWF  xC5
020F2:  MOVLW  01
020F4:  MOVWF  xC7
020F6:  MOVWF  xC8
020F8:  MOVLB  0
020FA:  CALL   0596
....................                 
....................                glcd_rect(5, 45, 25, 60, YES, OFF);  
020FE:  MOVLW  05
02100:  MOVLB  4
02102:  MOVWF  xC3
02104:  MOVLW  2D
02106:  MOVWF  xC4
02108:  MOVLW  19
0210A:  MOVWF  xC5
0210C:  MOVLW  3C
0210E:  MOVWF  xC6
02110:  MOVLW  01
02112:  MOVWF  xC7
02114:  CLRF   xC8
02116:  MOVLB  0
02118:  CALL   157A
....................                glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
0211C:  MOVLW  05
0211E:  MOVLB  4
02120:  MOVWF  xC3
02122:  MOVLW  2D
02124:  MOVWF  xC4
02126:  MOVLW  19
02128:  MOVWF  xC5
0212A:  MOVLW  3C
0212C:  MOVWF  xC6
0212E:  CLRF   xC7
02130:  MOVLW  01
02132:  MOVWF  xC8
02134:  MOVLB  0
02136:  CALL   157A
....................                glcd_text57(9, 49, hora, 1, ON); 
0213A:  MOVLW  09
0213C:  MOVLB  4
0213E:  MOVWF  xC3
02140:  MOVLW  31
02142:  MOVWF  xC4
02144:  CLRF   xC6
02146:  MOVLW  9E
02148:  MOVWF  xC5
0214A:  MOVLW  01
0214C:  MOVWF  xC7
0214E:  MOVWF  xC8
02150:  MOVLB  0
02152:  CALL   0596
....................                 
....................                if ((up==0)&&(down==1)) 
02156:  MOVF   0D,F
02158:  BNZ   21D6
0215A:  DECFSZ 0F,W
0215C:  BRA    21D6
....................                {   
....................                   int8 auxao; 
....................                   auxao = atoi(ao); 
0215E:  MOVLB  4
02160:  CLRF   xC4
02162:  MOVLW  9B
02164:  MOVWF  xC3
02166:  MOVLB  0
02168:  CALL   1696
0216C:  MOVFF  01,4BD
....................                   auxao -=1; 
02170:  MOVLW  01
02172:  MOVLB  4
02174:  SUBWF  xBD,F
....................                   if (auxao==0) 
02176:  MOVF   xBD,F
02178:  BNZ   217E
....................                   { 
....................                      auxao = 99; 
0217A:  MOVLW  63
0217C:  MOVWF  xBD
....................                   } 
....................                   itoa(auxao,10,ao); 
0217E:  CLRF   xC6
02180:  CLRF   xC5
02182:  CLRF   xC4
02184:  MOVFF  4BD,4C3
02188:  MOVLW  0A
0218A:  MOVWF  xC7
0218C:  CLRF   xC9
0218E:  MOVLW  9B
02190:  MOVWF  xC8
02192:  MOVLB  0
02194:  CALL   196C
....................                   glcd_rect(65, 20, 85, 35, YES, ON);         //Ao 
02198:  MOVLW  41
0219A:  MOVLB  4
0219C:  MOVWF  xC3
0219E:  MOVLW  14
021A0:  MOVWF  xC4
021A2:  MOVLW  55
021A4:  MOVWF  xC5
021A6:  MOVLW  23
021A8:  MOVWF  xC6
021AA:  MOVLW  01
021AC:  MOVWF  xC7
021AE:  MOVWF  xC8
021B0:  MOVLB  0
021B2:  CALL   157A
....................                    
....................                   glcd_text57(69, 24, ao, 1, OFF); 
021B6:  MOVLW  45
021B8:  MOVLB  4
021BA:  MOVWF  xC3
021BC:  MOVLW  18
021BE:  MOVWF  xC4
021C0:  CLRF   xC6
021C2:  MOVLW  9B
021C4:  MOVWF  xC5
021C6:  MOVLW  01
021C8:  MOVWF  xC7
021CA:  CLRF   xC8
021CC:  MOVLB  0
021CE:  CALL   0596
....................                   glcd_update(); 
021D2:  CALL   0350
....................                } 
....................                if ((up==1)&&(down==0)) 
021D6:  DECFSZ 0D,W
021D8:  BRA    2256
021DA:  MOVF   0F,F
021DC:  BNZ   2256
....................                { 
....................                   int8 auxao; 
....................                   auxao = atoi(ao); 
021DE:  MOVLB  4
021E0:  CLRF   xC4
021E2:  MOVLW  9B
021E4:  MOVWF  xC3
021E6:  MOVLB  0
021E8:  CALL   1696
021EC:  MOVFF  01,4BE
....................                   auxao +=1; 
021F0:  MOVLW  01
021F2:  MOVLB  4
021F4:  ADDWF  xBE,F
....................                   if (auxao==99) 
021F6:  MOVF   xBE,W
021F8:  SUBLW  63
021FA:  BNZ   21FE
....................                   { 
....................                      auxao = 0; 
021FC:  CLRF   xBE
....................                   } 
....................                   itoa(auxao,10,ao); 
021FE:  CLRF   xC6
02200:  CLRF   xC5
02202:  CLRF   xC4
02204:  MOVFF  4BE,4C3
02208:  MOVLW  0A
0220A:  MOVWF  xC7
0220C:  CLRF   xC9
0220E:  MOVLW  9B
02210:  MOVWF  xC8
02212:  MOVLB  0
02214:  CALL   196C
....................                   glcd_rect(65, 20, 85, 35, YES, ON);         //Ao 
02218:  MOVLW  41
0221A:  MOVLB  4
0221C:  MOVWF  xC3
0221E:  MOVLW  14
02220:  MOVWF  xC4
02222:  MOVLW  55
02224:  MOVWF  xC5
02226:  MOVLW  23
02228:  MOVWF  xC6
0222A:  MOVLW  01
0222C:  MOVWF  xC7
0222E:  MOVWF  xC8
02230:  MOVLB  0
02232:  CALL   157A
....................                    
....................                   glcd_text57(69, 24, ao, 1, OFF); 
02236:  MOVLW  45
02238:  MOVLB  4
0223A:  MOVWF  xC3
0223C:  MOVLW  18
0223E:  MOVWF  xC4
02240:  CLRF   xC6
02242:  MOVLW  9B
02244:  MOVWF  xC5
02246:  MOVLW  01
02248:  MOVWF  xC7
0224A:  CLRF   xC8
0224C:  MOVLB  0
0224E:  CALL   0596
....................                   glcd_update(); 
02252:  CALL   0350
....................           
....................                } 
....................                break; 
02256:  BRA    28BC
....................             } 
....................             case 4:           // HORA 
....................             { 
....................                 
....................                glcd_rect(65, 20, 85, 35, YES, OFF);  
02258:  MOVLW  41
0225A:  MOVLB  4
0225C:  MOVWF  xC3
0225E:  MOVLW  14
02260:  MOVWF  xC4
02262:  MOVLW  55
02264:  MOVWF  xC5
02266:  MOVLW  23
02268:  MOVWF  xC6
0226A:  MOVLW  01
0226C:  MOVWF  xC7
0226E:  CLRF   xC8
02270:  MOVLB  0
02272:  CALL   157A
....................                glcd_rect(65, 20, 85, 35, NO, ON);         //Ao 
02276:  MOVLW  41
02278:  MOVLB  4
0227A:  MOVWF  xC3
0227C:  MOVLW  14
0227E:  MOVWF  xC4
02280:  MOVLW  55
02282:  MOVWF  xC5
02284:  MOVLW  23
02286:  MOVWF  xC6
02288:  CLRF   xC7
0228A:  MOVLW  01
0228C:  MOVWF  xC8
0228E:  MOVLB  0
02290:  CALL   157A
....................                glcd_text57(69, 24, ao, 1, ON); 
02294:  MOVLW  45
02296:  MOVLB  4
02298:  MOVWF  xC3
0229A:  MOVLW  18
0229C:  MOVWF  xC4
0229E:  CLRF   xC6
022A0:  MOVLW  9B
022A2:  MOVWF  xC5
022A4:  MOVLW  01
022A6:  MOVWF  xC7
022A8:  MOVWF  xC8
022AA:  MOVLB  0
022AC:  CALL   0596
....................                 
....................                glcd_rect(35, 45, 55, 60, YES, OFF);  
022B0:  MOVLW  23
022B2:  MOVLB  4
022B4:  MOVWF  xC3
022B6:  MOVLW  2D
022B8:  MOVWF  xC4
022BA:  MOVLW  37
022BC:  MOVWF  xC5
022BE:  MOVLW  3C
022C0:  MOVWF  xC6
022C2:  MOVLW  01
022C4:  MOVWF  xC7
022C6:  CLRF   xC8
022C8:  MOVLB  0
022CA:  CALL   157A
....................                glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
022CE:  MOVLW  23
022D0:  MOVLB  4
022D2:  MOVWF  xC3
022D4:  MOVLW  2D
022D6:  MOVWF  xC4
022D8:  MOVLW  37
022DA:  MOVWF  xC5
022DC:  MOVLW  3C
022DE:  MOVWF  xC6
022E0:  CLRF   xC7
022E2:  MOVLW  01
022E4:  MOVWF  xC8
022E6:  MOVLB  0
022E8:  CALL   157A
....................                glcd_text57(39, 49, min, 1, ON); 
022EC:  MOVLW  27
022EE:  MOVLB  4
022F0:  MOVWF  xC3
022F2:  MOVLW  31
022F4:  MOVWF  xC4
022F6:  CLRF   xC6
022F8:  MOVLW  A1
022FA:  MOVWF  xC5
022FC:  MOVLW  01
022FE:  MOVWF  xC7
02300:  MOVWF  xC8
02302:  MOVLB  0
02304:  CALL   0596
....................                 
....................                 
....................                if ((up==0)&&(down==1)) 
02308:  MOVF   0D,F
0230A:  BNZ   2388
0230C:  DECFSZ 0F,W
0230E:  BRA    2388
....................                {   
....................                   int8 auxhora; 
....................                   auxhora = atoi(hora); 
02310:  MOVLB  4
02312:  CLRF   xC4
02314:  MOVLW  9E
02316:  MOVWF  xC3
02318:  MOVLB  0
0231A:  CALL   1696
0231E:  MOVFF  01,4BF
....................                   auxhora -=1; 
02322:  MOVLW  01
02324:  MOVLB  4
02326:  SUBWF  xBF,F
....................                   if (auxhora<=0) 
02328:  MOVF   xBF,F
0232A:  BNZ   2330
....................                   { 
....................                      auxhora = 12; 
0232C:  MOVLW  0C
0232E:  MOVWF  xBF
....................                   } 
....................                   itoa(auxhora,10,hora); 
02330:  CLRF   xC6
02332:  CLRF   xC5
02334:  CLRF   xC4
02336:  MOVFF  4BF,4C3
0233A:  MOVLW  0A
0233C:  MOVWF  xC7
0233E:  CLRF   xC9
02340:  MOVLW  9E
02342:  MOVWF  xC8
02344:  MOVLB  0
02346:  CALL   196C
....................                    
....................                   glcd_rect(5, 45, 25, 60, YES, ON);         //Hora 
0234A:  MOVLW  05
0234C:  MOVLB  4
0234E:  MOVWF  xC3
02350:  MOVLW  2D
02352:  MOVWF  xC4
02354:  MOVLW  19
02356:  MOVWF  xC5
02358:  MOVLW  3C
0235A:  MOVWF  xC6
0235C:  MOVLW  01
0235E:  MOVWF  xC7
02360:  MOVWF  xC8
02362:  MOVLB  0
02364:  CALL   157A
....................                    
....................                   glcd_text57(9, 49, hora, 1, OFF); 
02368:  MOVLW  09
0236A:  MOVLB  4
0236C:  MOVWF  xC3
0236E:  MOVLW  31
02370:  MOVWF  xC4
02372:  CLRF   xC6
02374:  MOVLW  9E
02376:  MOVWF  xC5
02378:  MOVLW  01
0237A:  MOVWF  xC7
0237C:  CLRF   xC8
0237E:  MOVLB  0
02380:  CALL   0596
....................                   glcd_update(); 
02384:  CALL   0350
....................                } 
....................                if ((up==1)&&(down==0)) 
02388:  DECFSZ 0D,W
0238A:  BRA    240A
0238C:  MOVF   0F,F
0238E:  BNZ   240A
....................                { 
....................                   int8 auxhora; 
....................                   auxhora = atoi(hora); 
02390:  MOVLB  4
02392:  CLRF   xC4
02394:  MOVLW  9E
02396:  MOVWF  xC3
02398:  MOVLB  0
0239A:  CALL   1696
0239E:  MOVFF  01,4C0
....................                   auxhora +=1; 
023A2:  MOVLW  01
023A4:  MOVLB  4
023A6:  ADDWF  xC0,F
....................                   if (auxhora>=12) 
023A8:  MOVF   xC0,W
023AA:  SUBLW  0B
023AC:  BC    23B2
....................                   { 
....................                      auxhora = 1; 
023AE:  MOVLW  01
023B0:  MOVWF  xC0
....................                   } 
....................                   itoa(auxhora,10,hora); 
023B2:  CLRF   xC6
023B4:  CLRF   xC5
023B6:  CLRF   xC4
023B8:  MOVFF  4C0,4C3
023BC:  MOVLW  0A
023BE:  MOVWF  xC7
023C0:  CLRF   xC9
023C2:  MOVLW  9E
023C4:  MOVWF  xC8
023C6:  MOVLB  0
023C8:  CALL   196C
....................                   glcd_rect(5, 45, 25, 60, YES, ON);         //Hora 
023CC:  MOVLW  05
023CE:  MOVLB  4
023D0:  MOVWF  xC3
023D2:  MOVLW  2D
023D4:  MOVWF  xC4
023D6:  MOVLW  19
023D8:  MOVWF  xC5
023DA:  MOVLW  3C
023DC:  MOVWF  xC6
023DE:  MOVLW  01
023E0:  MOVWF  xC7
023E2:  MOVWF  xC8
023E4:  MOVLB  0
023E6:  CALL   157A
....................                    
....................                   glcd_text57(9, 49, hora, 1, OFF); 
023EA:  MOVLW  09
023EC:  MOVLB  4
023EE:  MOVWF  xC3
023F0:  MOVLW  31
023F2:  MOVWF  xC4
023F4:  CLRF   xC6
023F6:  MOVLW  9E
023F8:  MOVWF  xC5
023FA:  MOVLW  01
023FC:  MOVWF  xC7
023FE:  CLRF   xC8
02400:  MOVLB  0
02402:  CALL   0596
....................                   glcd_update(); 
02406:  CALL   0350
....................           
....................                }   
....................                 
....................                break; 
0240A:  BRA    28BC
....................             } 
....................             case 5:           // MINUTOS 
....................             { 
....................                glcd_rect(5, 45, 25, 60, YES, OFF);  
0240C:  MOVLW  05
0240E:  MOVLB  4
02410:  MOVWF  xC3
02412:  MOVLW  2D
02414:  MOVWF  xC4
02416:  MOVLW  19
02418:  MOVWF  xC5
0241A:  MOVLW  3C
0241C:  MOVWF  xC6
0241E:  MOVLW  01
02420:  MOVWF  xC7
02422:  CLRF   xC8
02424:  MOVLB  0
02426:  CALL   157A
....................                glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
0242A:  MOVLW  05
0242C:  MOVLB  4
0242E:  MOVWF  xC3
02430:  MOVLW  2D
02432:  MOVWF  xC4
02434:  MOVLW  19
02436:  MOVWF  xC5
02438:  MOVLW  3C
0243A:  MOVWF  xC6
0243C:  CLRF   xC7
0243E:  MOVLW  01
02440:  MOVWF  xC8
02442:  MOVLB  0
02444:  CALL   157A
....................                glcd_text57(9, 49, hora, 1, ON); 
02448:  MOVLW  09
0244A:  MOVLB  4
0244C:  MOVWF  xC3
0244E:  MOVLW  31
02450:  MOVWF  xC4
02452:  CLRF   xC6
02454:  MOVLW  9E
02456:  MOVWF  xC5
02458:  MOVLW  01
0245A:  MOVWF  xC7
0245C:  MOVWF  xC8
0245E:  MOVLB  0
02460:  CALL   0596
....................                 
....................                glcd_rect(65, 45, 85, 60, YES, OFF);  
02464:  MOVLW  41
02466:  MOVLB  4
02468:  MOVWF  xC3
0246A:  MOVLW  2D
0246C:  MOVWF  xC4
0246E:  MOVLW  55
02470:  MOVWF  xC5
02472:  MOVLW  3C
02474:  MOVWF  xC6
02476:  MOVLW  01
02478:  MOVWF  xC7
0247A:  CLRF   xC8
0247C:  MOVLB  0
0247E:  CALL   157A
....................                glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
02482:  MOVLW  41
02484:  MOVLB  4
02486:  MOVWF  xC3
02488:  MOVLW  2D
0248A:  MOVWF  xC4
0248C:  MOVLW  55
0248E:  MOVWF  xC5
02490:  MOVLW  3C
02492:  MOVWF  xC6
02494:  CLRF   xC7
02496:  MOVLW  01
02498:  MOVWF  xC8
0249A:  MOVLB  0
0249C:  CALL   157A
....................                glcd_text57(69, 49, aop, 1, ON); 
024A0:  MOVLW  45
024A2:  MOVLB  4
024A4:  MOVWF  xC3
024A6:  MOVLW  31
024A8:  MOVWF  xC4
024AA:  CLRF   xC6
024AC:  MOVLW  A4
024AE:  MOVWF  xC5
024B0:  MOVLW  01
024B2:  MOVWF  xC7
024B4:  MOVWF  xC8
024B6:  MOVLB  0
024B8:  CALL   0596
....................                                      
....................                 
....................     
....................                if ((up==0)&&(down==1)) 
024BC:  MOVF   0D,F
024BE:  BNZ   2534
024C0:  DECFSZ 0F,W
024C2:  BRA    2534
....................                {   
....................                   int8 auxmin; 
....................                   auxmin = atoi(min); 
024C4:  MOVLB  4
024C6:  CLRF   xC4
024C8:  MOVLW  A1
024CA:  MOVWF  xC3
024CC:  MOVLB  0
024CE:  CALL   1696
024D2:  MOVFF  01,4C1
....................                   auxmin -=1; 
024D6:  MOVLW  01
024D8:  MOVLB  4
024DA:  SUBWF  xC1,F
....................                   if (auxmin<=-1) 
....................                   { 
....................                      auxmin = 59; 
....................                   } 
....................                   itoa(auxmin,10,min); 
024DC:  CLRF   xC6
024DE:  CLRF   xC5
024E0:  CLRF   xC4
024E2:  MOVFF  4C1,4C3
024E6:  MOVLW  0A
024E8:  MOVWF  xC7
024EA:  CLRF   xC9
024EC:  MOVLW  A1
024EE:  MOVWF  xC8
024F0:  MOVLB  0
024F2:  CALL   196C
....................                    
....................                   glcd_rect(35, 45, 55, 60, YES, ON);        //Minuto 
024F6:  MOVLW  23
024F8:  MOVLB  4
024FA:  MOVWF  xC3
024FC:  MOVLW  2D
024FE:  MOVWF  xC4
02500:  MOVLW  37
02502:  MOVWF  xC5
02504:  MOVLW  3C
02506:  MOVWF  xC6
02508:  MOVLW  01
0250A:  MOVWF  xC7
0250C:  MOVWF  xC8
0250E:  MOVLB  0
02510:  CALL   157A
....................                   glcd_text57(39, 49, min, 1, OFF); 
02514:  MOVLW  27
02516:  MOVLB  4
02518:  MOVWF  xC3
0251A:  MOVLW  31
0251C:  MOVWF  xC4
0251E:  CLRF   xC6
02520:  MOVLW  A1
02522:  MOVWF  xC5
02524:  MOVLW  01
02526:  MOVWF  xC7
02528:  CLRF   xC8
0252A:  MOVLB  0
0252C:  CALL   0596
....................                   glcd_update(); 
02530:  CALL   0350
....................                } 
....................                if ((up==1)&&(down==0)) 
02534:  DECFSZ 0D,W
02536:  BRA    25B4
02538:  MOVF   0F,F
0253A:  BNZ   25B4
....................                { 
....................                   int8 auxmin; 
....................                   auxmin = atoi(min); 
0253C:  MOVLB  4
0253E:  CLRF   xC4
02540:  MOVLW  A1
02542:  MOVWF  xC3
02544:  MOVLB  0
02546:  CALL   1696
0254A:  MOVFF  01,4C2
....................                   auxmin +=1; 
0254E:  MOVLW  01
02550:  MOVLB  4
02552:  ADDWF  xC2,F
....................                   if (auxmin>=60) 
02554:  MOVF   xC2,W
02556:  SUBLW  3B
02558:  BC    255C
....................                   { 
....................                      auxmin = 0; 
0255A:  CLRF   xC2
....................                   } 
....................                   itoa(auxmin,10,min); 
0255C:  CLRF   xC6
0255E:  CLRF   xC5
02560:  CLRF   xC4
02562:  MOVFF  4C2,4C3
02566:  MOVLW  0A
02568:  MOVWF  xC7
0256A:  CLRF   xC9
0256C:  MOVLW  A1
0256E:  MOVWF  xC8
02570:  MOVLB  0
02572:  CALL   196C
....................                    
....................                   glcd_rect(35, 45, 55, 60, YES, ON);        //Minuto 
02576:  MOVLW  23
02578:  MOVLB  4
0257A:  MOVWF  xC3
0257C:  MOVLW  2D
0257E:  MOVWF  xC4
02580:  MOVLW  37
02582:  MOVWF  xC5
02584:  MOVLW  3C
02586:  MOVWF  xC6
02588:  MOVLW  01
0258A:  MOVWF  xC7
0258C:  MOVWF  xC8
0258E:  MOVLB  0
02590:  CALL   157A
....................                   glcd_text57(39, 49, min, 1, OFF); 
02594:  MOVLW  27
02596:  MOVLB  4
02598:  MOVWF  xC3
0259A:  MOVLW  31
0259C:  MOVWF  xC4
0259E:  CLRF   xC6
025A0:  MOVLW  A1
025A2:  MOVWF  xC5
025A4:  MOVLW  01
025A6:  MOVWF  xC7
025A8:  CLRF   xC8
025AA:  MOVLB  0
025AC:  CALL   0596
....................                   glcd_update(); 
025B0:  CALL   0350
....................           
....................                } 
....................                break; 
025B4:  BRA    28BC
....................             } 
....................             case 6:           // AM - PM                          
....................             { 
....................                 
....................                glcd_rect(35, 45, 55, 60, YES, OFF);  
025B6:  MOVLW  23
025B8:  MOVLB  4
025BA:  MOVWF  xC3
025BC:  MOVLW  2D
025BE:  MOVWF  xC4
025C0:  MOVLW  37
025C2:  MOVWF  xC5
025C4:  MOVLW  3C
025C6:  MOVWF  xC6
025C8:  MOVLW  01
025CA:  MOVWF  xC7
025CC:  CLRF   xC8
025CE:  MOVLB  0
025D0:  CALL   157A
....................                glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
025D4:  MOVLW  23
025D6:  MOVLB  4
025D8:  MOVWF  xC3
025DA:  MOVLW  2D
025DC:  MOVWF  xC4
025DE:  MOVLW  37
025E0:  MOVWF  xC5
025E2:  MOVLW  3C
025E4:  MOVWF  xC6
025E6:  CLRF   xC7
025E8:  MOVLW  01
025EA:  MOVWF  xC8
025EC:  MOVLB  0
025EE:  CALL   157A
....................                glcd_text57(39, 49, min, 1, ON); 
025F2:  MOVLW  27
025F4:  MOVLB  4
025F6:  MOVWF  xC3
025F8:  MOVLW  31
025FA:  MOVWF  xC4
025FC:  CLRF   xC6
025FE:  MOVLW  A1
02600:  MOVWF  xC5
02602:  MOVLW  01
02604:  MOVWF  xC7
02606:  MOVWF  xC8
02608:  MOVLB  0
0260A:  CALL   0596
....................                 
....................                glcd_rect(5, 20, 25, 35, YES, OFF);  
0260E:  MOVLW  05
02610:  MOVLB  4
02612:  MOVWF  xC3
02614:  MOVLW  14
02616:  MOVWF  xC4
02618:  MOVLW  19
0261A:  MOVWF  xC5
0261C:  MOVLW  23
0261E:  MOVWF  xC6
02620:  MOVLW  01
02622:  MOVWF  xC7
02624:  CLRF   xC8
02626:  MOVLB  0
02628:  CALL   157A
....................                glcd_rect(5, 20, 25, 35, NO, ON);         //Dia 
0262C:  MOVLW  05
0262E:  MOVLB  4
02630:  MOVWF  xC3
02632:  MOVLW  14
02634:  MOVWF  xC4
02636:  MOVLW  19
02638:  MOVWF  xC5
0263A:  MOVLW  23
0263C:  MOVWF  xC6
0263E:  CLRF   xC7
02640:  MOVLW  01
02642:  MOVWF  xC8
02644:  MOVLB  0
02646:  CALL   157A
....................                glcd_text57(9, 24, dia, 1, ON); 
0264A:  MOVLW  09
0264C:  MOVLB  4
0264E:  MOVWF  xC3
02650:  MOVLW  18
02652:  MOVWF  xC4
02654:  CLRF   xC6
02656:  MOVLW  95
02658:  MOVWF  xC5
0265A:  MOVLW  01
0265C:  MOVWF  xC7
0265E:  MOVWF  xC8
02660:  MOVLB  0
02662:  CALL   0596
....................                 
....................                 
....................                 
....................                 
....................                 
....................                if ((up==1)||(down==1)) 
02666:  DECFSZ 0D,W
02668:  BRA    266C
0266A:  BRA    2670
0266C:  DECFSZ 0F,W
0266E:  BRA    2718
....................                { 
....................                   if (aop=="AM") 
02670:  MOVLW  00
02672:  MOVWF  02
02674:  MOVLW  02
02676:  MOVWF  01
02678:  MOVLW  9C
0267A:  MOVWF  00
0267C:  CLRF   03
0267E:  MOVF   00,W
02680:  SUBLW  A4
02682:  BNZ   26B8
02684:  MOVF   01,F
02686:  BNZ   26B8
02688:  MOVF   02,F
0268A:  BNZ   26B8
0268C:  MOVF   03,F
0268E:  BNZ   26B8
....................                   { 
....................                      aop = "PM"; 
02690:  CLRF   FEA
02692:  MOVLW  A4
02694:  MOVWF  FE9
02696:  MOVFF  FF2,4C3
0269A:  BCF    FF2.7
0269C:  MOVLW  00
0269E:  CALL   02A0
026A2:  TBLRD*-
026A4:  TBLRD*+
026A6:  MOVF   FF5,W
026A8:  MOVWF  FEE
026AA:  IORLW  00
026AC:  BNZ   26A4
026AE:  MOVLB  4
026B0:  BTFSC  xC3.7
026B2:  BSF    FF2.7
....................                   } 
....................                   else 
026B4:  BRA    26DC
026B6:  MOVLB  0
....................                   { 
....................                      aop="AM"; 
026B8:  CLRF   FEA
026BA:  MOVLW  A4
026BC:  MOVWF  FE9
026BE:  MOVFF  FF2,4C3
026C2:  BCF    FF2.7
026C4:  MOVLW  00
026C6:  CALL   028C
026CA:  TBLRD*-
026CC:  TBLRD*+
026CE:  MOVF   FF5,W
026D0:  MOVWF  FEE
026D2:  IORLW  00
026D4:  BNZ   26CC
026D6:  MOVLB  4
026D8:  BTFSC  xC3.7
026DA:  BSF    FF2.7
....................                   } 
....................                   glcd_rect(65, 45, 85, 60, YES, ON);        //Minuto 
026DC:  MOVLW  41
026DE:  MOVWF  xC3
026E0:  MOVLW  2D
026E2:  MOVWF  xC4
026E4:  MOVLW  55
026E6:  MOVWF  xC5
026E8:  MOVLW  3C
026EA:  MOVWF  xC6
026EC:  MOVLW  01
026EE:  MOVWF  xC7
026F0:  MOVWF  xC8
026F2:  MOVLB  0
026F4:  CALL   157A
....................                   glcd_text57(69, 49, aop, 1, OFF); 
026F8:  MOVLW  45
026FA:  MOVLB  4
026FC:  MOVWF  xC3
026FE:  MOVLW  31
02700:  MOVWF  xC4
02702:  CLRF   xC6
02704:  MOVLW  A4
02706:  MOVWF  xC5
02708:  MOVLW  01
0270A:  MOVWF  xC7
0270C:  CLRF   xC8
0270E:  MOVLB  0
02710:  CALL   0596
....................                   glcd_update(); 
02714:  CALL   0350
....................           
....................                } 
....................                 
....................                break;                                                     
02718:  BRA    28BC
....................             } 
....................             case 10:          // SET                         
....................             { 
....................                glcd_fillscreen(OFF); 
0271A:  MOVLB  4
0271C:  CLRF   xC3
0271E:  MOVLB  0
02720:  CALL   02F6
....................                glcd_text57(0, 0, MENU1, 1, ON); 
02724:  MOVLB  4
02726:  CLRF   xC3
02728:  CLRF   xC4
0272A:  CLRF   xC6
0272C:  MOVLW  25
0272E:  MOVWF  xC5
02730:  MOVLW  01
02732:  MOVWF  xC7
02734:  MOVWF  xC8
02736:  MOVLB  0
02738:  CALL   0596
....................                glcd_bar(0, 9, 127, 9, 2, ON); //div 
0273C:  MOVLB  4
0273E:  CLRF   xC3
02740:  MOVLW  09
02742:  MOVWF  xC4
02744:  MOVLW  7F
02746:  MOVWF  xC5
02748:  MOVLW  09
0274A:  MOVWF  xC6
0274C:  MOVLW  02
0274E:  MOVWF  xC7
02750:  MOVLW  01
02752:  MOVWF  xC8
02754:  MOVLB  0
02756:  CALL   079E
....................                 
....................                glcd_rect(5, 20, 25, 35, NO, ON);         //Dia     
0275A:  MOVLW  05
0275C:  MOVLB  4
0275E:  MOVWF  xC3
02760:  MOVLW  14
02762:  MOVWF  xC4
02764:  MOVLW  19
02766:  MOVWF  xC5
02768:  MOVLW  23
0276A:  MOVWF  xC6
0276C:  CLRF   xC7
0276E:  MOVLW  01
02770:  MOVWF  xC8
02772:  MOVLB  0
02774:  CALL   157A
....................                glcd_text57(9, 24, dia, 1, ON); 
02778:  MOVLW  09
0277A:  MOVLB  4
0277C:  MOVWF  xC3
0277E:  MOVLW  18
02780:  MOVWF  xC4
02782:  CLRF   xC6
02784:  MOVLW  95
02786:  MOVWF  xC5
02788:  MOVLW  01
0278A:  MOVWF  xC7
0278C:  MOVWF  xC8
0278E:  MOVLB  0
02790:  CALL   0596
....................                 
....................                glcd_rect(35, 20, 55, 35, NO, ON);        //Mes 
02794:  MOVLW  23
02796:  MOVLB  4
02798:  MOVWF  xC3
0279A:  MOVLW  14
0279C:  MOVWF  xC4
0279E:  MOVLW  37
027A0:  MOVWF  xC5
027A2:  MOVLW  23
027A4:  MOVWF  xC6
027A6:  CLRF   xC7
027A8:  MOVLW  01
027AA:  MOVWF  xC8
027AC:  MOVLB  0
027AE:  CALL   157A
....................                glcd_text57(39, 24, mes, 1, ON); 
027B2:  MOVLW  27
027B4:  MOVLB  4
027B6:  MOVWF  xC3
027B8:  MOVLW  18
027BA:  MOVWF  xC4
027BC:  CLRF   xC6
027BE:  MOVLW  98
027C0:  MOVWF  xC5
027C2:  MOVLW  01
027C4:  MOVWF  xC7
027C6:  MOVWF  xC8
027C8:  MOVLB  0
027CA:  CALL   0596
....................                 
....................                glcd_rect(65, 20, 85, 35, NO, ON);        //Ao 
027CE:  MOVLW  41
027D0:  MOVLB  4
027D2:  MOVWF  xC3
027D4:  MOVLW  14
027D6:  MOVWF  xC4
027D8:  MOVLW  55
027DA:  MOVWF  xC5
027DC:  MOVLW  23
027DE:  MOVWF  xC6
027E0:  CLRF   xC7
027E2:  MOVLW  01
027E4:  MOVWF  xC8
027E6:  MOVLB  0
027E8:  CALL   157A
....................                glcd_text57(69, 24, ao, 1, ON); 
027EC:  MOVLW  45
027EE:  MOVLB  4
027F0:  MOVWF  xC3
027F2:  MOVLW  18
027F4:  MOVWF  xC4
027F6:  CLRF   xC6
027F8:  MOVLW  9B
027FA:  MOVWF  xC5
027FC:  MOVLW  01
027FE:  MOVWF  xC7
02800:  MOVWF  xC8
02802:  MOVLB  0
02804:  CALL   0596
....................                 
....................                 
....................                glcd_rect(5, 45, 25, 60, NO, ON);         //Hora 
02808:  MOVLW  05
0280A:  MOVLB  4
0280C:  MOVWF  xC3
0280E:  MOVLW  2D
02810:  MOVWF  xC4
02812:  MOVLW  19
02814:  MOVWF  xC5
02816:  MOVLW  3C
02818:  MOVWF  xC6
0281A:  CLRF   xC7
0281C:  MOVLW  01
0281E:  MOVWF  xC8
02820:  MOVLB  0
02822:  CALL   157A
....................                glcd_text57(9, 49, hora, 1, ON); 
02826:  MOVLW  09
02828:  MOVLB  4
0282A:  MOVWF  xC3
0282C:  MOVLW  31
0282E:  MOVWF  xC4
02830:  CLRF   xC6
02832:  MOVLW  9E
02834:  MOVWF  xC5
02836:  MOVLW  01
02838:  MOVWF  xC7
0283A:  MOVWF  xC8
0283C:  MOVLB  0
0283E:  CALL   0596
....................                 
....................                glcd_rect(35, 45, 55, 60, NO, ON);        //Minuto 
02842:  MOVLW  23
02844:  MOVLB  4
02846:  MOVWF  xC3
02848:  MOVLW  2D
0284A:  MOVWF  xC4
0284C:  MOVLW  37
0284E:  MOVWF  xC5
02850:  MOVLW  3C
02852:  MOVWF  xC6
02854:  CLRF   xC7
02856:  MOVLW  01
02858:  MOVWF  xC8
0285A:  MOVLB  0
0285C:  CALL   157A
....................                glcd_text57(39, 49, min, 1, ON); 
02860:  MOVLW  27
02862:  MOVLB  4
02864:  MOVWF  xC3
02866:  MOVLW  31
02868:  MOVWF  xC4
0286A:  CLRF   xC6
0286C:  MOVLW  A1
0286E:  MOVWF  xC5
02870:  MOVLW  01
02872:  MOVWF  xC7
02874:  MOVWF  xC8
02876:  MOVLB  0
02878:  CALL   0596
....................                 
....................                glcd_rect(65, 45, 85, 60, NO, ON);        // AM/PM. 
0287C:  MOVLW  41
0287E:  MOVLB  4
02880:  MOVWF  xC3
02882:  MOVLW  2D
02884:  MOVWF  xC4
02886:  MOVLW  55
02888:  MOVWF  xC5
0288A:  MOVLW  3C
0288C:  MOVWF  xC6
0288E:  CLRF   xC7
02890:  MOVLW  01
02892:  MOVWF  xC8
02894:  MOVLB  0
02896:  CALL   157A
....................                glcd_text57(69, 49, aop, 1, ON); 
0289A:  MOVLW  45
0289C:  MOVLB  4
0289E:  MOVWF  xC3
028A0:  MOVLW  31
028A2:  MOVWF  xC4
028A4:  CLRF   xC6
028A6:  MOVLW  A4
028A8:  MOVWF  xC5
028AA:  MOVLW  01
028AC:  MOVWF  xC7
028AE:  MOVWF  xC8
028B0:  MOVLB  0
028B2:  CALL   0596
....................                 
....................                glcd_update(); 
028B6:  CALL   0350
....................                 
....................                break;                                                     
028BA:  BRA    28BC
....................             } 
....................                                                                          
....................          } 
....................        
....................        
....................                                                                           
....................       pressed = 0; 
028BC:  CLRF   08
....................       if (control==10) 
028BE:  MOVF   07,W
028C0:  SUBLW  0A
028C2:  BNZ   28C6
....................       { 
....................          return; 
028C4:  BRA    28CA
....................       } 
....................  
....................    } 
028C6:  GOTO   1CE4
.................... } 
028CA:  GOTO   2914 (RETURN)
....................  
....................  
.................... void menu_drawmain(void) 
.................... { 
....................    glcd_fillScreen(OFF); 
*
00D16:  MOVLB  4
00D18:  CLRF   xC3
00D1A:  MOVLB  0
00D1C:  CALL   02F6
....................    glcd_text57(0, 0, MENUTITLE, 1, ON); 
00D20:  MOVLB  4
00D22:  CLRF   xC3
00D24:  CLRF   xC4
00D26:  CLRF   xC6
00D28:  MOVLW  17
00D2A:  MOVWF  xC5
00D2C:  MOVLW  01
00D2E:  MOVWF  xC7
00D30:  MOVWF  xC8
00D32:  MOVLB  0
00D34:  RCALL  0596
....................    glcd_bar(0, 9, 127, 9, 2, ON); //div 
00D36:  MOVLB  4
00D38:  CLRF   xC3
00D3A:  MOVLW  09
00D3C:  MOVWF  xC4
00D3E:  MOVLW  7F
00D40:  MOVWF  xC5
00D42:  MOVLW  09
00D44:  MOVWF  xC6
00D46:  MOVLW  02
00D48:  MOVWF  xC7
00D4A:  MOVLW  01
00D4C:  MOVWF  xC8
00D4E:  MOVLB  0
00D50:  RCALL  079E
....................    glcd_text57(0, 14, MENU1, 1, ON); 
00D52:  MOVLB  4
00D54:  CLRF   xC3
00D56:  MOVLW  0E
00D58:  MOVWF  xC4
00D5A:  CLRF   xC6
00D5C:  MOVLW  25
00D5E:  MOVWF  xC5
00D60:  MOVLW  01
00D62:  MOVWF  xC7
00D64:  MOVWF  xC8
00D66:  MOVLB  0
00D68:  RCALL  0596
....................    menu_entrar(14,ON); 
00D6A:  MOVLW  0E
00D6C:  MOVLB  4
00D6E:  MOVWF  xBB
00D70:  MOVLW  01
00D72:  MOVWF  xBC
00D74:  MOVLB  0
00D76:  RCALL  0C8A
....................    glcd_text57(0, 23, MENU2, 1, ON); 
00D78:  MOVLB  4
00D7A:  CLRF   xC3
00D7C:  MOVLW  17
00D7E:  MOVWF  xC4
00D80:  CLRF   xC6
00D82:  MOVLW  33
00D84:  MOVWF  xC5
00D86:  MOVLW  01
00D88:  MOVWF  xC7
00D8A:  MOVWF  xC8
00D8C:  MOVLB  0
00D8E:  RCALL  0596
....................    glcd_text57(100, 23, UniTemp, 1, ON); 
00D90:  MOVLW  64
00D92:  MOVLB  4
00D94:  MOVWF  xC3
00D96:  MOVLW  17
00D98:  MOVWF  xC4
00D9A:  CLRF   xC6
00D9C:  MOVLW  A7
00D9E:  MOVWF  xC5
00DA0:  MOVLW  01
00DA2:  MOVWF  xC7
00DA4:  MOVWF  xC8
00DA6:  MOVLB  0
00DA8:  CALL   0596
....................    menu_entrar(23,ON); 
00DAC:  MOVLW  17
00DAE:  MOVLB  4
00DB0:  MOVWF  xBB
00DB2:  MOVLW  01
00DB4:  MOVWF  xBC
00DB6:  MOVLB  0
00DB8:  RCALL  0C8A
....................    glcd_text57(0, 32, MENU3, 1, ON); 
00DBA:  MOVLB  4
00DBC:  CLRF   xC3
00DBE:  MOVLW  20
00DC0:  MOVWF  xC4
00DC2:  CLRF   xC6
00DC4:  MOVLW  59
00DC6:  MOVWF  xC5
00DC8:  MOVLW  01
00DCA:  MOVWF  xC7
00DCC:  MOVWF  xC8
00DCE:  MOVLB  0
00DD0:  CALL   0596
....................    glcd_text57(100, 32, UniPres, 1, ON); 
00DD4:  MOVLW  64
00DD6:  MOVLB  4
00DD8:  MOVWF  xC3
00DDA:  MOVLW  20
00DDC:  MOVWF  xC4
00DDE:  CLRF   xC6
00DE0:  MOVLW  A9
00DE2:  MOVWF  xC5
00DE4:  MOVLW  01
00DE6:  MOVWF  xC7
00DE8:  MOVWF  xC8
00DEA:  MOVLB  0
00DEC:  CALL   0596
....................    menu_entrar(32,ON); 
00DF0:  MOVLW  20
00DF2:  MOVLB  4
00DF4:  MOVWF  xBB
00DF6:  MOVLW  01
00DF8:  MOVWF  xBC
00DFA:  MOVLB  0
00DFC:  RCALL  0C8A
....................    glcd_text57(0, 41, MENU4, 1, ON); 
00DFE:  MOVLB  4
00E00:  CLRF   xC3
00E02:  MOVLW  29
00E04:  MOVWF  xC4
00E06:  CLRF   xC6
00E08:  MOVLW  75
00E0A:  MOVWF  xC5
00E0C:  MOVLW  01
00E0E:  MOVWF  xC7
00E10:  MOVWF  xC8
00E12:  MOVLB  0
00E14:  CALL   0596
....................    glcd_text57(100, 41, UniVel, 1, ON); 
00E18:  MOVLW  64
00E1A:  MOVLB  4
00E1C:  MOVWF  xC3
00E1E:  MOVLW  29
00E20:  MOVWF  xC4
00E22:  CLRF   xC6
00E24:  MOVLW  AD
00E26:  MOVWF  xC5
00E28:  MOVLW  01
00E2A:  MOVWF  xC7
00E2C:  MOVWF  xC8
00E2E:  MOVLB  0
00E30:  CALL   0596
....................    menu_entrar(41,ON); 
00E34:  MOVLW  29
00E36:  MOVLB  4
00E38:  MOVWF  xBB
00E3A:  MOVLW  01
00E3C:  MOVWF  xBC
00E3E:  MOVLB  0
00E40:  RCALL  0C8A
....................    glcd_update(); 
00E42:  CALL   0350
.................... } 
00E46:  RETLW  00
....................  
....................  
.................... /*FIN**INCLUDES*/ 
....................  
....................  
.................... /****/ 
....................  
....................  
.................... /*FUNCIONES*/ 
....................  
....................  
.................... /*FIN**FUNCIONES*/ 
....................  
....................  
.................... void main() 
.................... { 
*
02D14:  CLRF   FF8
02D16:  BCF    FD0.7
02D18:  CLRF   FEA
02D1A:  CLRF   FE9
02D1C:  BSF    FB8.3
02D1E:  MOVLW  10
02D20:  MOVWF  FAF
02D22:  MOVLW  00
02D24:  MOVWF  FB0
02D26:  MOVLW  A6
02D28:  MOVWF  FAC
02D2A:  MOVLW  90
02D2C:  MOVWF  FAB
02D2E:  CLRF   06
02D30:  CLRF   07
02D32:  CLRF   08
02D34:  MOVF   FC1,W
02D36:  ANDLW  C0
02D38:  IORLW  0F
02D3A:  MOVWF  FC1
02D3C:  MOVLW  07
02D3E:  MOVWF  FB4
02D40:  CLRF   05
02D42:  MOVLW  43
02D44:  MOVWF  17
02D46:  MOVLW  6F
02D48:  MOVWF  18
02D4A:  MOVLW  6E
02D4C:  MOVWF  19
02D4E:  MOVLW  66
02D50:  MOVWF  1A
02D52:  MOVLW  69
02D54:  MOVWF  1B
02D56:  MOVLW  67
02D58:  MOVWF  1C
02D5A:  MOVLW  75
02D5C:  MOVWF  1D
02D5E:  MOVLW  72
02D60:  MOVWF  1E
02D62:  MOVLW  61
02D64:  MOVWF  1F
02D66:  MOVLW  63
02D68:  MOVWF  20
02D6A:  MOVLW  69
02D6C:  MOVWF  21
02D6E:  MOVLW  6F
02D70:  MOVWF  22
02D72:  MOVLW  6E
02D74:  MOVWF  23
02D76:  CLRF   24
02D78:  MOVLW  2D
02D7A:  MOVWF  25
02D7C:  MOVLW  46
02D7E:  MOVWF  26
02D80:  MOVLW  65
02D82:  MOVWF  27
02D84:  MOVLW  63
02D86:  MOVWF  28
02D88:  MOVLW  68
02D8A:  MOVWF  29
02D8C:  MOVLW  61
02D8E:  MOVWF  2A
02D90:  MOVLW  20
02D92:  MOVWF  2B
02D94:  MOVLW  79
02D96:  MOVWF  2C
02D98:  MOVLW  20
02D9A:  MOVWF  2D
02D9C:  MOVLW  48
02D9E:  MOVWF  2E
02DA0:  MOVLW  6F
02DA2:  MOVWF  2F
02DA4:  MOVLW  72
02DA6:  MOVWF  30
02DA8:  MOVLW  61
02DAA:  MOVWF  31
02DAC:  CLRF   32
02DAE:  MOVLW  2D
02DB0:  MOVWF  33
02DB2:  MOVLW  54
02DB4:  MOVWF  34
02DB6:  MOVLW  65
02DB8:  MOVWF  35
02DBA:  MOVLW  6D
02DBC:  MOVWF  36
02DBE:  MOVLW  70
02DC0:  MOVWF  37
02DC2:  MOVLW  65
02DC4:  MOVWF  38
02DC6:  MOVLW  72
02DC8:  MOVWF  39
02DCA:  MOVLW  61
02DCC:  MOVWF  3A
02DCE:  MOVLW  74
02DD0:  MOVWF  3B
02DD2:  MOVLW  75
02DD4:  MOVWF  3C
02DD6:  MOVLW  72
02DD8:  MOVWF  3D
02DDA:  MOVLW  61
02DDC:  MOVWF  3E
02DDE:  MOVLW  20
02DE0:  MOVWF  3F
02DE2:  MOVWF  40
02DE4:  MOVWF  41
02DE6:  CLRF   42
02DE8:  MOVLW  2D
02DEA:  MOVWF  43
02DEC:  MOVWF  44
02DEE:  MOVLW  43
02DF0:  MOVWF  45
02DF2:  MOVLW  65
02DF4:  MOVWF  46
02DF6:  MOVLW  6C
02DF8:  MOVWF  47
02DFA:  MOVLW  73
02DFC:  MOVWF  48
02DFE:  MOVLW  69
02E00:  MOVWF  49
02E02:  MOVLW  75
02E04:  MOVWF  4A
02E06:  MOVLW  73
02E08:  MOVWF  4B
02E0A:  CLRF   4C
02E0C:  MOVLW  2D
02E0E:  MOVWF  4D
02E10:  MOVWF  4E
02E12:  MOVLW  46
02E14:  MOVWF  4F
02E16:  MOVLW  61
02E18:  MOVWF  50
02E1A:  MOVLW  72
02E1C:  MOVWF  51
02E1E:  MOVLW  65
02E20:  MOVWF  52
02E22:  MOVLW  6E
02E24:  MOVWF  53
02E26:  MOVLW  68
02E28:  MOVWF  54
02E2A:  MOVLW  65
02E2C:  MOVWF  55
02E2E:  MOVLW  69
02E30:  MOVWF  56
02E32:  MOVLW  74
02E34:  MOVWF  57
02E36:  CLRF   58
02E38:  MOVLW  2D
02E3A:  MOVWF  59
02E3C:  MOVLW  50
02E3E:  MOVWF  5A
02E40:  MOVLW  72
02E42:  MOVWF  5B
02E44:  MOVLW  65
02E46:  MOVWF  5C
02E48:  MOVLW  73
02E4A:  MOVWF  5D
02E4C:  MOVLW  69
02E4E:  MOVWF  5E
02E50:  MOVLW  6F
02E52:  MOVWF  5F
02E54:  MOVLW  6E
02E56:  MOVWF  x60
02E58:  CLRF   x61
02E5A:  MOVLW  2D
02E5C:  MOVWF  x62
02E5E:  MOVWF  x63
02E60:  MOVLW  50
02E62:  MOVWF  x64
02E64:  MOVLW  61
02E66:  MOVWF  x65
02E68:  MOVLW  73
02E6A:  MOVWF  x66
02E6C:  MOVLW  63
02E6E:  MOVWF  x67
02E70:  MOVLW  61
02E72:  MOVWF  x68
02E74:  MOVLW  6C
02E76:  MOVWF  x69
02E78:  CLRF   x6A
02E7A:  MOVLW  2D
02E7C:  MOVWF  x6B
02E7E:  MOVWF  x6C
02E80:  MOVLW  4D
02E82:  MOVWF  x6D
02E84:  MOVLW  69
02E86:  MOVWF  x6E
02E88:  MOVLW  6C
02E8A:  MOVWF  x6F
02E8C:  MOVLW  69
02E8E:  MOVWF  x70
02E90:  MOVLW  62
02E92:  MOVWF  x71
02E94:  MOVLW  61
02E96:  MOVWF  x72
02E98:  MOVLW  72
02E9A:  MOVWF  x73
02E9C:  CLRF   x74
02E9E:  MOVLW  2D
02EA0:  MOVWF  x75
02EA2:  MOVLW  56
02EA4:  MOVWF  x76
02EA6:  MOVLW  65
02EA8:  MOVWF  x77
02EAA:  MOVLW  6C
02EAC:  MOVWF  x78
02EAE:  MOVLW  6F
02EB0:  MOVWF  x79
02EB2:  MOVLW  63
02EB4:  MOVWF  x7A
02EB6:  MOVLW  69
02EB8:  MOVWF  x7B
02EBA:  MOVLW  64
02EBC:  MOVWF  x7C
02EBE:  MOVLW  61
02EC0:  MOVWF  x7D
02EC2:  MOVLW  64
02EC4:  MOVWF  x7E
02EC6:  CLRF   x7F
02EC8:  MOVLW  2D
02ECA:  MOVWF  x80
02ECC:  MOVWF  x81
02ECE:  MOVLW  6D
02ED0:  MOVWF  x82
02ED2:  MOVLW  2F
02ED4:  MOVWF  x83
02ED6:  MOVLW  73
02ED8:  MOVWF  x84
02EDA:  CLRF   x85
02EDC:  MOVLW  2D
02EDE:  MOVWF  x86
02EE0:  MOVWF  x87
02EE2:  MOVLW  6B
02EE4:  MOVWF  x88
02EE6:  MOVLW  6D
02EE8:  MOVWF  x89
02EEA:  MOVLW  2F
02EEC:  MOVWF  x8A
02EEE:  MOVLW  68
02EF0:  MOVWF  x8B
02EF2:  CLRF   x8C
02EF4:  MOVLW  2D
02EF6:  MOVWF  x8D
02EF8:  MOVWF  x8E
02EFA:  MOVLW  4E
02EFC:  MOVWF  x8F
02EFE:  MOVLW  75
02F00:  MOVWF  x90
02F02:  MOVLW  64
02F04:  MOVWF  x91
02F06:  MOVLW  6F
02F08:  MOVWF  x92
02F0A:  MOVLW  73
02F0C:  MOVWF  x93
02F0E:  CLRF   x94
02F10:  MOVLW  30
02F12:  MOVWF  x95
02F14:  MOVLW  31
02F16:  MOVWF  x96
02F18:  CLRF   x97
02F1A:  MOVLW  30
02F1C:  MOVWF  x98
02F1E:  MOVLW  31
02F20:  MOVWF  x99
02F22:  CLRF   x9A
02F24:  MOVLW  30
02F26:  MOVWF  x9B
02F28:  MOVLW  31
02F2A:  MOVWF  x9C
02F2C:  CLRF   x9D
02F2E:  MOVWF  x9E
02F30:  MOVLW  30
02F32:  MOVWF  x9F
02F34:  CLRF   xA0
02F36:  MOVLW  31
02F38:  MOVWF  xA1
02F3A:  MOVLW  30
02F3C:  MOVWF  xA2
02F3E:  CLRF   xA3
02F40:  MOVLW  41
02F42:  MOVWF  xA4
02F44:  MOVLW  4D
02F46:  MOVWF  xA5
02F48:  CLRF   xA6
02F4A:  MOVLW  43
02F4C:  MOVWF  xA7
02F4E:  CLRF   xA8
02F50:  MOVLW  50
02F52:  MOVWF  xA9
02F54:  MOVLW  61
02F56:  MOVWF  xAA
02F58:  MOVLW  20
02F5A:  MOVWF  xAB
02F5C:  CLRF   xAC
02F5E:  MOVLW  6D
02F60:  MOVWF  xAD
02F62:  MOVLW  2F
02F64:  MOVWF  xAE
02F66:  MOVLW  73
02F68:  MOVWF  xAF
02F6A:  MOVLW  20
02F6C:  MOVWF  xB0
02F6E:  CLRF   xB1
02F70:  MOVLB  4
02F72:  CLRF   xB2
02F74:  CLRF   xB3
....................  
....................     
....................    glcd_init(ON);   
02F76:  MOVLW  01
02F78:  MOVWF  xB8
02F7A:  MOVLB  0
02F7C:  CALL   0408
....................  
....................    delay_ms(100); 
02F80:  MOVLW  64
02F82:  MOVLB  4
02F84:  MOVWF  xB8
02F86:  MOVLB  0
02F88:  GOTO   04B0
....................     
....................     
....................      
....................     
....................     
....................    menu_mainmenu(); 
02F8C:  BRA    2C86
....................     
....................    
....................     
.................... } 
....................  
....................  
.................... /*FUNCIONES*/ 
....................  
....................  
.................... /*FIN**FUNCIONES*/ 
02F8E:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV21 NOPUT
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP BBSIZ1K NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
